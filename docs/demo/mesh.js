(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["meshjs"] = factory();
	else
		root["meshjs"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Renderer", function() { return _renderer__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _figure2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Figure2D", function() { return _figure2d__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _mesh2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(73);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Mesh2D", function() { return _mesh2d__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _mesh_cloud__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshCloud", function() { return _mesh_cloud__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _utils_parse_font__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(39);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseFont", function() { return _utils_parse_font__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _utils_parse_color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(47);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseColor", function() { return _utils_parse_color__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _utils_env__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(37);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ENV", function() { return _utils_env__WEBPACK_IMPORTED_MODULE_6__["default"]; });

__webpack_require__(1).glMatrix.setMatrixArrayType(Array);










/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "glMatrix", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _mat2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return _mat2_js__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _mat2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2d", function() { return _mat2d_js__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return _mat3_js__WEBPACK_IMPORTED_MODULE_3__; });
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return _mat4_js__WEBPACK_IMPORTED_MODULE_4__; });
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return _quat_js__WEBPACK_IMPORTED_MODULE_5__; });
/* harmony import */ var _quat2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat2", function() { return _quat2_js__WEBPACK_IMPORTED_MODULE_6__; });
/* harmony import */ var _vec2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(11);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return _vec2_js__WEBPACK_IMPORTED_MODULE_7__; });
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(8);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return _vec3_js__WEBPACK_IMPORTED_MODULE_8__; });
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(9);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return _vec4_js__WEBPACK_IMPORTED_MODULE_9__; });












/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON", function() { return EPSILON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RANDOM", function() { return RANDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMatrixArrayType", function() { return setMatrixArrayType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadian", function() { return toRadian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LDU", function() { return LDU; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */

function fromValues(m00, m01, m10, m11) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */

function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {ReadonlyMat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {ReadonlyMat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {ReadonlyMat2} L the lower triangular matrix
 * @param {ReadonlyMat2} D the diagonal matrix
 * @param {ReadonlyMat2} U the upper triangular matrix
 * @param {ReadonlyMat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

var sub = subtract;

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/**
 * 2x3 Matrix
 * @module mat2d
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b,
 *  c, d,
 *  tx, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0,
 *  c, d, 0,
 *  tx, ty, 1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */

function fromValues(a, b, c, d, tx, ty) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */

function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/

function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2d} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat2d} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {ReadonlyMat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

var sub = subtract;

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat2d", function() { return fromMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalFromMat4", function() { return normalFromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projection", function() { return projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = subtract;

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromXRotation", function() { return fromXRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromYRotation", function() { return fromYRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromZRotation", function() { return fromZRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat2", function() { return fromQuat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaling", function() { return getScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRotation", function() { return getRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScale", function() { return fromRotationTranslationScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScaleOrigin", function() { return fromRotationTranslationScaleOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frustum", function() { return frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspective", function() { return perspective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspectiveFromFieldOfView", function() { return perspectiveFromFieldOfView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ortho", function() { return ortho; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookAt", function() { return lookAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "targetTo", function() { return targetTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxisAngle", function() { return setAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAxisAngle", function() { return getAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAngle", function() { return getAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateW", function() { return calculateW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ln", function() { return ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slerp", function() { return slerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat3", function() { return fromMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEuler", function() { return fromEuler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotationTo", function() { return rotationTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqlerp", function() { return sqlerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxes", function() { return setAxes; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9);




/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */

function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */

function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["clone"];
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["fromValues"];
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["copy"];
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["set"];
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */

var add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["add"];
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["scale"];
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["dot"];
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["lerp"];
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["length"];
/**
 * Alias for {@link quat.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["squaredLength"];
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["normalize"];
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["exactEquals"];
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["equals"];
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = function () {
  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["create"]();
  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](1, 0, 0);
  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](0, 1, 0);
  return function (out, a, b) {
    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["dot"](a, b);

    if (dot < -0.999999) {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, xUnitVec3, a);
      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__["len"](tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, yUnitVec3, a);
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = function () {
  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hermite", function() { return hermite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bezier", function() { return bezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationValues", function() { return fromRotationTranslationValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getReal", function() { return getReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDual", function() { return getDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setReal", function() { return setReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDual", function() { return setDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatAppend", function() { return rotateByQuatAppend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatPrepend", function() { return rotateByQuatPrepend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateAroundAxis", function() { return rotateAroundAxis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);



/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */

function create() {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }

  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */

function clone(a) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q a normalized quaternion
 * @param {ReadonlyVec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyVec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {ReadonlyMat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */

function fromMat4(out, a) {
  //TODO Optimize this
  var outer = _quat_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getRotation"](outer, a);
  var t = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getTranslation"](t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */

function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} real part
 */

var getReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} dual part
 */

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */

var setReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */

function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {quat2} out
 */

function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateX"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateY"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateZ"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @returns {quat2} out
 */

function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */

function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */

function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return copy(out, a);
  }

  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 * @function
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 */

function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _quat_js__WEBPACK_IMPORTED_MODULE_1__["dot"];
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */

function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */

var length = _quat_js__WEBPACK_IMPORTED_MODULE_1__["length"];
/**
 * Alias for {@link quat2.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _quat_js__WEBPACK_IMPORTED_MODULE_1__["squaredLength"];
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

function normalize(out, a) {
  var magnitude = squaredLength(a);

  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }

  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {ReadonlyQuat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */

function str(a) {
  return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat2} a the first dual quaternion.
 * @param {ReadonlyQuat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat2} a the first dual quat.
 * @param {ReadonlyQuat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2", function() { return transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2d", function() { return transformMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */

function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Renderer; });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var gl_renderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1);
/* harmony import */ var _canvas_renderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(36);
/* harmony import */ var _utils_compress__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(43);
/* harmony import */ var _utils_canvas__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(41);
/* harmony import */ var _figure2d__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(56);
/* harmony import */ var _mesh2d__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(73);
/* harmony import */ var _mesh_cloud__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(45);
/* harmony import */ var _utils_transform__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(78);
/* harmony import */ var _utils_env__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(37);
/* harmony import */ var _utils_shader_creator__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(82);





__webpack_require__(1).glMatrix.setMatrixArrayType(Array);

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }












var defaultOpts = {
  autoUpdate: false,
  // premultipliedAlpha: true,
  preserveDrawingBuffer: false,
  // depth: false,
  // antialias: false,
  bufferSize: 1500
};
var defaultPassVertex = "attribute vec3 a_vertexPosition;\nattribute vec3 a_vertexTextureCoord;\nvarying vec3 vTextureCoord;\nuniform mat3 viewMatrix;\nuniform mat3 projectionMatrix;\n\nvoid main() {\n  gl_PointSize = 1.0;\n  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);\n  gl_Position = vec4(pos.xy, 1.0, 1.0);    \n  vTextureCoord = a_vertexTextureCoord;              \n}\n";
var defaultPassFragment = "precision mediump float;\nvarying vec3 vTextureCoord;\nuniform sampler2D u_texSampler;\nvoid main() {\n  gl_FragColor = texture2D(u_texSampler, vTextureCoord.xy);\n}\n";

var _glRenderer = Symbol('glRenderer');

var _canvasRenderer = Symbol('canvasRenderer');

var _options = Symbol('options');

var _globalTransform = Symbol('globalTransform');

var _applyGlobalTransform = Symbol('applyGlobalTransform');

var _canvas = Symbol('canvas');

function draw(renderer) {
  var gl = renderer.gl;
  var fbo = renderer.fbo;

  if (fbo) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
  }

  renderer._draw();

  if (fbo) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
}

function drawFilterContext(renderer, filterContext, width, height) {
  var filterTexture = renderer.createTexture(filterContext.canvas);
  var contours = [[[0, 0], [width, 0], [width, height], [0, height], [0, 0]]];
  contours.closed = true;
  var filterMesh = new _mesh2d__WEBPACK_IMPORTED_MODULE_10__["default"]({
    contours: contours
  });
  filterMesh.setTexture(filterTexture);
  renderer.setMeshData([filterMesh.meshData]);
  draw(renderer);
  filterTexture.delete();
  filterContext.clearRect(0, 0, width, height);
  delete filterContext._filter;
}

var Renderer = /*#__PURE__*/function () {
  function Renderer(canvas) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default()(this, Renderer);

    var contextType = opts.contextType;

    if (!contextType) {
      if (typeof WebGL2RenderingContext === 'function') {
        contextType = 'webgl2';
      } else if (typeof WebGLRenderingContext === 'function') {
        contextType = 'webgl';
      } else {
        contextType = '2d';
      }
    }

    if (!canvas.getContext) {
      // 小程序
      var context = canvas;
      canvas = {
        getContext: function getContext() {
          return context;
        },
        width: opts.width,
        height: opts.height
      };
      context.canvas = canvas;
      contextType = '2d';
    }

    this[_canvas] = canvas;

    if (contextType !== 'webgl' && contextType !== 'webgl2' && contextType !== '2d') {
      throw new Error("Unknown context type ".concat(contextType));
    }

    opts.contextType = contextType;
    this[_options] = Object.assign({}, defaultOpts, opts);

    if (contextType === 'webgl' || contextType === 'webgl2') {
      if (contextType === 'webgl2') this[_options].webgl2 = true;
      var renderer = new gl_renderer__WEBPACK_IMPORTED_MODULE_4__["default"](canvas, this[_options]);

      if (contextType === 'webgl2' && !renderer.isWebGL2) {
        // webgl2 may disabled by browser settings
        opts.contextType = 'webgl';
      }

      Object(_utils_shader_creator__WEBPACK_IMPORTED_MODULE_14__["createShaders"])(renderer);
      Object(_utils_shader_creator__WEBPACK_IMPORTED_MODULE_14__["applyShader"])(renderer);
      Object(_utils_shader_creator__WEBPACK_IMPORTED_MODULE_14__["createCloudShaders"])(renderer);
      var gl = renderer.gl; // gl.clearColor(1.0, 1.0, 1.0, 1.0);
      // gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);

      gl.clearColor(0.0, 0.0, 0.0, 0.0);
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      this[_glRenderer] = renderer;
    } else {
      this[_canvasRenderer] = new _canvas_renderer__WEBPACK_IMPORTED_MODULE_6__["default"](canvas, this[_options]);
    }

    this[_globalTransform] = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    this.updateResolution();
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default()(Renderer, [{
    key: _applyGlobalTransform,
    value: function value() {
      var renderer = this[_glRenderer] || this[_canvasRenderer];

      if (this[_glRenderer]) {
        var _this$canvas = this.canvas,
            width = _this$canvas.width,
            height = _this$canvas.height;
        renderer.uniforms.viewMatrix = this.viewMatrix;
        renderer.uniforms.projectionMatrix = this.projectionMatrix;
        renderer.uniforms.u_resolution = [width, height];
      }
    }
  }, {
    key: "updateResolution",
    value: function updateResolution() {
      var _this$canvas2 = this.canvas,
          width = _this$canvas2.width,
          height = _this$canvas2.height;
      var m1 = [// translation
      1, 0, 0, 0, 1, 0, -width / 2, -height / 2, 1];
      var m2 = [// scale
      2 / width, 0, 0, 0, -2 / height, 0, 0, 0, 1];
      var m3 = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), m2, m1);
      this.projectionMatrix = m3;

      if (this[_glRenderer]) {
        this[_glRenderer].gl.viewport(0, 0, width, height);
      }
    }
  }, {
    key: "createTexture",
    value: function createTexture(img, opts) {
      var renderer = this[_glRenderer] || this[_canvasRenderer];
      return renderer.createTexture(img, opts);
    }
    /* async */

  }, {
    key: "loadTexture",
    value: function loadTexture(textureURL) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$useImageBitmap = _ref.useImageBitmap,
          useImageBitmap = _ref$useImageBitmap === void 0 ? false : _ref$useImageBitmap;

      var renderer = this[_glRenderer] || this[_canvasRenderer];
      return renderer.loadTexture(textureURL, {
        useImageBitmap: useImageBitmap
      });
    }
  }, {
    key: "createText",
    value: function createText(text) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$font = _ref2.font,
          font = _ref2$font === void 0 ? '16px arial' : _ref2$font,
          _ref2$fillColor = _ref2.fillColor,
          fillColor = _ref2$fillColor === void 0 ? null : _ref2$fillColor,
          _ref2$strokeColor = _ref2.strokeColor,
          strokeColor = _ref2$strokeColor === void 0 ? null : _ref2$strokeColor,
          _ref2$strokeWidth = _ref2.strokeWidth,
          strokeWidth = _ref2$strokeWidth === void 0 ? 1 : _ref2$strokeWidth;

      if (this[_glRenderer]) {
        var img = _utils_env__WEBPACK_IMPORTED_MODULE_13__["default"].createText(text, {
          font: font,
          fillColor: fillColor,
          strokeColor: strokeColor,
          strokeWidth: strokeWidth
        });
        return {
          image: this.createTexture(img.image),
          rect: img.rect
        };
      }

      return {
        _img: {
          font: font,
          fillColor: fillColor,
          strokeColor: strokeColor,
          strokeWidth: strokeWidth,
          text: text
        }
      };
    }
  }, {
    key: "createProgram",
    value: function createProgram() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          vertex = _ref3.vertex,
          fragment = _ref3.fragment,
          options = _ref3.options;

      if (this[_glRenderer]) {
        var program = this[_glRenderer].compileSync(fragment, vertex);

        program._attribOpts = options;
        return program;
      }

      throw new Error('Context 2D cannot create webgl program.');
    }
  }, {
    key: "createPassProgram",
    value: function createPassProgram() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref4$vertex = _ref4.vertex,
          vertex = _ref4$vertex === void 0 ? defaultPassVertex : _ref4$vertex,
          _ref4$fragment = _ref4.fragment,
          fragment = _ref4$fragment === void 0 ? defaultPassFragment : _ref4$fragment,
          options = _ref4.options;

      return this.createProgram({
        vertex: vertex,
        fragment: fragment,
        options: options
      });
    }
  }, {
    key: "useProgram",
    value: function useProgram(program) {
      var attributeOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this[_glRenderer]) {
        var attrOpts = Object.assign({}, program._attribOpts, attributeOptions);
        return this[_glRenderer].useProgram(program, attrOpts);
      }

      throw new Error('Context 2D cannot use webgl program.');
    }
  }, {
    key: "deleteTexture",
    value: function deleteTexture(texture) {
      var renderer = this[_glRenderer] || this[_canvasRenderer];
      return renderer.deleteTexture(texture);
    }
  }, {
    key: "clear",
    value: function clear() {
      if (this[_glRenderer]) {
        var gl = this[_glRenderer].gl;
        gl.clear(gl.COLOR_BUFFER_BIT);
      } else {
        var _this$_canvasRenderer;

        (_this$_canvasRenderer = this[_canvasRenderer]).clear.apply(_this$_canvasRenderer, arguments);
      }
    }
  }, {
    key: "drawMeshCloud",
    value: function drawMeshCloud(cloud) {
      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref5$clear = _ref5.clear,
          clear = _ref5$clear === void 0 ? false : _ref5$clear,
          _ref5$program = _ref5.program,
          drawProgram = _ref5$program === void 0 ? null : _ref5$program;

      var renderer = this[_glRenderer] || this[_canvasRenderer]; // if(!this.isWebGL2) throw new Error('Only webgl2 context support drawMeshCloud.');

      var program = drawProgram || cloud.program;

      if (this[_glRenderer]) {
        var gl = renderer.gl;
        if (clear) gl.clear(gl.COLOR_BUFFER_BIT);

        if (!program) {
          var mesh = cloud.mesh.meshData;
          var hasTexture = !!mesh.uniforms.u_texSampler;
          var hasFilter = !!mesh.uniforms.u_filterFlag;
          var hasGradient = !!mesh.uniforms.u_radialGradientVector;
          var hasCloudColor = cloud.hasCloudColor;
          var hasCloudFilter = cloud.hasCloudFilter;
          var hasClipPath = !!mesh.uniforms.u_clipSampler;
          Object(_utils_shader_creator__WEBPACK_IMPORTED_MODULE_14__["applyCloudShader"])(renderer, {
            hasTexture: hasTexture,
            hasFilter: hasFilter,
            hasGradient: hasGradient,
            hasCloudColor: hasCloudColor,
            hasCloudFilter: hasCloudFilter,
            hasClipPath: hasClipPath
          });
        } else if (renderer.program !== program) {
          this.useProgram(program, {
            a_color: {
              type: 'UNSIGNED_BYTE',
              normalize: true
            },
            a_fillCloudColor: {
              type: 'UNSIGNED_BYTE',
              normalize: true
            },
            a_strokeCloudColor: {
              type: 'UNSIGNED_BYTE',
              normalize: true
            },
            a_frameIndex: {
              type: 'UNSIGNED_BYTE',
              normalize: false
            }
          });
        }

        this[_applyGlobalTransform]();

        renderer.setMeshData([cloud.meshData]);
        if (cloud.beforeRender) cloud.beforeRender(gl, cloud);
        draw(renderer);
        if (cloud.afterRender) cloud.afterRender(gl, cloud);
      } else {
        renderer.setTransform(this.globalTransformMatrix);
        renderer.drawMeshCloud(cloud, {
          clear: clear,
          hook: false
        });
      }
    }
  }, {
    key: "drawMeshes",
    value: function drawMeshes(meshes) {
      var _this = this;

      var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref6$clear = _ref6.clear,
          clear = _ref6$clear === void 0 ? false : _ref6$clear,
          _ref6$program = _ref6.program,
          drawProgram = _ref6$program === void 0 ? null : _ref6$program;

      // eslint-disable-line complexity
      var renderer = this[_glRenderer] || this[_canvasRenderer];

      if (this[_glRenderer]) {
        (function () {
          var oldFBO = renderer.fbo;
          var meshData = Object(_utils_compress__WEBPACK_IMPORTED_MODULE_7__["default"])(_this, meshes, drawProgram == null);
          var gl = renderer.gl;
          if (clear) gl.clear(gl.COLOR_BUFFER_BIT);
          var hasGlobalTransform = !Object(_utils_transform__WEBPACK_IMPORTED_MODULE_12__["isUnitTransform"])(_this.globalTransformMatrix);
          _this._drawCalls = 0;

          var _iterator = _createForOfIteratorHelper(meshData),
              _step;

          try {
            var _loop = function _loop() {
              var mesh = _step.value;
              // eslint-disable-line no-restricted-syntax
              _this._drawCalls++;
              var program = drawProgram || mesh.program;

              if (mesh instanceof _mesh_cloud__WEBPACK_IMPORTED_MODULE_11__["default"]) {
                _this.drawMeshCloud(mesh, {
                  clear: clear,
                  program: program
                }); // continue; // eslint-disable-line no-continue

              } else {
                var _this$canvas3 = _this.canvas,
                    width = _this$canvas3.width,
                    height = _this$canvas3.height;
                if (mesh.beforeRender) mesh.beforeRender(gl, mesh);

                if (mesh.pass.length) {
                  if (!_this.fbo || _this.fbo.width !== width || _this.fbo.height !== height) {
                    _this.fbo = {
                      width: width,
                      height: height,
                      target: renderer.createFBO(),
                      buffer: renderer.createFBO(),
                      swap: function swap() {
                        var _ref7 = [this.buffer, this.target];
                        this.target = _ref7[0];
                        this.buffer = _ref7[1];
                      }
                    };
                  }

                  renderer.bindFBO(_this.fbo.target);
                }

                if (!program && mesh.filterCanvas) {
                  // 有一些滤镜用shader不好实现：blur、drop-shadow、url
                  Object(_utils_shader_creator__WEBPACK_IMPORTED_MODULE_14__["applyShader"])(renderer, {
                    hasTexture: true
                  });
                  var filterContext = _this.filterContext;

                  if (!filterContext) {
                    var canvas = _utils_env__WEBPACK_IMPORTED_MODULE_13__["default"].createCanvas(width, height);
                    filterContext = canvas.getContext('2d');
                    _this.filterContext = filterContext;
                  }

                  var originalMesh = meshes[mesh.packIndex];
                  var currentFilter = originalMesh.filter;
                  var nextMesh = meshes[mesh.packIndex + 1];
                  var previousMesh = meshes[mesh.packIndex - 1];

                  if ((!previousMesh || !previousMesh.filterCanvas || previousMesh.filter !== currentFilter) && (!nextMesh || !nextMesh.filterCanvas || nextMesh.filter !== currentFilter)) {
                    if (hasGlobalTransform) {
                      filterContext.save(); // filterContext.transform(...this.globalTransformMatrix);

                      Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_8__["drawMesh2D"])(originalMesh, filterContext, false);
                      filterContext.restore();
                      Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_8__["applyFilter"])(filterContext, currentFilter);
                    } else {
                      Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_8__["drawMesh2D"])(originalMesh, filterContext, true);
                    }

                    _this[_applyGlobalTransform]();

                    drawFilterContext(renderer, filterContext, width, height);
                  } else {
                    if (hasGlobalTransform) {
                      filterContext.save(); // filterContext.transform(...this.globalTransformMatrix);
                    }

                    Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_8__["drawMesh2D"])(originalMesh, filterContext, false);

                    if (hasGlobalTransform) {
                      filterContext.restore();
                    }

                    if (!nextMesh || !nextMesh.filterCanvas || originalMesh.filter !== nextMesh.filter) {
                      Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_8__["applyFilter"])(filterContext, currentFilter);

                      _this[_applyGlobalTransform]();

                      drawFilterContext(renderer, filterContext, width, height);
                    }
                  }
                } else {
                  if (!program) {
                    var hasTexture = !!mesh.uniforms.u_texSampler;
                    var hasFilter = !!mesh.uniforms.u_filterFlag;
                    var hasGradient = !!mesh.uniforms.u_radialGradientVector;
                    var hasClipPath = !!mesh.uniforms.u_clipSampler;
                    Object(_utils_shader_creator__WEBPACK_IMPORTED_MODULE_14__["applyShader"])(renderer, {
                      hasTexture: hasTexture,
                      hasFilter: hasFilter,
                      hasGradient: hasGradient,
                      hasClipPath: hasClipPath
                    });
                  } else if (renderer.program !== program) {
                    _this.useProgram(program, {
                      a_color: {
                        type: 'UNSIGNED_BYTE',
                        normalize: true
                      }
                    });
                  }

                  if (mesh.filterCanvas) {
                    console.warn('User program ignored some filter effects.');
                  }

                  _this[_applyGlobalTransform]();

                  renderer.setMeshData([mesh]);
                  draw(renderer);
                }

                if (mesh.pass.length) {
                  var len = mesh.pass.length;
                  mesh.pass.forEach(function (pass, idx) {
                    pass.blend = mesh.enableBlend;
                    pass.setTexture(renderer.fbo.texture);
                    if (idx === len - 1) renderer.bindFBO(oldFBO);else {
                      _this.fbo.swap();

                      renderer.bindFBO(_this.fbo.target);
                    }
                    if (pass.program) renderer.useProgram(pass.program);else {
                      _this.defaultPassProgram = _this.defaultPassProgram || _this.createPassProgram();
                      renderer.useProgram(_this.defaultPassProgram);
                    }
                    renderer.setMeshData([pass.meshData]);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    draw(renderer);
                  });
                }

                if (mesh.afterRender) mesh.afterRender(gl, mesh);
              }
            };

            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              _loop();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        })();
      } else {
        renderer.setTransform(this.globalTransformMatrix);
        renderer.drawMeshes(meshes, {
          clear: clear
        });
      }
    }
  }, {
    key: "drawImage",
    value: function drawImage(image) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var argLength = args.length;

      if (argLength < 2) {
        throw new TypeError("Failed to execute 'drawImage' on 'Renderer': 3 arguments required, but only ".concat(args.length + 1, " present."));
      }

      if (argLength !== 2 && argLength !== 4 && argLength !== 8) {
        throw new TypeError("Failed to execute 'drawImage' on 'Renderer': Valid arities are: [3, 5, 9], but ".concat(args.length + 1, " arguments provided."));
      }

      var rect = null;
      var srcRect = null;

      if (argLength === 2) {
        // drawImage(image, dx, dy)
        rect = [args[0], args[1], image.width, image.height];
      } else if (argLength === 4) {
        // drawImage(image, dx, dy, dWidth, dHeight)
        rect = args;
      } else if (argLength === 8) {
        // drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
        srcRect = args.slice(0, 4);
        rect = args.slice(4);
      }

      var texture = this.createTexture(image);
      var _this$canvas4 = this.canvas,
          width = _this$canvas4.width,
          height = _this$canvas4.height;
      var figure = new _figure2d__WEBPACK_IMPORTED_MODULE_9__["default"]();
      figure.rect(rect[0], rect[1], width, height);
      var mesh = new _mesh2d__WEBPACK_IMPORTED_MODULE_10__["default"](figure, {
        width: width,
        height: height
      });
      mesh.setTexture(texture, {
        rect: rect,
        srcRect: srcRect
      });
      this.drawMeshes([mesh]);
      this.deleteTexture(texture);
    }
  }, {
    key: "setGlobalTransform",
    value: function setGlobalTransform() {
      this[_globalTransform] = [arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], 0, arguments.length <= 2 ? undefined : arguments[2], arguments.length <= 3 ? undefined : arguments[3], 0, arguments.length <= 4 ? undefined : arguments[4], arguments.length <= 5 ? undefined : arguments[5], 1];
      return this;
    }
  }, {
    key: "globalTransform",
    value: function globalTransform() {
      var transform = this[_globalTransform];

      for (var _len2 = arguments.length, m = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        m[_key2] = arguments[_key2];
      }

      this[_globalTransform] = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), transform, m);
      return this;
    }
  }, {
    key: "globalTranslate",
    value: function globalTranslate(x, y) {
      var m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].create();
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), m, [x, y]);
      return this.globalTransform.apply(this, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(m));
    }
  }, {
    key: "globalRotate",
    value: function globalRotate(rad) {
      var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0],
          _ref9 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref8, 2),
          ox = _ref9[0],
          oy = _ref9[1];

      var m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].create();
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), m, [ox, oy]);
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].rotate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), m, rad);
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), m, [-ox, -oy]);
      return this.globalTransform.apply(this, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(m));
    }
  }, {
    key: "globalScale",
    value: function globalScale(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;

      var _ref10 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0],
          _ref11 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref10, 2),
          ox = _ref11[0],
          oy = _ref11[1];

      var m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].create();
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), m, [ox, oy]);
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].scale(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), m, [x, y]);
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), m, [-ox, -oy]);
      return this.globalTransform.apply(this, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(m));
    }
  }, {
    key: "globalSkew",
    value: function globalSkew(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;

      var _ref12 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0],
          _ref13 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref12, 2),
          ox = _ref13[0],
          oy = _ref13[1];

      var m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].create();
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), m, [ox, oy]);
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), m, gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].fromValues(1, Math.tan(y), Math.tan(x), 1, 0, 0));
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].translate(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), m, [-ox, -oy]);
      return this.globalTransform.apply(this, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(m));
    }
  }, {
    key: "transformPoint",
    value: function transformPoint(x, y, matrix) {
      var m = this.globalTransformMatrix;
      if (matrix) m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat3"].multiply(Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0), m, matrix);
      var newX = x * m[0] + y * m[2] + m[4];
      var newY = x * m[1] + y * m[3] + m[5];
      return [newX, newY];
    }
  }, {
    key: "canvas",
    get: function get() {
      return this[_canvas];
    }
  }, {
    key: "canvasRenderer",
    get: function get() {
      return this[_canvasRenderer];
    }
  }, {
    key: "glRenderer",
    get: function get() {
      return this[_glRenderer];
    }
  }, {
    key: "isWebGL2",
    get: function get() {
      return this[_glRenderer] && this[_glRenderer].isWebGL2;
    }
  }, {
    key: "options",
    get: function get() {
      return this[_options];
    }
  }, {
    key: "globalTransformMatrix",
    get: function get() {
      var m = this[_globalTransform];
      return [m[0], m[1], m[3], m[4], m[6], m[7]];
    }
  }, {
    key: "viewMatrix",
    get: function get() {
      return this[_globalTransform];
    }
  }]);

  return Renderer;
}();



/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(14);

var iterableToArrayLimit = __webpack_require__(15);

var unsupportedIterableToArray = __webpack_require__(16);

var nonIterableRest = __webpack_require__(18);

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),
/* 14 */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),
/* 15 */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(17);

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),
/* 17 */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(20);

var iterableToArray = __webpack_require__(21);

var unsupportedIterableToArray = __webpack_require__(16);

var nonIterableSpread = __webpack_require__(22);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(17);

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),
/* 23 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),
/* 24 */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
__webpack_require__(1).glMatrix.setMatrixArrayType(Array);


/* harmony default export */ __webpack_exports__["default"] = (_renderer__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Renderer; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(23);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(30);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(31);
/* harmony import */ var _default_vert_glsl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(33);
/* harmony import */ var _default_frag_glsl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(34);
/* harmony import */ var _default_feeback_vert_glsl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(35);








__webpack_require__(1).glMatrix.setMatrixArrayType(Array);





var GLSL_LIBS = {};

function mapTextureCoordinate(positions) {
  var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  var texVertexData = [];
  var len = positions.length;

  for (var i = 0; i < len; i++) {
    if (i % size < 2) texVertexData.push(0.5 * (positions[i] + 1));
  }

  return texVertexData;
}

function clearBuffers(gl, program) {
  var buffers = program._buffers;
  Object.values(buffers).forEach(function (buffer) {
    gl.deleteBuffer(buffer);
  });
  program._buffers = {};
}

function bindTexture(gl, texture, i) {
  gl.activeTexture(gl.TEXTURE0 + i);

  if (Array.isArray(texture._img)) {
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
  } else {
    gl.bindTexture(gl.TEXTURE_2D, texture);
  }

  return texture;
}

var uniformTypeMap = {
  int: '1i',
  ivec2: '2i',
  ivec3: '3i',
  ivec4: '4i',
  float: '1f',
  vec2: '2f',
  vec3: '3f',
  vec4: '4f',
  mat2: 'Matrix2fv',
  mat3: 'Matrix3fv',
  mat4: 'Matrix4fv',
  sampler1D: 'sampler1D',
  sampler2D: 'sampler2D',
  sampler3D: 'sampler3D',
  samplerCube: 'samplerCube',
  sampler1DShadow: 'sampler1DShadow',
  sampler2DShadow: 'sampler2DShadow',
  sampler2DRect: 'sampler2DRect',
  sampler2DRectShadow: 'sampler2DRectShadow'
};

var Renderer = /*#__PURE__*/function () {
  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5___default()(Renderer, null, [{
    key: "addLibs",
    value: function addLibs() {
      var libs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      Object.assign(GLSL_LIBS, libs);
    }
  }, {
    key: "FLOAT",
    value: function FLOAT(points, buffer) {
      return Object(_helpers__WEBPACK_IMPORTED_MODULE_7__["pointsToBuffer"])(points, Float32Array, buffer);
    }
  }, {
    key: "UNSIGNED_BYTE",
    value: function UNSIGNED_BYTE(points, buffer) {
      return Object(_helpers__WEBPACK_IMPORTED_MODULE_7__["pointsToBuffer"])(points, Uint8Array, buffer);
    }
  }, {
    key: "UNSIGNED_SHORT",
    value: function UNSIGNED_SHORT(points, buffer) {
      return Object(_helpers__WEBPACK_IMPORTED_MODULE_7__["pointsToBuffer"])(points, Uint16Array, buffer);
    }
  }, {
    key: "BYTE",
    value: function BYTE(points, buffer) {
      return Object(_helpers__WEBPACK_IMPORTED_MODULE_7__["pointsToBuffer"])(points, Int8Array, buffer);
    }
  }, {
    key: "SHORT",
    value: function SHORT(points, buffer) {
      return Object(_helpers__WEBPACK_IMPORTED_MODULE_7__["pointsToBuffer"])(points, Int16Array, buffer);
    }
  }]);

  function Renderer(canvas) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4___default()(this, Renderer);

    this.options = Object.assign({}, Renderer.defaultOptions, opts);
    this.canvas = canvas;
    var gl;

    if (this.options.webgl2) {
      gl = canvas.getContext('webgl2', this.options);
    }

    if (gl == null) {
      gl = Object(_helpers__WEBPACK_IMPORTED_MODULE_7__["setupWebGL"])(canvas, this.options);
      this.aia_ext = gl.getExtension('ANGLE_instanced_arrays');
    }

    this.gl = gl;
    gl.viewport(0, 0, canvas.width, canvas.height); // gl.clearColor(1.0, 1.0, 1.0, 1.0);
    // gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    this.programs = [];
    this._events = {};
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5___default()(Renderer, [{
    key: "_declareUniform",
    // WebGLRenderingContext.uniform[1234][fi][v]()
    // WebGLRenderingContext.uniformMatrix[234]fv()
    value: function _declareUniform(program, name) {
      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '1f';
      var gl = this.gl;
      var uniform = gl.getUniformLocation(program, name);
      var value;
      var that = this;

      if (/^sampler/.test(type)) {
        var samplerMap = program._samplerMap;
        var textures = program._bindTextures;
        Object.defineProperty(program.uniforms, name, {
          get: function get() {
            return value;
          },
          set: function set(v) {
            value = v;
            var idx = samplerMap[name] != null ? samplerMap[name] : textures.length;
            textures[idx] = v;
            bindTexture(gl, v, idx);

            if (!samplerMap[name]) {
              samplerMap[name] = idx;
              gl.uniform1i(uniform, idx);
            } // gl.bindTexture(gl.TEXTURE_2D, null);


            if (that.options.autoUpdate) that.update();
          },
          configurable: false,
          enumerable: true
        });
      } else {
        var isMatrix = type.indexOf('Matrix') === 0;
        var isTypeV = !isMatrix && /v$/.test(type);
        var setUniform = gl["uniform".concat(type)].bind(gl);
        Object.defineProperty(program.uniforms, name, {
          get: function get() {
            return value;
          },
          set: function set(v) {
            value = v;

            if (typeof v === 'number') {
              v = [v];
            }

            if (isMatrix) setUniform(uniform, false, v);else if (isTypeV) setUniform(uniform, v);else setUniform.apply(void 0, [uniform].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3___default()(v)));
            if (that.options.autoUpdate) that.update();
          },
          configurable: false,
          enumerable: true
        });
      }
    }
  }, {
    key: "_draw",
    value: function _draw() {
      var _this = this;

      var program = this.program;
      program.meshData.forEach(function (meshData, meshIndex) {
        var positions = meshData.positions,
            cells = meshData.cells,
            instanceCount = meshData.instanceCount,
            cellsCount = meshData.cellsCount,
            attributes = meshData.attributes,
            uniforms = meshData.uniforms,
            textureCoord = meshData.textureCoord,
            enableBlend = meshData.enableBlend;
        var gl = _this.gl;
        var mode = meshData.mode != null ? meshData.mode : gl.TRIANGLES;

        if (typeof mode === 'string') {
          mode = gl[mode];
        }

        if (enableBlend) gl.enable(gl.BLEND);else gl.disable(gl.BLEND);
        gl.bindBuffer(gl.ARRAY_BUFFER, program._buffers.verticesBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        if (cells) {
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, program._buffers.cellsBuffer);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cells, gl.STATIC_DRAW);
        }

        var locations = [];

        if (attributes) {
          Object.values(attributes).forEach(function (_ref) {
            var name = _ref.name,
                data = _ref.data,
                divisor = _ref.divisor;
            gl.bindBuffer(gl.ARRAY_BUFFER, program._buffers[name]);
            gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

            if (divisor != null) {
              var location = gl.getAttribLocation(program, name);

              if (location >= 0) {
                gl.enableVertexAttribArray(location);
                locations.push(location);

                if (gl.vertexAttribDivisor) {
                  gl.vertexAttribDivisor(location, divisor);
                } else if (_this.aia_ext) {
                  _this.aia_ext.vertexAttribDivisorANGLE(location, divisor);
                }
              }
            }
          });
        }

        if (uniforms) {
          Object.entries(uniforms).forEach(function (_ref2) {
            var _ref3 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref2, 2),
                key = _ref3[0],
                value = _ref3[1];

            _this.uniforms[key] = value;
          });
        }

        var count;

        if (!cells) {
          var dimension = program._dimension;
          count = positions.length / dimension;
        }

        if (program._enableTextures && program._buffers.texCoordBuffer) {
          var texVertexData = textureCoord || mapTextureCoordinate(positions, program._dimension);
          gl.bindBuffer(gl.ARRAY_BUFFER, program._buffers.texCoordBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, Renderer.FLOAT(texVertexData), gl.STATIC_DRAW);
        }

        if (instanceCount != null) {
          if (cells) {
            if (gl.drawElementsInstanced) {
              gl.drawElementsInstanced(mode, cellsCount, gl.UNSIGNED_SHORT, 0, instanceCount);
            } else if (_this.aia_ext) {
              _this.aia_ext.drawElementsInstancedANGLE(mode, cellsCount, gl.UNSIGNED_SHORT, 0, instanceCount);
            }
          } else if (gl.drawArraysInstanced) {
            gl.drawArraysInstanced(mode, 0, count, instanceCount);
          } else {
            _this.aia_ext.drawArraysInstancedANGLE(mode, 0, count, instanceCount);
          }

          locations.forEach(function (location) {
            if (gl.vertexAttribDivisor) {
              gl.vertexAttribDivisor(location, null);
            } else if (_this.aia_ext) {
              _this.aia_ext.vertexAttribDivisorANGLE(location, null);
            }
          });
        } else if (cells) {
          gl.drawElements(mode, cellsCount, gl.UNSIGNED_SHORT, 0);
        } else {
          gl.drawArrays(mode, 0, count);
        }
      });
    }
  }, {
    key: "deleteProgram",
    value: function deleteProgram(program) {
      var gl = this.gl;

      if (this.program === program) {
        this.startRender = false;

        if (this._renderFrameID) {
          cancelAnimationFrame(this._renderFrameID);
          delete this._renderFrameID;
        }

        gl.useProgram(null);
      }

      var idx = this.programs.indexOf(program);

      if (idx >= 0) {
        this.programs.splice(idx, 1);
      }

      clearBuffers(gl, program);
      gl.deleteProgram(program);
    }
    /**
      [{
        positions: ...
        cells: ...
        textureCoord: ...
        attributes: {name: {data:..., normalize: true}},
        uniforms: ...
      }]
     */

  }, {
    key: "setMeshData",
    value: function setMeshData(data) {
      var _this2 = this;

      if (!Array.isArray(data)) {
        data = [data];
      }

      var program = this.program;
      program.meshData = data.map(function (_ref4) {
        var mode = _ref4.mode,
            positions = _ref4.positions,
            instanceCount = _ref4.instanceCount,
            cells = _ref4.cells,
            cellsCount = _ref4.cellsCount,
            attributes = _ref4.attributes,
            uniforms = _ref4.uniforms,
            textureCoord = _ref4.textureCoord,
            enableBlend = _ref4.enableBlend;
        var meshData = {
          positions: Renderer.FLOAT(positions),
          uniforms: uniforms,
          enableBlend: !!enableBlend,
          textureCoord: Renderer.FLOAT(textureCoord)
        };

        if (cells) {
          meshData.cells = Renderer.USHORT(cells);
          meshData.cellsCount = cellsCount || meshData.cells.length;
        }

        if (mode != null) {
          meshData.mode = mode;
        }

        if (instanceCount != null) {
          if (!_this2.isWebGL2 && !_this2.aia_ext) throw new Error('Cannot use instanceCount in this rendering context, use webgl2 context instead.');else meshData.instanceCount = instanceCount;
        }

        if (attributes) {
          var copied = {};
          Object.entries(attributes).forEach(function (_ref5) {
            var _ref6 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref5, 2),
                key = _ref6[0],
                value = _ref6[1];

            if (!program._attribute[key]) {
              // throw new Error(`Invalid attribute ${key}.`);
              if (false) {}
              program._attribute[key] = 'ignored';
            } else if (program._attribute[key] !== 'ignored') {
              var _program$_attribute$k = program._attribute[key],
                  name = _program$_attribute$k.name,
                  type = _program$_attribute$k.type;
              var buffer = value.data || value;

              if (Array.isArray(buffer)) {
                buffer = Renderer[type](buffer);
              }

              copied[key] = {
                name: name,
                data: buffer
              };

              if (value.divisor != null) {
                if (!_this2.isWebGL2 && !_this2.aia_ext) throw new Error('Cannot use divisor in this rendering context, use webgl2 context instead.');else copied[key].divisor = value.divisor;
              }
            }
          });
          meshData.attributes = copied;
        }

        return meshData;
      });
      if (this.options.autoUpdate) this.update();
    }
  }, {
    key: "createProgram",
    value: function createProgram(fragmentShader, vertexShader) {
      var _this3 = this;

      // this.deleteProgram();
      // this._events = {};
      var enableTextures = /^\s*uniform\s+sampler/mg.test(fragmentShader);
      if (fragmentShader == null) fragmentShader = _default_frag_glsl__WEBPACK_IMPORTED_MODULE_9__["default"];
      if (vertexShader == null) vertexShader = enableTextures ? _default_feeback_vert_glsl__WEBPACK_IMPORTED_MODULE_10__["default"] : _default_vert_glsl__WEBPACK_IMPORTED_MODULE_8__["default"];
      var gl = this.gl;

      var program = Object(_helpers__WEBPACK_IMPORTED_MODULE_7__["createProgram"])(gl, vertexShader, fragmentShader);

      program.shaderText = {
        vertexShader: vertexShader,
        fragmentShader: fragmentShader
      };
      program._buffers = {};
      program._attribute = {};
      program.uniforms = {};
      program._samplerMap = {};
      program._bindTextures = []; // console.log(vertexShader);

      var pattern = new RegExp("(?:attribute|in) vec(\\d) ".concat(this.options.vertexPosition), 'im');
      var matched = vertexShader.match(pattern);

      if (matched) {
        program._dimension = Number(matched[1]);
      }

      var texCoordPattern = new RegExp("(?:attribute|in) vec(\\d) ".concat(this.options.vertexTextureCoord), 'im');
      matched = vertexShader.match(texCoordPattern);

      if (matched) {
        program._texCoordSize = Number(matched[1]);
      }

      var attributePattern = /^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/gim;
      matched = vertexShader.match(attributePattern);

      if (matched) {
        for (var i = 0; i < matched.length; i++) {
          var patt = /^\s*(?:attribute|in) (\w+?)(\d*) (\w+)/im;

          var _matched = matched[i].match(patt);

          if (_matched && _matched[3] !== this.options.vertexPosition && _matched[3] !== this.options.vertexTextureCoord) {
            var _matched2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_matched, 4),
                type = _matched2[1],
                size = _matched2[2],
                name = _matched2[3];

            if (type === 'mat') size = Math.pow(size, 2);
            program._buffers[name] = gl.createBuffer();
            program._attribute[name] = {
              name: name,
              type: type,
              size: Number(size) || 1
            };
          }
        }
      }

      var uniformPattern = /^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/mg;
      matched = vertexShader.match(uniformPattern) || [];
      matched = matched.concat(fragmentShader.match(uniformPattern) || []);
      matched.forEach(function (m) {
        var _matched = m.match(/^\s*uniform\s+(\w+)\s+(\w+)(\[\d+\])?/);

        var _matched$slice = _matched.slice(1),
            _matched$slice2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_matched$slice, 3),
            type = _matched$slice2[0],
            name = _matched$slice2[1],
            isTypeV = _matched$slice2[2];

        type = uniformTypeMap[type];
        isTypeV = !!isTypeV;

        if (type.indexOf('Matrix') !== 0 && isTypeV) {
          type += 'v';
        }

        _this3._declareUniform(program, name, type);
      });
      program._buffers.verticesBuffer = gl.createBuffer();
      program._buffers.cellsBuffer = gl.createBuffer();
      var vTexCoord = gl.getAttribLocation(program, this.options.vertexTextureCoord);
      program._enableTextures = vTexCoord >= 0;

      if (program._enableTextures) {
        program._buffers.texCoordBuffer = gl.createBuffer();
      }

      this.programs.push(program);
      return program;
    }
  }, {
    key: "useProgram",
    value: function useProgram(program) {
      var attrOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.startRender = false;

      if (this._renderFrameID) {
        cancelAnimationFrame(this._renderFrameID);
        delete this._renderFrameID;
      }

      var gl = this.gl;
      gl.useProgram(program); // this.program = program;

      var dimension = program._dimension;
      gl.bindBuffer(gl.ARRAY_BUFFER, program._buffers.verticesBuffer);
      var vPosition = gl.getAttribLocation(program, this.options.vertexPosition);
      gl.vertexAttribPointer(vPosition, dimension, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(vPosition);

      if (program._enableTextures) {
        gl.bindBuffer(gl.ARRAY_BUFFER, program._buffers.texCoordBuffer);
        var vTexCoord = gl.getAttribLocation(program, this.options.vertexTextureCoord);
        gl.vertexAttribPointer(vTexCoord, program._texCoordSize || 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(vTexCoord);
      }

      Object.entries(program._attribute).forEach(function (_ref7) {
        var _ref8 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref7, 2),
            name = _ref8[0],
            item = _ref8[1];

        if (item !== 'ignored') {
          var size = item.size;
          var options = attrOptions[name] || {};
          var normalize = !!options.normalize;
          var bufferType = options.type || 'FLOAT';
          var key = options.key || name;
          if (bufferType === 'UBYTE') bufferType = 'UNSIGNED_BYTE';
          if (bufferType === 'USHORT') bufferType = 'UNSIGNED_SHORT';
          item.type = bufferType;

          if (key && key !== name) {
            program._attribute[key] = item;
          }

          gl.bindBuffer(gl.ARRAY_BUFFER, program._buffers[name]);
          var attrib = gl.getAttribLocation(program, name); // console.log(size, gl[bufferType]);

          if (attrib >= 0) {
            gl.vertexAttribPointer(attrib, size, gl[bufferType], normalize, 0, 0);
            gl.enableVertexAttribArray(attrib);
          }
        }
      });

      if (!program.meshData) {
        var positions = [[-1, -1, 0, 1].slice(0, dimension), [1, -1, 0, 1].slice(0, dimension), [1, 1, 0, 1].slice(0, dimension), [-1, 1, 0, 1].slice(0, dimension)];
        var cells = [[0, 1, 3], [3, 1, 2]];
        this.setMeshData({
          positions: positions,
          cells: cells
        });
      }

      return program;
    }
  }, {
    key: "compileSync",
    value: function compileSync(frag, vert) {
      frag = frag || _default_frag_glsl__WEBPACK_IMPORTED_MODULE_9__["default"];
      var loaded = {};

      function _compile(content) {
        content = content.replace(/^\s*/mg, '');
        var includes = [];
        var matched = content.match(/^#pragma\s+include\s+.*/mg);

        if (matched) {
          // console.log(matched, url);
          for (var i = 0; i < matched.length; i++) {
            var m = matched[i];

            var _matched = m.match(/(?:<|")(.*)(?:>|")/);

            if (_matched) {
              var type = _matched[0].indexOf('<') === 0 ? 'lib' : 'link';
              var name = _matched[1];
              if (name === 'graph') name = 'graphics';

              if (!loaded[name]) {
                loaded[name] = true;

                if (type === 'lib') {
                  var c = _compile(GLSL_LIBS[name]); // eslint-disable-line no-await-in-loop


                  includes.push(c);
                } else if (type === 'link') {
                  throw new Error('Cannot load external links synchronously. Use compile instead of compileSync.');
                }
              } else {
                includes.push("/* included ".concat(name, " */"));
              }
            }
          }

          includes.forEach(function (inc) {
            content = content.replace(/^#pragma\s+include\s+.*/m, inc);
          });
        }

        return content;
      }

      var fragmentShader = _compile(frag);

      var vertexShader = vert ? _compile(vert) : null;
      var program = this.createProgram(fragmentShader, vertexShader);
      return program;
    }
  }, {
    key: "compile",
    value: function () {
      var _compile2 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2(frag, vert) {
        var loaded, _compile, _compile3, fragmentShader, vertexShader, program;

        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _compile3 = function _compile5() {
                  _compile3 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(content) {
                    var includes, matched, i, m, _matched, type, name, c, _c;

                    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            content = content.replace(/^\s*/mg, '');
                            includes = [];
                            matched = content.match(/^#pragma\s+include\s+.*/mg);

                            if (!matched) {
                              _context.next = 36;
                              break;
                            }

                            i = 0;

                          case 5:
                            if (!(i < matched.length)) {
                              _context.next = 35;
                              break;
                            }

                            m = matched[i];
                            _matched = m.match(/(?:<|")(.*)(?:>|")/);

                            if (!_matched) {
                              _context.next = 32;
                              break;
                            }

                            type = _matched[0].indexOf('<') === 0 ? 'lib' : 'link';
                            name = _matched[1];
                            if (name === 'graph') name = 'graphics';

                            if (loaded[name]) {
                              _context.next = 31;
                              break;
                            }

                            loaded[name] = true; // TODO: 这里可以优化成异步加载

                            if (!(type === 'lib')) {
                              _context.next = 21;
                              break;
                            }

                            _context.next = 17;
                            return _compile(GLSL_LIBS[name]);

                          case 17:
                            c = _context.sent;
                            // eslint-disable-line no-await-in-loop
                            includes.push(c);
                            _context.next = 29;
                            break;

                          case 21:
                            if (!(type === 'link')) {
                              _context.next = 29;
                              break;
                            }

                            _context.next = 24;
                            return Renderer.fetchShader(name);

                          case 24:
                            _c = _context.sent;
                            _context.next = 27;
                            return _compile(_c);

                          case 27:
                            _c = _context.sent;
                            // eslint-disable-line no-await-in-loop
                            includes.push(_c);

                          case 29:
                            _context.next = 32;
                            break;

                          case 31:
                            includes.push("/* included ".concat(name, " */"));

                          case 32:
                            i++;
                            _context.next = 5;
                            break;

                          case 35:
                            includes.forEach(function (inc) {
                              content = content.replace(/^#pragma\s+include\s+.*/m, inc);
                            });

                          case 36:
                            return _context.abrupt("return", content);

                          case 37:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));
                  return _compile3.apply(this, arguments);
                };

                _compile = function _compile4(_x3) {
                  return _compile3.apply(this, arguments);
                };

                frag = frag || _default_frag_glsl__WEBPACK_IMPORTED_MODULE_9__["default"];
                loaded = {};
                _context2.next = 6;
                return _compile(frag);

              case 6:
                fragmentShader = _context2.sent;

                if (!vert) {
                  _context2.next = 13;
                  break;
                }

                _context2.next = 10;
                return _compile(vert);

              case 10:
                _context2.t0 = _context2.sent;
                _context2.next = 14;
                break;

              case 13:
                _context2.t0 = null;

              case 14:
                vertexShader = _context2.t0;
                program = this.createProgram(fragmentShader, vertexShader);
                return _context2.abrupt("return", program);

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function compile(_x, _x2) {
        return _compile2.apply(this, arguments);
      }

      return compile;
    }()
  }, {
    key: "load",
    value: function () {
      var _load = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee3(frag) {
        var vert,
            _args3 = arguments;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                vert = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : null;
                _context3.next = 3;
                return Renderer.fetchShader(frag);

              case 3:
                frag = _context3.sent;

                if (!vert) {
                  _context3.next = 8;
                  break;
                }

                _context3.next = 7;
                return Renderer.fetchShader(vert);

              case 7:
                vert = _context3.sent;

              case 8:
                return _context3.abrupt("return", this.compile(frag, vert));

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function load(_x4) {
        return _load.apply(this, arguments);
      }

      return load;
    }()
  }, {
    key: "createTexture",
    value: function createTexture() {
      var _this4 = this;

      var img = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      var _ref9 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref9$wrapS = _ref9.wrapS,
          wrapS = _ref9$wrapS === void 0 ? this.gl.CLAMP_TO_EDGE : _ref9$wrapS,
          _ref9$wrapT = _ref9.wrapT,
          wrapT = _ref9$wrapT === void 0 ? this.gl.CLAMP_TO_EDGE : _ref9$wrapT,
          _ref9$minFilter = _ref9.minFilter,
          minFilter = _ref9$minFilter === void 0 ? this.gl.LINEAR : _ref9$minFilter,
          _ref9$magFilter = _ref9.magFilter,
          magFilter = _ref9$magFilter === void 0 ? this.gl.LINEAR : _ref9$magFilter;

      var gl = this.gl;
      var target = Array.isArray(img) ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
      this._max_texture_image_units = this._max_texture_image_units || gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
      gl.activeTexture(gl.TEXTURE0 + this._max_texture_image_units - 1);
      var texture = gl.createTexture();
      gl.bindTexture(target, texture);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      var _this$canvas = this.canvas,
          width = _this$canvas.width,
          height = _this$canvas.height;

      if (img) {
        if (target === gl.TEXTURE_CUBE_MAP) {
          // For cube maps
          for (var i = 0; i < 6; i++) {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img[i]);
          }
        } else {
          gl.texImage2D(target, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        }
      } else if (target === gl.TEXTURE_CUBE_MAP) {
        // For cube maps
        for (var _i = 0; _i < 6; _i++) {
          this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
      } else {
        gl.texImage2D(target, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      } // gl.NEAREST is also allowed, instead of gl.LINEAR, as neither mipmap.


      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minFilter);
      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magFilter); // Prevents s-coordinate wrapping (repeating).

      gl.texParameteri(target, gl.TEXTURE_WRAP_S, wrapS); // Prevents t-coordinate wrapping (repeating).

      gl.texParameteri(target, gl.TEXTURE_WRAP_T, wrapT);

      if (target === gl.TEXTURE_CUBE_MAP) {
        // gl.texParameteri(target, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
        img.width = img[0].width;
        img.height = img[0].height;
      }

      gl.bindTexture(target, null);
      texture._img = img || {
        width: width,
        height: height
      };

      texture.delete = function () {
        _this4.deleteTexture(texture);
      };

      return texture;
    }
  }, {
    key: "deleteTexture",
    value: function deleteTexture(texture) {
      var image = texture._img;
      this.gl.deleteTexture(texture);

      if (typeof image.close === 'function') {
        // release ImageBitmap
        image.close();
      }
    }
  }, {
    key: "loadTexture",
    value: function () {
      var _loadTexture = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee4(source) {
        var _ref10,
            _ref10$useImageBitmap,
            useImageBitmap,
            img,
            _args4 = arguments;

        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _ref10 = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {}, _ref10$useImageBitmap = _ref10.useImageBitmap, useImageBitmap = _ref10$useImageBitmap === void 0 ? true : _ref10$useImageBitmap;
                _context4.next = 3;
                return Renderer.loadImage(source, {
                  useImageBitmap: useImageBitmap
                });

              case 3:
                img = _context4.sent;
                return _context4.abrupt("return", this.createTexture(img));

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function loadTexture(_x5) {
        return _loadTexture.apply(this, arguments);
      }

      return loadTexture;
    }()
  }, {
    key: "createFBO",
    value: function createFBO() {
      var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref11$color = _ref11.color,
          color = _ref11$color === void 0 ? 1 : _ref11$color,
          _ref11$blend = _ref11.blend,
          blend = _ref11$blend === void 0 ? false : _ref11$blend,
          _ref11$depth = _ref11.depth,
          depth = _ref11$depth === void 0 ? this.options.depth !== false : _ref11$depth,
          _ref11$stencil = _ref11.stencil,
          stencil = _ref11$stencil === void 0 ? !!this.options.stencil : _ref11$stencil;

      var gl = this.gl;
      var buffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);
      var textures = [];

      for (var i = 0; i < color; i++) {
        var texture = this.createTexture();
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, texture, 0
        /* level */
        );
        textures.push(texture);
      }

      buffer.textures = textures;
      buffer.texture = textures[0];
      buffer.blend = blend;
      var _this$canvas2 = this.canvas,
          width = _this$canvas2.width,
          height = _this$canvas2.height; // Render buffers

      if (depth && !stencil) {
        buffer.depthBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, buffer.depthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, buffer.depthBuffer);
      }

      if (stencil && !depth) {
        buffer.stencilBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, buffer.stencilBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8, width, height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, buffer.stencilBuffer);
      }

      if (depth && stencil) {
        buffer.depthStencilBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, buffer.depthStencilBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, buffer.depthStencilBuffer);
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return buffer;
    }
  }, {
    key: "bindFBO",
    value: function bindFBO() {
      var fbo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.fbo = fbo;
    }
  }, {
    key: "render",
    value: function render() {
      var _ref12 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref12$clearBuffer = _ref12.clearBuffer,
          clearBuffer = _ref12$clearBuffer === void 0 ? true : _ref12$clearBuffer;

      this.startRender = true;
      var gl = this.gl;
      var program = this.program;

      if (!program) {
        program = this.createProgram();
        this.useProgram(program);
      }

      if (this.fbo) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
      }

      var depth = this.options.depth;

      if (depth) {
        gl.enable(gl.DEPTH_TEST);
      }

      this.gl.clear(this.gl.COLOR_BUFFER_BIT | (depth ? this.gl.DEPTH_BUFFER_BIT : 0) | (this.options.stencil ? this.gl.STENCIL_BUFFER_BIT : 0));
      var lastFrameID = this._renderFrameID;

      this._draw();

      if (this.fbo) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }

      if (this._renderFrameID === lastFrameID) {
        this._renderFrameID = null;
      }
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.startRender) return;

      if (this._renderFrameID == null) {
        this._renderFrameID = requestAnimationFrame(this.render.bind(this));
      }
    }
  }, {
    key: "program",
    get: function get() {
      var gl = this.gl;
      return gl.getParameter(gl.CURRENT_PROGRAM);
    }
  }, {
    key: "isWebGL2",
    get: function get() {
      return typeof WebGL2RenderingContext !== 'undefined' && this.gl instanceof WebGL2RenderingContext;
    }
  }, {
    key: "enableTextures",
    get: function get() {
      return this.program && this.program._enableTextures;
    }
  }, {
    key: "uniforms",
    get: function get() {
      var program = this.program;

      if (!program || !program.uniforms) {
        throw Error('No avaliable program.');
      }

      return program.uniforms;
    }
  }]);

  return Renderer;
}();

_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(Renderer, "defaultOptions", {
  preserveDrawingBuffer: true,
  autoUpdate: true,
  vertexPosition: 'a_vertexPosition',
  vertexTextureCoord: 'a_vertexTextureCoord',
  webgl2: false
});

_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(Renderer, "UBYTE", Renderer.UNSIGNED_BYTE);

_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(Renderer, "USHORT", Renderer.UNSIGNED_SHORT);

_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(Renderer, "fetchShader", _helpers__WEBPACK_IMPORTED_MODULE_7__["fetchShader"]);

_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(Renderer, "loadImage", _helpers__WEBPACK_IMPORTED_MODULE_7__["loadImage"]);



/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(28);


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),
/* 29 */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),
/* 30 */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupWebGL", function() { return setupWebGL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createProgram", function() { return createProgram; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointsToBuffer", function() { return pointsToBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return loadImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchShader", function() { return fetchShader; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2__);




__webpack_require__(1).glMatrix.setMatrixArrayType(Array);

function create3DContext(canvas, opt_attribs) {
  var names = ['webgl', 'experimental-webgl', 'webkit-3d', 'moz-webgl'];
  var context = null;

  for (var ii = 0; ii < names.length; ++ii) {
    try {
      context = canvas.getContext(names[ii], opt_attribs);
    } catch (e) {// no-empty
    }

    if (context) {
      break;
    }
  }

  return context;
}

function setupWebGL(canvas, opt_attribs) {
  var context = create3DContext(canvas, opt_attribs);

  if (!context) {
    throw new Error("Sorry, your browser doesn't support WebGL.");
  }

  return context;
}
function createProgram(gl, vertex, fragment) {
  var vertShdr = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertShdr, vertex);
  gl.compileShader(vertShdr);

  if (!gl.getShaderParameter(vertShdr, gl.COMPILE_STATUS)) {
    var msg = "Vertex shader failed to compile.  The error log is:".concat(gl.getShaderInfoLog(vertShdr));
    throw new Error(msg);
  }

  var fragShdr = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragShdr, fragment);
  gl.compileShader(fragShdr);

  if (!gl.getShaderParameter(fragShdr, gl.COMPILE_STATUS)) {
    var _msg = "Fragment shader failed to compile.  The error log is:".concat(gl.getShaderInfoLog(fragShdr));

    throw new Error(_msg);
  }

  var program = gl.createProgram();
  gl.attachShader(program, vertShdr);
  gl.attachShader(program, fragShdr);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    var _msg2 = "Shader program failed to link.  The error log is:".concat(gl.getProgramInfoLog(program));

    throw new Error(_msg2);
  }

  gl.deleteShader(vertShdr);
  gl.deleteShader(fragShdr);
  return program;
}
function pointsToBuffer(points) {
  var Type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Float32Array;
  var buffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (buffer && !(buffer instanceof Type)) throw new TypeError('Wrong buffer type.');
  if (points == null) return points;
  if (points instanceof Type) return points;

  if (points[0] == null || points[0].length == null) {
    if (buffer) {
      buffer.set(points, 0);
      return buffer;
    }

    return new Type(points);
  }

  var deminsion = points[0].length;
  var len = points.length;

  if (!buffer) {
    buffer = new Type(deminsion * len);
  }

  var idx = 0;

  for (var i = 0; i < len; i++) {
    for (var j = 0; j < deminsion; j++) {
      buffer[idx++] = points[i][j];
    }
  }

  return buffer;
}
var imageCache = {};
function loadImage(src) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$useImageBitmap = _ref.useImageBitmap,
      useImageBitmap = _ref$useImageBitmap === void 0 ? true : _ref$useImageBitmap,
      _ref$alias = _ref.alias,
      alias = _ref$alias === void 0 ? null : _ref$alias;

  if (!imageCache[src]) {
    if (typeof Image === 'function') {
      var img = new Image();

      if (typeof src === 'string' && !((typeof location === "undefined" ? "undefined" : _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2___default()(location)) === 'object' && /^file:/.test(location.href)) // eslint-disable-line no-restricted-globals
      && !/^data:/.test(src)) {
        // base64 dont need crossOrigin - fix early webkit cross domain bug
        img.crossOrigin = 'anonymous';
      }

      imageCache[src] = new Promise(function (resolve) {
        img.onload = function () {
          if (useImageBitmap && typeof createImageBitmap === 'function') {
            createImageBitmap(img, {
              imageOrientation: 'flipY'
            }).then(function (bitmap) {
              imageCache[src] = bitmap;
              if (alias) imageCache[alias] = bitmap;
              resolve(bitmap);
            });
          } else {
            imageCache[src] = img;
            if (alias) imageCache[alias] = img;
            resolve(img);
          }
        };

        img.src = src;
      });
      if (alias) imageCache[alias] = imageCache[src];
    } else if (typeof fetch === 'function') {
      // run in worker
      return fetch(src, {
        method: 'GET',
        mode: 'cors',
        cache: 'default'
      }).then(function (response) {
        return response.blob();
      }).then(function (blob) {
        return createImageBitmap(blob, {
          imageOrientation: 'flipY'
        }).then(function (bitmap) {
          imageCache[src] = bitmap;
          if (alias) imageCache[alias] = bitmap;
          return bitmap;
        });
      });
    }
  }

  return imageCache[src];
}
var shaderCache = {};
function fetchShader(_x) {
  return _fetchShader.apply(this, arguments);
}

function _fetchShader() {
  _fetchShader = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(url) {
    var res, content;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!shaderCache[url]) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return", shaderCache[url]);

          case 2:
            _context.next = 4;
            return fetch(url);

          case 4:
            res = _context.sent;

            if (!(res.status >= 200 && res.status < 300)) {
              _context.next = 11;
              break;
            }

            _context.next = 8;
            return res.text();

          case 8:
            content = _context.sent;
            shaderCache[url] = content;
            return _context.abrupt("return", content);

          case 11:
            throw new Error('Shader loaded error.');

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _fetchShader.apply(this, arguments);
}

/***/ }),
/* 32 */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("attribute vec3 a_vertexPosition;\n\nvoid main() {\n  gl_PointSize = 1.0;\n  gl_Position = vec4(a_vertexPosition, 1);\n}");

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);\n}");

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("attribute vec4 a_vertexPosition;\nattribute vec2 a_vertexTextureCoord;\nvarying vec2 vTextureCoord;\n\nvoid main() {\n  gl_PointSize = 1.0;\n  gl_Position = a_vertexPosition;\n  vTextureCoord = a_vertexTextureCoord;\n}");

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CanvasRenderer; });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(23);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _utils_env__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(37);
/* harmony import */ var _utils_canvas__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(41);







__webpack_require__(1).glMatrix.setMatrixArrayType(Array);




var _transform = Symbol('transform');

var CanvasRenderer = /*#__PURE__*/function () {
  function CanvasRenderer(canvas, options) {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4___default()(this, CanvasRenderer);

    this.context = canvas.getContext('2d');
    this.options = options;
    this[_transform] = [1, 0, 0, 1, 0, 0];
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5___default()(CanvasRenderer, [{
    key: "createTexture",
    value: function createTexture(img) {
      var texture = {
        _img: img
      };
      return texture;
    }
  }, {
    key: "loadTexture",
    value: function () {
      var _loadTexture = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee(textureURL) {
        var image;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _utils_env__WEBPACK_IMPORTED_MODULE_6__["default"].loadImage(textureURL, {
                  useImageBitmap: false
                });

              case 2:
                image = _context.sent;
                return _context.abrupt("return", this.createTexture(image));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function loadTexture(_x) {
        return _loadTexture.apply(this, arguments);
      }

      return loadTexture;
    }()
  }, {
    key: "deleteTexture",
    value: function deleteTexture(texture) {
      return texture;
    }
  }, {
    key: "clear",
    value: function clear(x, y, w, h) {
      var context = this.context;
      x = x || 0;
      y = y || 0;
      w = w || context.canvas.width - x;
      h = h || context.canvas.height - y;
      context.clearRect(x, y, w, h);
    }
  }, {
    key: "drawMeshCloud",
    value: function drawMeshCloud(cloud) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$clear = _ref.clear,
          clear = _ref$clear === void 0 ? false : _ref$clear;

      var cloudMeshes = [];

      for (var i = 0; i < cloud.amount; i++) {
        var transform = cloud.getTransform(i);
        var frame = cloud.getTextureFrame(i);
        if (frame) frame = frame._img;
        var filter = cloud.getFilter(i);

        var _cloud$getCloudRGBA = cloud.getCloudRGBA(i),
            fill = _cloud$getCloudRGBA.fill,
            stroke = _cloud$getCloudRGBA.stroke;

        cloudMeshes.push({
          mesh: cloud.mesh,
          _cloudOptions: [fill, stroke, frame, transform, filter]
        }); // console.log(transform, colorTransform, frame);
      }

      if (cloud.beforeRender) cloud.beforeRender(this.context, cloud);
      this.drawMeshes(cloudMeshes, {
        clear: clear,
        hook: false
      });
      if (cloud.afterRender) cloud.afterRender(this.context, cloud);
    }
  }, {
    key: "drawMeshes",
    value: function drawMeshes(meshes) {
      var _this = this;

      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$clear = _ref2.clear,
          clear = _ref2$clear === void 0 ? false : _ref2$clear,
          _ref2$hook = _ref2.hook,
          hook = _ref2$hook === void 0 ? true : _ref2$hook;

      var context = this.context;

      if (clear) {
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
      }

      var lastFilter = null;
      var _context$canvas = context.canvas,
          width = _context$canvas.width,
          height = _context$canvas.height;
      var len = meshes.length;
      meshes.forEach(function (mesh, i) {
        var fill, stroke, frame, transform, cloudFilter;
        if (hook && mesh.beforeRender) mesh.beforeRender(context, mesh);

        if (mesh._cloudOptions) {
          var _mesh$_cloudOptions = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(mesh._cloudOptions, 5);

          fill = _mesh$_cloudOptions[0];
          stroke = _mesh$_cloudOptions[1];
          frame = _mesh$_cloudOptions[2];
          transform = _mesh$_cloudOptions[3];
          cloudFilter = _mesh$_cloudOptions[4];
          mesh = mesh.mesh;
        }

        var filter = mesh.filter;
        if (cloudFilter) filter = filter ? "".concat(filter, " ").concat(cloudFilter) : cloudFilter;

        if (filter && !_this.filterBuffer && _this.filterBuffer !== false) {
          var canvas = _utils_env__WEBPACK_IMPORTED_MODULE_6__["default"].createCanvas(width, height);

          if (canvas) {
            _this.filterBuffer = canvas.getContext('2d');
          } else {
            _this.filterBuffer = false;
          }
        }

        if (lastFilter && lastFilter !== filter) {
          Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_7__["applyFilter"])(_this.filterBuffer, lastFilter);
          context.drawImage(_this.filterBuffer.canvas, 0, 0, width, height);

          _this.filterBuffer.clearRect(0, 0, width, height);

          lastFilter = null;
        }

        if (filter && _this.filterBuffer) {
          var _this$filterBuffer;

          _this.filterBuffer.save();

          (_this$filterBuffer = _this.filterBuffer).transform.apply(_this$filterBuffer, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(_this[_transform])); // console.log(this[_transform]);


          Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_7__["drawMesh2D"])(mesh, _this.filterBuffer, false, fill, stroke, frame, transform);

          _this.filterBuffer.restore();

          if (i === len - 1) {
            Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_7__["applyFilter"])(_this.filterBuffer, filter);
            context.drawImage(_this.filterBuffer.canvas, 0, 0, width, height);

            _this.filterBuffer.clearRect(0, 0, width, height);
          } else {
            lastFilter = filter;
          }
        } else {
          context.save();
          context.transform.apply(context, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(_this[_transform]));
          Object(_utils_canvas__WEBPACK_IMPORTED_MODULE_7__["drawMesh2D"])(mesh, context, false, fill, stroke, frame, transform);
          context.restore();
        }

        if (hook && mesh.afterRender) mesh.afterRender(context, mesh);
      });
    }
  }, {
    key: "setTransform",
    value: function setTransform(transform) {
      this[_transform] = transform;
    }
  }]);

  return CanvasRenderer;
}();



/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32);
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var gl_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);
/* harmony import */ var _parse_font__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39);
/* harmony import */ var _vector_to_rgba__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40);



__webpack_require__(1).glMatrix.setMatrixArrayType(Array);




var cacheMap = {};

function fontEx(info, ratio) {
  var style = info.style,
      variant = info.variant,
      weight = info.weight,
      stretch = info.stretch,
      size = info.size,
      pxLineHeight = info.pxLineHeight,
      family = info.family;

  if (stretch === 'normal') {
    // fix iOS10 bug
    return "".concat(style, " ").concat(variant, " ").concat(weight, " ").concat(size * ratio, "px/").concat(pxLineHeight * ratio, "px ").concat(family);
  }

  return "".concat(style, " ").concat(variant, " ").concat(weight, " ").concat(stretch, " ").concat(size * ratio, "px/").concat(pxLineHeight * ratio, "px ").concat(family);
}

function createText(text, _ref) {
  var font = _ref.font,
      fillColor = _ref.fillColor,
      strokeColor = _ref.strokeColor,
      strokeWidth = _ref.strokeWidth,
      _ref$ratio = _ref.ratio,
      ratio = _ref$ratio === void 0 ? 1 : _ref$ratio,
      textCanvas = _ref.textCanvas,
      _ref$cachable = _ref.cachable,
      cachable = _ref$cachable === void 0 ? false : _ref$cachable;
  var key;

  if (cachable) {
    key = [text, font, String(fillColor), String(strokeColor), String(strokeWidth)].join('###');
    var cachedCanvas = cacheMap[key];
    if (cachedCanvas) return cachedCanvas;
  }

  if (!textCanvas) {
    textCanvas = createCanvas(1, 1);
  }

  var textContext = textCanvas.getContext('2d');
  textContext.save();
  textContext.font = font;

  var _textContext$measureT = textContext.measureText(text),
      width = _textContext$measureT.width;

  textContext.restore();
  var fontInfo = Object(_parse_font__WEBPACK_IMPORTED_MODULE_3__["default"])(font);
  var height = Math.max(fontInfo.pxLineHeight, fontInfo.pxHeight * 1.13);

  if (/italic|oblique/.test(font)) {
    width += height * Math.tan(15 * Math.PI / 180);
  }

  if (!fillColor && !strokeColor) fillColor = '#000';
  var canvas = textContext.canvas;
  var w = Math.ceil(width);
  var h = Math.ceil(height);
  canvas.width = Math.round(w * ratio);
  canvas.height = Math.round(h * ratio);
  textContext.save();
  textContext.font = fontEx(fontInfo, ratio);
  textContext.textAlign = 'center';
  textContext.textBaseline = 'middle';
  var top = canvas.height * 0.5 + fontInfo.pxHeight * 0.05 * ratio;
  var left = canvas.width * 0.5;

  if (fillColor) {
    if (Array.isArray(fillColor)) fillColor = Object(_vector_to_rgba__WEBPACK_IMPORTED_MODULE_4__["default"])(fillColor);else if (fillColor.vector) {
      var gradient;
      var _fillColor = fillColor,
          vector = _fillColor.vector,
          colors = _fillColor.colors;

      if (vector.length === 6) {
        gradient = textContext.createRadialGradient.apply(textContext, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(vector));
      } else {
        gradient = textContext.createLinearGradient.apply(textContext, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(vector));
      }

      colors.forEach(function (_ref2) {
        var offset = _ref2.offset,
            color = _ref2.color;
        gradient.addColorStop(offset, color);
      });
      fillColor = gradient;
    }
    textContext.fillStyle = fillColor;
    textContext.fillText(text, left, top);
  }

  if (strokeColor) {
    textContext.lineWidth = strokeWidth * ratio;
    if (Array.isArray(strokeColor)) strokeColor = Object(_vector_to_rgba__WEBPACK_IMPORTED_MODULE_4__["default"])(strokeColor);else if (strokeColor.vector) {
      var _gradient;

      var _strokeColor = strokeColor,
          _vector = _strokeColor.vector,
          _colors = _strokeColor.colors;

      if (_vector.length === 6) {
        _gradient = textContext.createRadialGradient.apply(textContext, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(_vector));
      } else {
        _gradient = textContext.createLinearGradient.apply(textContext, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(_vector));
      }

      _colors.forEach(function (_ref3) {
        var offset = _ref3.offset,
            color = _ref3.color;

        _gradient.addColorStop(offset, color);
      });

      strokeColor = _gradient;
    }
    textContext.strokeStyle = strokeColor;
    textContext.strokeText(text, left, top);
  }

  textContext.restore();
  var ret = {
    image: textCanvas,
    rect: [0, 0, w, h]
  };

  if (cachable) {
    cacheMap[key] = ret;
  }

  return ret;
} // Fixed: use offscreen canvas as texture will fail in early chrome.


var isEarlyChrome = false;

if ((typeof navigator === "undefined" ? "undefined" : _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(navigator)) === 'object' && typeof navigator.userAgent === 'string') {
  var matched = navigator.userAgent.toLowerCase().match(/chrome\/(\d+)/);

  if (matched) {
    isEarlyChrome = Number(matched[1]) < 70;
  }
}

function createCanvas(width, height) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var offscreen = options.offscreen || !isEarlyChrome && options.offscreen !== false;
  var canvas;

  if (typeof global !== 'undefined' && typeof global.createCanvas === 'function') {
    canvas = global.createCanvas(width, height, options);
  } else if (offscreen && typeof OffscreenCanvas === 'function') {
    canvas = new OffscreenCanvas(width, height);
  } else {
    canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
  }

  return canvas;
}

var ENV = {
  createCanvas: createCanvas,
  createText: createText,
  loadImage: gl_renderer__WEBPACK_IMPORTED_MODULE_2__["default"].loadImage
};
/* harmony default export */ __webpack_exports__["default"] = (ENV);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(38)))

/***/ }),
/* 38 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseFont; });
__webpack_require__(1).glMatrix.setMatrixArrayType(Array);

function sizeToPixel(value, defaultWidth) {
  // eslint-disable-line complexity
  if (typeof value === 'string') {
    var matched = value.trim().match(/^([\d.]+)(px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%)$/);

    if (matched) {
      value = {
        size: parseFloat(matched[1]),
        unit: matched[2]
      };
    } else {
      value = {
        size: parseInt(value, 10),
        unit: 'px'
      };
    }
  }

  var _value = value,
      size = _value.size,
      unit = _value.unit;

  if (unit === 'pt') {
    size /= 0.75;
  } else if (unit === 'pc') {
    size *= 16;
  } else if (unit === 'in') {
    size *= 96;
  } else if (unit === 'cm') {
    size *= 96.0 / 2.54;
  } else if (unit === 'mm') {
    size *= 96.0 / 25.4;
  } else if (unit === 'em' || unit === 'rem' || unit === 'ex') {
    if (!defaultWidth && typeof getComputedStyle === 'function' && typeof document !== 'undefined') {
      var root = getComputedStyle(document.documentElement).fontSize;
      defaultWidth = sizeToPixel(root, 16);
    }

    size *= defaultWidth;
    if (unit === 'ex') size /= 2;
  } else if (unit === 'q') {
    size *= 96.0 / 25.4 / 4;
  } else if (unit === 'vw' || unit === 'vh') {
    if (typeof document !== 'undefined') {
      var val = unit === 'vw' ? document.documentElement.clientWidth : document.documentElement.clientHeight;
      size *= val / 100;
    }
  } else if (unit === 'vmax' || unit === 'vmin') {
    if (typeof document !== 'undefined') {
      var width = document.documentElement.clientWidth;
      var height = document.documentElement.clientHeight;

      if (unit === 'vmax') {
        size *= Math.max(width, height) / 100;
      } else {
        size *= Math.min(width, height) / 100;
      }
    }
  }

  return size;
} // borrow from node-canvas (https://github.com/Automattic/node-canvas)

/**
 * Font RegExp helpers.
 */


var weights = 'bold|bolder|lighter|[1-9]00',
    styles = 'italic|oblique',
    variants = 'small-caps',
    stretches = 'ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded',
    units = 'px|pt|pc|in|cm|mm|em|ex|rem|q|vw|vh|vmax|vmin|%',
    string = "'([^']+)'|\"([^\"]+)\"|([\\w-]|[\u4E00-\u9FA5])+"; // [ [ <‘font-style’> || <font-variant-css21> || <‘font-weight’> || <‘font-stretch’> ]?
//    <‘font-size’> [ / <‘line-height’> ]? <‘font-family’> ]
// https://drafts.csswg.org/css-fonts-3/#font-prop

var weightRe = new RegExp("(".concat(weights, ") +"), 'i');
var styleRe = new RegExp("(".concat(styles, ") +"), 'i');
var variantRe = new RegExp("(".concat(variants, ") +"), 'i');
var stretchRe = new RegExp("(".concat(stretches, ") +"), 'i');
/* eslint-disable prefer-template */

var sizeFamilyRe = new RegExp('([\\d\\.]+)(' + units + ')(?:\\/([\\d\\.]+)(' + units + '))? *' + '((?:' + string + ')( *, *(?:' + string + '))*)');
/* eslint-enable prefer-template */

/**
 * Parse font `str`.
 *
 * @param {String} str
 * @return {Object} Parsed font. `size` is in device units. `unit` is the unit
 *   appearing in the input string.
 * @api private
 */

function parseFont(str, defaultHeight) {
  // Try for required properties first.
  var sizeFamily = sizeFamilyRe.exec(str);
  if (!sizeFamily) return; // invalid

  var lineHeight = parseFloat(sizeFamily[3]); // Default values and required properties

  var font = {
    weight: 'normal',
    style: 'normal',
    stretch: 'normal',
    variant: 'normal',
    size: parseFloat(sizeFamily[1]),
    unit: sizeFamily[2],
    lineHeight: Number.isFinite(lineHeight) ? lineHeight : undefined,
    lineHeightUnit: sizeFamily[4],
    family: sizeFamily[5].replace(/ *, */g, ',')
  }; // Stop search at `sizeFamily.index`

  var substr = str.substring(0, sizeFamily.index); // Optional, unordered properties.

  var weight = weightRe.exec(substr),
      style = styleRe.exec(substr),
      variant = variantRe.exec(substr),
      stretch = stretchRe.exec(substr);
  if (weight) font.weight = weight[1];
  if (style) font.style = style[1];
  if (variant) font.variant = variant[1];
  if (stretch) font.stretch = stretch[1];
  font.pxHeight = sizeToPixel({
    size: font.size,
    unit: font.unit
  }, defaultHeight);
  font.pxLineHeight = sizeToPixel({
    size: font.lineHeight || font.size,
    unit: font.lineHeightUnit || font.unit
  }, defaultHeight);
  return font;
}

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return vectorToRGBA; });
__webpack_require__(1).glMatrix.setMatrixArrayType(Array);

function vectorToRGBA(vector) {
  return "rgba(".concat(vector.map(function (c, i) {
    if (i < 3) return Math.round(c * 255);
    return c;
  }).join(), ")");
}

/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyFilter", function() { return applyFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawMesh2D", function() { return drawMesh2D; });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var _vector_to_rgba__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);
/* harmony import */ var _parse_font__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(42);


__webpack_require__(1).glMatrix.setMatrixArrayType(Array);





function applyFilter(context, filter) {
  var canvas = context.canvas;
  context.save();
  context.filter = filter;
  context.drawImage(canvas, 0, 0, canvas.width, canvas.height);
  context.restore();
}

function mixRGBA(a, b) {
  var pattern = /rgba\((\d+),(\d+),(\d+),(\d+)\)/;
  a = a.match(pattern).slice(1, 5).map(Number);
  b = b.match(pattern).slice(1, 5).map(Number);
  var c = [];
  var alpha = b[3];

  for (var i = 0; i < 4; i++) {
    c[i] = Object(_math__WEBPACK_IMPORTED_MODULE_4__["mix"])(a[i], b[i], alpha);
  }

  return "rgba(".concat(c.join(), ")");
}

function drawMesh2D(mesh, context) {
  var enableFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var cloudFill = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var cloudStroke = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var cloudFrame = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
  var cloudTransform = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
  context.save();
  var stroke = false;
  var fill = false;
  context.globalAlpha = mesh.getOpacity();

  if (mesh._updateMatrix) {
    var acc = mesh.transformScale / mesh.contours.scale;

    if (acc > 1.5) {
      mesh.accurate(mesh.transformScale);
    }
  }

  if (mesh.lineWidth) {
    var _gradient = mesh.gradient && mesh.gradient.stroke;

    if (_gradient) {
      var _gradient2 = _gradient,
          vector = _gradient2.vector,
          colors = _gradient2.colors;

      if (vector.length === 6) {
        _gradient = context.createRadialGradient.apply(context, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(vector));
      } else if (vector.length === 4) {
        _gradient = context.createLinearGradient.apply(context, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(vector));
      } else if (vector.length === 3) {
        _gradient = context.createCircularGradient.apply(context, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(vector));
      } else {
        throw new TypeError('Invalid vector dimension.');
      }

      colors.forEach(function (_ref) {
        var offset = _ref.offset,
            color = _ref.color;
        var rgba = Object(_vector_to_rgba__WEBPACK_IMPORTED_MODULE_2__["default"])(color);
        if (cloudStroke) rgba = mixRGBA(rgba, cloudStroke);

        _gradient.addColorStop(offset, rgba);
      });
      context.strokeStyle = _gradient;
      stroke = true;
    } else if (mesh.strokeStyle) {
      if (cloudStroke) {
        context.strokeStyle = mixRGBA(mesh.strokeStyle, cloudStroke);
      } else {
        context.strokeStyle = mesh.strokeStyle;
      }

      stroke = true;
    }
  }

  if (stroke) {
    context.lineWidth = mesh.lineWidth;
    context.lineJoin = mesh.lineJoin;
    context.lineCap = mesh.lineCap;
    context.miterLimit = mesh.miterLimit;

    if (mesh.lineDash) {
      context.setLineDash(mesh.lineDash);

      if (mesh.lineDashOffset) {
        context.lineDashOffset = mesh.lineDashOffset;
      }
    }
  }

  var gradient = mesh.gradient && mesh.gradient.fill;

  if (gradient) {
    var _gradient3 = gradient,
        _vector = _gradient3.vector,
        _colors = _gradient3.colors;

    if (_vector.length === 6) {
      gradient = context.createRadialGradient.apply(context, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(_vector));
    } else if (_vector.length === 4) {
      gradient = context.createLinearGradient.apply(context, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(_vector));
    } else if (_vector.length === 3) {
      gradient = context.createCircularGradient.apply(context, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(_vector));
    } else {
      throw new TypeError('Invalid vector dimension.');
    }

    _colors.forEach(function (_ref2) {
      var offset = _ref2.offset,
          color = _ref2.color;
      var rgba = Object(_vector_to_rgba__WEBPACK_IMPORTED_MODULE_2__["default"])(color);
      if (cloudStroke) rgba = mixRGBA(rgba, cloudStroke);
      gradient.addColorStop(offset, rgba);
    });

    context.fillStyle = gradient;
    fill = true;
  } else if (mesh.fillStyle) {
    if (cloudFill) {
      context.fillStyle = mixRGBA(mesh.fillStyle, cloudFill);
    } else {
      context.fillStyle = mesh.fillStyle;
    }

    fill = true;
  } // if(enableFilter) {
  //   const filter = mesh.filter;
  //   if(filter) {
  //     context.filter = filter;
  //   }
  // }


  if (cloudTransform) {
    context.transform.apply(context, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(cloudTransform));
  }

  context.transform.apply(context, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(mesh.transformMatrix));

  if (mesh.clipPath) {
    var clipPath = mesh.clipPath;
    var path = new Path2D(clipPath);
    context.clip(path);
  }

  var count = mesh.contours.length;
  mesh.contours.forEach(function (points, i) {
    // eslint-disable-line complexity
    var len = points.length;
    var closed = len > 1 && gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec2"].equals(points[0], points[len - 1]);
    var drawTexture = i === count - 1 && mesh.texture;

    if (points && len > 0) {
      if (fill || stroke || drawTexture) {
        context.beginPath();
        context.moveTo.apply(context, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(points[0]));

        for (var _i = 1; _i < len; _i++) {
          if (_i === len - 1 && closed) {
            context.closePath();
          } else {
            context.lineTo.apply(context, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(points[_i]));
          }
        }
      }

      if (fill) {
        context.fill(mesh.fillRule);
      }

      if (drawTexture) {
        context.save();
        context.clip();
        var _mesh$texture = mesh.texture,
            image = _mesh$texture.image,
            options = _mesh$texture.options;
        if (cloudFrame) image = cloudFrame;
        if (options.repeat) console.warn('Context 2D not supported image repeat yet.');

        if (image.font) {
          if (options.scale) console.warn('Context 2D not supported text scale yet.');
          if (options.srcRect) console.warn('Context 2D not supported text srcRect yet.');
          var _image = image,
              font = _image.font,
              fillColor = _image.fillColor,
              strokeColor = _image.strokeColor,
              strokeWidth = _image.strokeWidth,
              text = _image.text;
          if (!fillColor && !strokeColor) fillColor = '#000';
          if (Array.isArray(fillColor)) fillColor = Object(_vector_to_rgba__WEBPACK_IMPORTED_MODULE_2__["default"])(fillColor);
          if (Array.isArray(strokeColor)) strokeColor = Object(_vector_to_rgba__WEBPACK_IMPORTED_MODULE_2__["default"])(strokeColor);
          context.font = font;

          var _context$measureText = context.measureText(text),
              width = _context$measureText.width;

          var fontInfo = Object(_parse_font__WEBPACK_IMPORTED_MODULE_3__["default"])(font);
          var height = Math.max(fontInfo.pxLineHeight, fontInfo.pxHeight * 1.13);
          context.textAlign = 'center';
          context.textBaseline = 'middle'; // text ignore rect scale

          var rect = options.rect;
          var top = rect[0] + height * 0.5 + fontInfo.pxHeight * 0.06;
          var left = rect[1] + width * 0.5;

          if (rect[2] != null) {
            context.scale(rect[2] / width, rect[3] / height);
          }

          if (fillColor) {
            context.fillStyle = fillColor;
            context.fillText(text, left, top);
          }

          if (strokeColor) {
            context.lineWidth = strokeWidth;
            context.strokeStyle = strokeColor;
            context.strokeText(text, left, top);
          }
        } else {
          var _rect = options.rect;
          var srcRect = options.srcRect;

          if (options.scale) {
            _rect = [0, 0, context.canvas.width, context.canvas.height];
          }

          if (options.rotated && _rect) {
            _rect = [-_rect[1], _rect[0], _rect[3], _rect[2]];
          }

          if (srcRect) {
            _rect = _rect || [0, 0, srcRect[2], srcRect[3]];
          }

          if (options.rotated) {
            context.translate(0, _rect ? _rect[2] : image.width);
            context.rotate(-0.5 * Math.PI);
          }

          if (srcRect) {
            context.drawImage.apply(context, [image].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(srcRect), _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(_rect)));
          } else if (_rect) {
            context.drawImage.apply(context, [image].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(_rect)));
          } else {
            context.drawImage(image, 0, 0);
          }
        }

        context.restore();
      }

      if (stroke) {
        context.stroke();
      }
    }
  });
  context.restore();

  if (enableFilter) {
    var filter = mesh.filter;

    if (filter) {
      applyFilter(context, filter);
    }
  }
}

/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mix", function() { return mix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformPoint", function() { return transformPoint; });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);


__webpack_require__(1).glMatrix.setMatrixArrayType(Array);

function clamp(value, min, max) {
  if (min > max) {
    var _ref = [max, min];
    min = _ref[0];
    max = _ref[1];
  }

  if (value < min) return min;
  if (value > max) return max;
  return value;
}
function mix(src, dest, p) {
  return src * (1 - p) + dest * p;
}
function transformPoint(p, m) {
  var _p = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(p, 2),
      x = _p[0],
      y = _p[1];

  return [x * m[0] + y * m[2] + m[4], x * m[1] + y * m[3] + m[5]];
}

/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return compress; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _flatten_meshes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44);
/* harmony import */ var _mesh_cloud__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);


__webpack_require__(1).glMatrix.setMatrixArrayType(Array);

var _marked = /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(compress);




function compareUniform(a, b, temp) {
  var ua = a.uniforms || {};
  var ub = b.uniforms || {};
  if (ua.u_texSampler && ub.u_texSampler && ua.u_texSampler !== ub.u_texSampler) return false;
  var keysA = Object.keys(ua),
      keysB = Object.keys(ub); // console.log(keysA, keysB);

  var idx1 = keysA.indexOf('u_texSampler');
  var idx2 = keysB.indexOf('u_texSampler');
  if (idx1 >= 0) keysA.splice(idx1, 1);
  if (idx2 >= 0) keysB.splice(idx2, 1);
  if (keysA.length !== keysB.length) return false;
  var ret = keysA.every(function (key) {
    var va = ua[key],
        vb = ub[key];
    if (va === vb) return true;

    if (va.length && vb.length && va.length === vb.length) {
      for (var i = 0; i < va.length; i++) {
        if (va[i] !== vb[i]) return false;
      }

      return true;
    }

    return false;
  });

  if (ret) {
    if (ua.u_texSampler && !ub.u_texSampler) {
      b.setTexture(ua.u_texSampler, {
        hidden: true
      });
    } else if (!ua.u_texSampler && ub.u_texSampler) {
      // a.setTexture(ub.u_texSampler, {hidden: true});
      for (var i = 0; i < temp.length; i++) {
        temp[i].setTexture(ub.u_texSampler, {
          hidden: true
        });
      }
    }
  }

  return ret;
}

var bufferCache = {};

function packData(temp, enableBlend) {
  if (temp.length) {
    var meshData = Object(_flatten_meshes__WEBPACK_IMPORTED_MODULE_1__["default"])(temp, bufferCache);
    meshData.enableBlend = enableBlend;

    if (temp[0].filterCanvas) {
      meshData.filterCanvas = true;
    }

    meshData.packIndex = temp[0].packIndex;
    meshData.packLength = temp.length;
    meshData.beforeRender = temp[0].beforeRender;
    meshData.pass = temp[0].pass;
    meshData.mode = temp[0].mode;
    meshData.afterRender = temp[temp.length - 1].afterRender;
    temp.length = 0;
    return meshData;
  }
}

function compress(renderer, meshes) {
  var ignoreTrasnparent,
      temp,
      maxSize,
      size,
      enableBlend,
      i,
      mesh,
      meshData,
      texture,
      len,
      filterCanvas,
      lastMesh,
      _args = arguments;
  return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function compress$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          ignoreTrasnparent = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;
          temp = [];
          maxSize = renderer.options.bufferSize;
          size = 0;
          enableBlend = false;
          i = 0;

        case 6:
          if (!(i < meshes.length)) {
            _context.next = 50;
            break;
          }

          mesh = meshes[i];

          if (!(mesh instanceof _mesh_cloud__WEBPACK_IMPORTED_MODULE_2__["default"])) {
            _context.next = 18;
            break;
          }

          if (!temp.length) {
            _context.next = 12;
            break;
          }

          _context.next = 12;
          return packData(temp, enableBlend);

        case 12:
          size = 0;
          enableBlend = false;
          _context.next = 16;
          return mesh;

        case 16:
          _context.next = 47;
          break;

        case 18:
          meshData = mesh.meshData;

          if (meshData.clipPath && !meshData.uniforms.u_clipSampler) {
            texture = renderer.createTexture(meshData.clipPath);
            meshData.uniforms.u_clipSampler = texture;
          }

          len = 0;

          if (!((!ignoreTrasnparent || !mesh.canIgnore()) && meshData && meshData.positions.length)) {
            _context.next = 43;
            break;
          }

          mesh.packIndex = i;
          filterCanvas = mesh.filterCanvas;
          len = meshData.positions.length;

          if (!(filterCanvas || size + len > maxSize)) {
            _context.next = 33;
            break;
          }

          if (!temp.length) {
            _context.next = 29;
            break;
          }

          _context.next = 29;
          return packData(temp, enableBlend);

        case 29:
          size = 0;
          enableBlend = false;
          _context.next = 40;
          break;

        case 33:
          if (!size) {
            _context.next = 40;
            break;
          }

          lastMesh = temp[temp.length - 1];

          if (!(lastMesh && (lastMesh.filterCanvas || lastMesh.afterRender || mesh.beforeRender || lastMesh.pass.length || mesh.pass.length || lastMesh.program !== mesh.program || lastMesh.mode !== mesh.mode || !!lastMesh.meshData.cells !== !!mesh.meshData.cells || !compareUniform(lastMesh, mesh, temp)))) {
            _context.next = 40;
            break;
          }

          _context.next = 38;
          return packData(temp, enableBlend);

        case 38:
          size = 0;
          enableBlend = false;

        case 40:
          temp.push(mesh);
          enableBlend = enableBlend || mesh.enableBlend;
          size += len;

        case 43:
          if (!(i === meshes.length - 1)) {
            _context.next = 47;
            break;
          }

          if (!temp.length) {
            _context.next = 47;
            break;
          }

          _context.next = 47;
          return packData(temp, enableBlend);

        case 47:
          i++;
          _context.next = 6;
          break;

        case 50:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return flattenMeshes; });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__);



__webpack_require__(1).glMatrix.setMatrixArrayType(Array);

var typeMap = {
  UNSIGNED_BYTE: Uint8Array,
  UNSIGNED_SHORT: Uint16Array,
  BYTE: Int8Array,
  SHORT: Int16Array,
  FLOAT: Float32Array
};

function allocateBuffer(meshes, bufferCache) {
  // eslint-disable-line complexity
  var positionsCount = 0;
  var cellsCount = 0;
  var textureCoordCount = 0;
  var sourceRectCount = 0;
  var clipUVCount = 0;
  var colorCount = 0;
  var count = 0;
  var program = meshes[0].program;
  var hasCell = !!meshes[0].meshData.cells;

  for (var i = 0; i < meshes.length; i++) {
    var mesh = meshes[i].meshData;

    if (mesh) {
      count += mesh.positions.length;
      var dimension = mesh.positions[0].length;
      positionsCount += mesh.positions.length * dimension;
      if (hasCell) cellsCount += mesh.cells.length * 3;
      colorCount += mesh.attributes.a_color.length * 4;
      var _textureCoord = mesh.textureCoord;

      if (_textureCoord) {
        textureCoordCount += _textureCoord.length * _textureCoord[0].length;
      }

      var _sourceRect = mesh.attributes.a_sourceRect;

      if (_sourceRect) {
        sourceRectCount += _sourceRect.length * 4;
      }

      var _clipUV = mesh.attributes.a_clipUV;

      if (_clipUV) {
        clipUVCount += _clipUV.length * 2;
      }
    }
  }

  if (!bufferCache.positions || bufferCache.positions.length < positionsCount) {
    bufferCache.positions = new Float32Array(positionsCount);
  }

  if (hasCell && (!bufferCache.cells || bufferCache.cells.length < cellsCount)) {
    bufferCache.cells = new Uint16Array(cellsCount);
  }

  if (textureCoordCount) {
    if (!bufferCache.textureCoord || bufferCache.textureCoord.length < textureCoordCount) {
      bufferCache.textureCoord = new Float32Array(textureCoordCount);
    }
  }

  if (!bufferCache.a_color || bufferCache.a_color.length < colorCount) {
    bufferCache.a_color = new Uint8Array(colorCount);
  }

  if (sourceRectCount) {
    if (!bufferCache.a_sourceRect || bufferCache.a_sourceRect.length < sourceRectCount) {
      bufferCache.a_sourceRect = new Float32Array(sourceRectCount);
    }
  }

  if (clipUVCount) {
    if (!bufferCache.a_clipUV || bufferCache.a_clipUV.length < clipUVCount) {
      bufferCache.a_clipUV = new Float32Array(clipUVCount);
    }
  }

  if (program) {
    var attribs = Object.entries(program._attribute);
    var meta = program._attribOpts || {};

    for (var _i = 0; _i < attribs.length; _i++) {
      var _attribs$_i = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(attribs[_i], 2),
          key = _attribs$_i[0],
          opts = _attribs$_i[1];

      if (key !== 'a_color' && key !== 'a_sourceRect' && opts !== 'ignored') {
        var type = meta[key] ? meta[key].type : 'FLOAT';
        var TypeArray = typeMap[type];
        var attribCount = opts.size * count;

        if (!bufferCache[key] || bufferCache[key].length < attribCount) {
          bufferCache[key] = new TypeArray(attribCount);
        }
      }
    }
  }

  return bufferCache;
}

function flattenMeshes(meshes, bufferCache) {
  // eslint-disable-line complexity
  var positions = [];
  var cells = [];
  var textureCoord = [];
  var a_color = [];
  var a_sourceRect = []; // sourceRect no buffer;

  var a_clipUV = []; // uv no buffer

  var idx = 0;
  var cidx = 0;
  var uniforms = meshes[0] ? meshes[0].uniforms || {} : {};
  var program = meshes[0] ? meshes[0].program : null;
  var hasCell = false;

  if (meshes[0]) {
    hasCell = !!meshes[0].cells || meshes[0].meshData && !!meshes[0].meshData.cells;
  }

  if (bufferCache) {
    allocateBuffer(meshes, bufferCache);
    cells = bufferCache.cells;
    positions = bufferCache.positions;
    textureCoord = bufferCache.textureCoord;
    a_color = bufferCache.a_color;
    a_sourceRect = bufferCache.a_sourceRect;
    a_clipUV = bufferCache.a_clipUV;
  }

  var hasSourceRect = false;
  var hasClipPath = false;
  var attributes = {};

  for (var i = 0; i < meshes.length; i++) {
    var mesh = meshes[i];

    if (mesh) {
      if (mesh.meshData) mesh = mesh.meshData;

      if (bufferCache) {
        var _positions = mesh.positions;

        for (var j = 0; j < _positions.length; j++) {
          var p = _positions[j];
          var o = 3 * (idx + j);

          for (var k = 0; k < p.length; k++) {
            positions[o + k] = p[k];
          }
        }
      } else {
        var _positions2;

        (_positions2 = positions).push.apply(_positions2, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(mesh.positions));
      }

      if (hasCell) {
        var _cells = mesh.cells;

        for (var _j = 0; _j < _cells.length; _j++) {
          var cell = _cells[_j];

          if (bufferCache) {
            var _o = 3 * (cidx + _j);

            cells[_o] = cell[0] + idx;
            cells[_o + 1] = cell[1] + idx;
            cells[_o + 2] = cell[2] + idx;
          } else {
            cells.push([cell[0] + idx, cell[1] + idx, cell[2] + idx]);
          }
        }
      } // cells.push(...mesh.cells.map(cell => cell.map(c => c + idx)));


      if (bufferCache) {
        var _colors = mesh.attributes.a_color;

        for (var _j2 = 0; _j2 < _colors.length; _j2++) {
          var c = _colors[_j2];

          var _o2 = 4 * (idx + _j2);

          a_color[_o2] = c[0];
          a_color[_o2 + 1] = c[1];
          a_color[_o2 + 2] = c[2];
          a_color[_o2 + 3] = c[3];
        }
      } else {
        var _a_color;

        (_a_color = a_color).push.apply(_a_color, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(mesh.attributes.a_color));
      }

      if (mesh.attributes.a_sourceRect) {
        hasSourceRect = true;

        if (bufferCache) {
          var _sourceRect = mesh.attributes.a_sourceRect;

          for (var _j3 = 0; _j3 < _sourceRect.length; _j3++) {
            var s = _sourceRect[_j3];

            var _o3 = 4 * (idx + _j3);

            a_sourceRect[_o3] = s[0];
            a_sourceRect[_o3 + 1] = s[1];
            a_sourceRect[_o3 + 2] = s[2];
            a_sourceRect[_o3 + 3] = s[3];
          }
        } else {
          var _a_sourceRect;

          (_a_sourceRect = a_sourceRect).push.apply(_a_sourceRect, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(mesh.attributes.a_sourceRect));
        }
      }

      if (mesh.attributes.a_clipUV) {
        hasClipPath = true;

        if (bufferCache) {
          var _clipUV = mesh.attributes.a_clipUV;

          for (var _j4 = 0; _j4 < _clipUV.length; _j4++) {
            var _s = _clipUV[_j4];

            var _o4 = 2 * (idx + _j4);

            a_clipUV[_o4] = _s[0];
            a_clipUV[_o4 + 1] = _s[1];
          }
        } else {
          var _a_clipUV;

          (_a_clipUV = a_clipUV).push.apply(_a_clipUV, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(mesh.attributes.a_clipUV));
        }
      }

      if (mesh.textureCoord) {
        if (bufferCache) {
          var _textureCoord = mesh.textureCoord;

          for (var _j5 = 0; _j5 < _textureCoord.length; _j5++) {
            var t = _textureCoord[_j5];

            var _o5 = 3 * (idx + _j5);

            for (var _k = 0; _k < t.length; _k++) {
              textureCoord[_o5 + _k] = t[_k];
            }
          }
        } else {
          var _textureCoord2;

          (_textureCoord2 = textureCoord).push.apply(_textureCoord2, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(mesh.textureCoord));
        }
      }

      if (program) {
        var attribs = Object.entries(program._attribute);

        for (var _j6 = 0; _j6 < attribs.length; _j6++) {
          var _attribs$_j = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(attribs[_j6], 2),
              name = _attribs$_j[0],
              opts = _attribs$_j[1];

          if (name !== 'a_color' && name !== 'a_sourceRect' && opts !== 'ignored') {
            attributes[name] = [];

            if (bufferCache) {
              attributes[name] = bufferCache[name];
              var _attr = mesh.attributes[name];
              var size = _attr[0].length;

              for (var _k2 = 0; _k2 < _attr.length; _k2++) {
                var _t = _attr[_k2];

                var _o6 = size * (idx + _k2);

                for (var w = 0; w < _t.length; w++) {
                  attributes[name][_o6 + w] = _t[w];
                }
              }
            } else {
              var _attributes$name;

              (_attributes$name = attributes[name]).push.apply(_attributes$name, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(mesh.attributes[name]));
            }
          }
        }
      }

      idx += mesh.positions.length;
      if (hasCell) cidx += mesh.cells.length;
    }
  }

  attributes.a_color = a_color;
  if (hasSourceRect && a_sourceRect && a_sourceRect.length > 0) attributes.a_sourceRect = a_sourceRect;
  var ret = {
    positions: positions,
    attributes: attributes,
    uniforms: uniforms,
    program: program
  };

  if (hasCell) {
    ret.cells = cells;
    ret.cellsCount = cidx * 3;
  }

  if (textureCoord && textureCoord.length) {
    ret.textureCoord = textureCoord;
  }

  if (hasClipPath && a_clipUV.length > 0) attributes.a_clipUV = a_clipUV;
  return ret;
}

/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _default; });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(24);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1);
/* harmony import */ var _utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(46);
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(42);
/* harmony import */ var _utils_parse_color__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(47);






__webpack_require__(1).glMatrix.setMatrixArrayType(Array);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






var _mesh = Symbol('mesh');

var _count = Symbol('count');

var _blend = Symbol('blend');

var _filters = Symbol('filter');

var _textures = Symbol('textures');

var _textureOptions = Symbol('textureOptions');

var _hasCloudColor = Symbol('cloudColor');

var _hasCloudFilter = Symbol('cloudFilter');

var _buffer = Symbol('buffer');

function createBuffer(buffer) {
  var oldBuffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var transform0 = new Float32Array(3 * buffer);
  var transform1 = new Float32Array(3 * buffer);
  var color0 = new Float32Array(4 * buffer);
  var color1 = new Float32Array(4 * buffer);
  var color2 = new Float32Array(4 * buffer);
  var color3 = new Float32Array(4 * buffer);
  var color4 = new Float32Array(4 * buffer);
  var frameIndex = new Uint8Array(buffer);
  var fillColor = new Uint8Array(4 * buffer);
  var strokeColor = new Uint8Array(4 * buffer);

  if (oldBuffer) {
    transform0.set(oldBuffer.transform0, 0);
    transform1.set(oldBuffer.transform1, 0);
    color0.set(oldBuffer.color0, 0);
    color1.set(oldBuffer.color1, 0);
    color2.set(oldBuffer.color2, 0);
    color3.set(oldBuffer.color3, 0);
    color4.set(oldBuffer.color4, 0);
    frameIndex.set(oldBuffer.frameIndex, 0);
    fillColor.set(oldBuffer.fillColor, 0);
    strokeColor.set(oldBuffer.strokeColor, 0);
  }

  return {
    bufferSize: buffer,
    transform0: transform0,
    transform1: transform1,
    color0: color0,
    color1: color1,
    color2: color2,
    color3: color3,
    color4: color4,
    frameIndex: frameIndex,
    fillColor: fillColor,
    strokeColor: strokeColor
  };
}

var _default = /*#__PURE__*/function () {
  function _default(mesh) {
    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$buffer = _ref.buffer,
        buffer = _ref$buffer === void 0 ? 1000 : _ref$buffer;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3___default()(this, _default);

    buffer = Math.max(buffer, amount);
    this[_count] = amount;
    this[_mesh] = mesh;
    this[_buffer] = createBuffer(buffer);
    this[_textures] = [];
    this[_filters] = [];
    this[_hasCloudColor] = false;
    this[_hasCloudFilter] = false;
    this[_blend] = false;
    this.initBuffer();
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4___default()(_default, [{
    key: "initBuffer",
    value: function initBuffer() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var amount = this[_count];

      for (var i = offset; i < amount; i++) {
        this[_buffer].transform0.set([1, 0, 0], i * 3);

        this[_buffer].transform1.set([0, 1, 0], i * 3);

        this[_buffer].frameIndex.set([-1], i);

        this[_buffer].fillColor.set([0, 0, 0, 0], i * 4);

        this[_buffer].strokeColor.set([0, 0, 0, 0], i * 4);

        this.setColorTransform(i, null);
      }
    }
  }, {
    key: "_getFilter",
    value: function _getFilter(idx) {
      this[_filters][idx] = this[_filters][idx] || [];
      return this[_filters][idx];
    }
  }, {
    key: "getFilter",
    value: function getFilter(idx) {
      return this._getFilter(idx).join(' ');
    }
  }, {
    key: "canIgnore",
    value: function canIgnore() {
      return this[_mesh].canIgnore();
    }
  }, {
    key: "delete",
    value: function _delete(idx) {
      if (idx >= this[_count] || idx < 0) throw new Error('Out of range.');
      var _this$_buffer = this[_buffer],
          transform0 = _this$_buffer.transform0,
          transform1 = _this$_buffer.transform1,
          color0 = _this$_buffer.color0,
          color1 = _this$_buffer.color1,
          color2 = _this$_buffer.color2,
          color3 = _this$_buffer.color3,
          color4 = _this$_buffer.color4,
          frameIndex = _this$_buffer.frameIndex,
          fillColor = _this$_buffer.fillColor,
          strokeColor = _this$_buffer.strokeColor;
      transform0.set(transform0.subarray(3 * (idx + 1)), 3 * idx);
      transform1.set(transform1.subarray(3 * (idx + 1)), 3 * idx);
      color0.set(color0.subarray(4 * (idx + 1)), 4 * idx);
      color1.set(color1.subarray(4 * (idx + 1)), 4 * idx);
      color2.set(color2.subarray(4 * (idx + 1)), 4 * idx);
      color3.set(color3.subarray(4 * (idx + 1)), 4 * idx);
      color4.set(color4.subarray(4 * (idx + 1)), 4 * idx);
      frameIndex.set(frameIndex.subarray(idx + 1), idx);
      fillColor.set(fillColor.subarray(4 * (idx + 1)), 4 * idx);
      strokeColor.set(strokeColor.subarray(4 * (idx + 1)), 4 * idx);

      for (var i in this[_filters]) {
        // eslint-disable-line no-restricted-syntax
        if (i === idx) {
          delete this[_filters][i];
        } else if (i > idx) {
          this[_filters][i - 1] = this[_filters][i];
          delete this[_filters][i];
        }
      }

      this[_count]--;
    }
  }, {
    key: "setColorTransform",
    value: function setColorTransform(idx, m) {
      if (idx >= this[_count] || idx < 0) throw new Error('Out of range.');
      idx *= 4;
      var _this$_buffer2 = this[_buffer],
          color0 = _this$_buffer2.color0,
          color1 = _this$_buffer2.color1,
          color2 = _this$_buffer2.color2,
          color3 = _this$_buffer2.color3,
          color4 = _this$_buffer2.color4;

      if (m != null) {
        color0.set([m[0], m[5], m[10], m[15]], idx);
        color1.set([m[1], m[6], m[11], m[16]], idx);
        color2.set([m[2], m[7], m[12], m[17]], idx);
        color3.set([m[3], m[8], m[13], m[18]], idx);
        color4.set([m[4], m[9], m[14], m[19]], idx);
        this[_blend] = this[_blend] || m[18] < 1.0;
        this[_hasCloudFilter] = true;
      } else {
        color0.set([1, 0, 0, 0], idx);
        color1.set([0, 1, 0, 0], idx);
        color2.set([0, 0, 1, 0], idx);
        color3.set([0, 0, 0, 1], idx);
        color4.set([0, 0, 0, 0], idx);
      }

      return this;
    }
  }, {
    key: "getColorTransform",
    value: function getColorTransform(idx) {
      if (idx >= this[_count] || idx < 0) throw new Error('Out of range.');
      idx *= 4;
      var _this$_buffer3 = this[_buffer],
          color0 = _this$_buffer3.color0,
          color1 = _this$_buffer3.color1,
          color2 = _this$_buffer3.color2,
          color3 = _this$_buffer3.color3,
          color4 = _this$_buffer3.color4;
      return [color0[idx], color1[idx], color2[idx], color3[idx], color4[idx], color0[idx + 1], color1[idx + 1], color2[idx + 1], color3[idx + 1], color4[idx + 1], color0[idx + 2], color1[idx + 2], color2[idx + 2], color3[idx + 2], color4[idx + 2], color0[idx + 3], color1[idx + 3], color2[idx + 3], color3[idx + 3], color4[idx + 3]];
    }
  }, {
    key: "transformColor",
    value: function transformColor(idx, m) {
      var transform = this.getColorTransform(idx);
      transform = Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["multiply"])(transform, m);
      this.setColorTransform(idx, transform);
      return this;
    }
  }, {
    key: "setFillColor",
    value: function setFillColor(idx, color) {
      if (idx >= this[_count] || idx < 0) throw new Error('Out of range.');
      if (typeof color === 'string') color = Object(_utils_parse_color__WEBPACK_IMPORTED_MODULE_8__["default"])(color);
      if (color[3] > 0.0) this[_hasCloudColor] = true;

      this[_buffer].fillColor.set(color.map(function (c) {
        return Math.round(255 * c);
      }), 4 * idx);
    }
  }, {
    key: "setStrokeColor",
    value: function setStrokeColor(idx, color) {
      if (idx >= this[_count] || idx < 0) throw new Error('Out of range.');
      if (typeof color === 'string') color = Object(_utils_parse_color__WEBPACK_IMPORTED_MODULE_8__["default"])(color);
      if (color[3] > 0.0) this[_hasCloudColor] = true;

      this[_buffer].strokeColor.set(color.map(function (c) {
        return Math.round(255 * c);
      }), 4 * idx);
    }
  }, {
    key: "getCloudRGBA",
    value: function getCloudRGBA(idx) {
      if (idx >= this[_count] || idx < 0) throw new Error('Out of range.');
      idx *= 4;
      var _this$_buffer4 = this[_buffer],
          fillColor = _this$_buffer4.fillColor,
          strokeColor = _this$_buffer4.strokeColor;
      var _fillColor = [fillColor[idx], fillColor[idx + 1], fillColor[idx + 2], fillColor[idx + 3]];
      var _strokeColor = [strokeColor[idx], strokeColor[idx + 1], strokeColor[idx + 2], strokeColor[idx + 3]];
      _fillColor[3] /= 255;
      _strokeColor[3] /= 255;
      return {
        fill: "rgba(".concat(_fillColor.join(), ")"),
        stroke: "rgba(".concat(_strokeColor.join(), ")")
      };
    }
  }, {
    key: "grayscale",
    value: function grayscale(idx, p) {
      this.transformColor(idx, Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["grayscale"])(p));

      this._getFilter(idx).push("grayscale(".concat(100 * p, "%)"));
    }
  }, {
    key: "brightness",
    value: function brightness(idx, p) {
      this.transformColor(idx, Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["brightness"])(p));

      this._getFilter(idx).push("brightness(".concat(100 * p, "%)"));
    }
  }, {
    key: "saturate",
    value: function saturate(idx, p) {
      this.transformColor(idx, Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["saturate"])(p));

      this._getFilter(idx).push("saturate(".concat(100 * p, "%)"));
    }
  }, {
    key: "contrast",
    value: function contrast(idx, p) {
      this.transformColor(idx, Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["contrast"])(p));

      this._getFilter(idx).push("contrast(".concat(100 * p, "%)"));
    }
  }, {
    key: "invert",
    value: function invert(idx, p) {
      this.transformColor(idx, Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["invert"])(p));

      this._getFilter(idx).push("invert(".concat(100 * p, "%)"));
    }
  }, {
    key: "sepia",
    value: function sepia(idx, p) {
      this.transformColor(idx, Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["sepia"])(p));

      this._getFilter(idx).push("sepia(".concat(100 * p, "%)"));
    }
  }, {
    key: "opacity",
    value: function opacity(idx, p) {
      this.transformColor(idx, Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["opacity"])(p));

      this._getFilter(idx).push("opacity(".concat(100 * p, "%)"));
    }
  }, {
    key: "hueRotate",
    value: function hueRotate(idx, deg) {
      this.transformColor(idx, Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_6__["hueRotate"])(deg));

      this._getFilter(idx).push("hue-rotate(".concat(deg, "deg)"));
    }
  }, {
    key: "setTransform",
    value: function setTransform(idx, m) {
      if (idx >= this[_count] || idx < 0) throw new Error('Out of range.');
      idx *= 3;
      if (m == null) m = [1, 0, 0, 1, 0, 0];
      var _this$_buffer5 = this[_buffer],
          transform0 = _this$_buffer5.transform0,
          transform1 = _this$_buffer5.transform1;
      transform0.set([m[0], m[2], m[4]], idx);
      transform1.set([m[1], m[3], m[5]], idx);
      return this;
    }
  }, {
    key: "getTransform",
    value: function getTransform(idx) {
      if (idx >= this[_count] || idx < 0) throw new Error('Out of range.');
      idx *= 3;
      var _this$_buffer6 = this[_buffer],
          transform0 = _this$_buffer6.transform0,
          transform1 = _this$_buffer6.transform1;
      var m = [transform0[idx], transform1[idx], transform0[idx + 1], transform1[idx + 1], transform0[idx + 2], transform1[idx + 2]];
      return m;
    }
  }, {
    key: "getTextureFrame",
    value: function getTextureFrame(idx) {
      return this[_textures][this[_buffer].frameIndex[idx]];
    }
  }, {
    key: "setTextureFrames",
    value: function setTextureFrames() {
      var frames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (frames.length > 12) {
        throw new Error('Max frames exceed. Allow 12 frames.');
      }

      if (frames.length) {
        var mesh = this[_mesh];
        mesh.setTexture(frames[0], options);
      }

      this[_textures] = frames;
      this[_textureOptions] = options;
    }
  }, {
    key: "setFrameIndex",
    value: function setFrameIndex(idx, frameIndex) {
      if (idx >= this[_count] || idx < 0) throw new Error('Out of range.');
      var len = this[_textures].length;
      if (len <= 0) throw new Error('No frames');
      this[_buffer].frameIndex[idx] = frameIndex % len;
    }
  }, {
    key: "setProgram",
    value: function setProgram(program) {
      this[_mesh].setProgram(program);
    }
  }, {
    key: "transform",
    value: function transform(idx, m) {
      var transform = this.getTransform(idx);
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].multiply(Array.of(0, 0, 0, 0, 0, 0), transform, m);
      this.setTransform(idx, m);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(idx, _ref2) {
      var _ref3 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref2, 2),
          x = _ref3[0],
          y = _ref3[1];

      var m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].create();
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0, 0, 0, 0, 0, 0), m, [x, y]);
      return this.transform(idx, m);
    }
  }, {
    key: "rotate",
    value: function rotate(idx, rad) {
      var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0],
          _ref5 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref4, 2),
          ox = _ref5[0],
          oy = _ref5[1];

      var m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].create();
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0, 0, 0, 0, 0, 0), m, [ox, oy]);
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].rotate(Array.of(0, 0, 0, 0, 0, 0), m, rad);
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0, 0, 0, 0, 0, 0), m, [-ox, -oy]);
      return this.transform(idx, m);
    }
  }, {
    key: "scale",
    value: function scale(idx, _ref6) {
      var _ref7 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref6, 2),
          x = _ref7[0],
          _ref7$ = _ref7[1],
          y = _ref7$ === void 0 ? x : _ref7$;

      var _ref8 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0],
          _ref9 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref8, 2),
          ox = _ref9[0],
          oy = _ref9[1];

      var m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].create();
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0, 0, 0, 0, 0, 0), m, [ox, oy]);
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].scale(Array.of(0, 0, 0, 0, 0, 0), m, [x, y]);
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0, 0, 0, 0, 0, 0), m, [-ox, -oy]);
      return this.transform(idx, m);
    }
  }, {
    key: "skew",
    value: function skew(idx, _ref10) {
      var _ref11 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref10, 2),
          x = _ref11[0],
          _ref11$ = _ref11[1],
          y = _ref11$ === void 0 ? x : _ref11$;

      var _ref12 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0],
          _ref13 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref12, 2),
          ox = _ref13[0],
          oy = _ref13[1];

      var m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].create();
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0, 0, 0, 0, 0, 0), m, [ox, oy]);
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].multiply(Array.of(0, 0, 0, 0, 0, 0), m, gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].fromValues(1, Math.tan(y), Math.tan(x), 1, 0, 0));
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0, 0, 0, 0, 0, 0), m, [-ox, -oy]);
      return this.transform(idx, m);
    }
  }, {
    key: "isPointCollision",
    value: function isPointCollision(idx, _ref14) {
      var _this$_mesh;

      var _ref15 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref14, 2),
          x = _ref15[0],
          y = _ref15[1];

      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'both';
      var m = this.getTransform(idx);
      var p = Object(_utils_math__WEBPACK_IMPORTED_MODULE_7__["transformPoint"])([x, y], gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].invert(Array.of(0, 0, 0, 0, 0, 0), m));
      return (_this$_mesh = this[_mesh]).isPointCollision.apply(_this$_mesh, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(p).concat([type]));
    }
  }, {
    key: "isPointInFill",
    value: function isPointInFill(idx, _ref16) {
      var _ref17 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref16, 2),
          x = _ref17[0],
          y = _ref17[1];

      return this.isPointCollision(idx, [x, y], 'fill');
    }
  }, {
    key: "isPointInStroke",
    value: function isPointInStroke(idx, _ref18) {
      var _ref19 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref18, 2),
          x = _ref19[0],
          y = _ref19[1];

      return this.isPointCollision(idx, [x, y], 'stroke');
    }
  }, {
    key: "bufferSize",
    get: function get() {
      return this[_buffer].bufferSize;
    }
  }, {
    key: "mesh",
    get: function get() {
      return this[_mesh];
    },
    set: function set(mesh) {
      this[_mesh] = mesh;

      if (this[_textures]) {
        this.setTextureFrames(this[_textures], this[_textureOptions]);
      }
    }
  }, {
    key: "hasCloudColor",
    get: function get() {
      return this[_hasCloudColor];
    }
  }, {
    key: "hasCloudFilter",
    get: function get() {
      return this[_hasCloudFilter];
    }
  }, {
    key: "enableBlend",
    get: function get() {
      return this[_mesh].enableBlend || this[_blend];
    }
  }, {
    key: "amount",
    get: function get() {
      return this[_count];
    },
    set: function set(value) {
      var amount = this[_count];
      if (value === amount) return;

      if (value > this[_buffer].bufferSize) {
        this[_buffer] = createBuffer(Math.max(value, this[_buffer].bufferSize + 1000), this[_buffer]);
      }

      this[_count] = value;

      if (value > amount) {
        this.initBuffer(amount);
      }
    }
  }, {
    key: "meshData",
    get: function get() {
      var _this$_mesh$meshData = this[_mesh].meshData,
          attributes = _this$_mesh$meshData.attributes,
          cells = _this$_mesh$meshData.cells,
          positions = _this$_mesh$meshData.positions,
          textureCoord = _this$_mesh$meshData.textureCoord,
          uniforms = _this$_mesh$meshData.uniforms;
      var frames = this[_textures];
      var meshData = {
        attributes: _objectSpread({}, attributes),
        cells: cells,
        positions: positions,
        textureCoord: textureCoord,
        uniforms: _objectSpread({}, uniforms),
        instanceCount: this[_count],
        enableBlend: this.enableBlend
      };

      if (frames.length) {
        frames.forEach(function (frame, i) {
          meshData.uniforms["u_texFrame".concat(i)] = frame;
        });
      }

      var _this$_buffer7 = this[_buffer],
          transform0 = _this$_buffer7.transform0,
          transform1 = _this$_buffer7.transform1,
          color0 = _this$_buffer7.color0,
          color1 = _this$_buffer7.color1,
          color2 = _this$_buffer7.color2,
          color3 = _this$_buffer7.color3,
          color4 = _this$_buffer7.color4,
          fillColor = _this$_buffer7.fillColor,
          strokeColor = _this$_buffer7.strokeColor,
          frameIndex = _this$_buffer7.frameIndex;

      if (this[_mesh].uniforms.u_texSampler) {
        meshData.attributes.a_frameIndex = {
          data: frameIndex,
          divisor: 1
        };
      } // console.log(this[_mesh].meshData)


      meshData.attributes.a_transform0 = {
        data: transform0,
        divisor: 1
      };
      meshData.attributes.a_transform1 = {
        data: transform1,
        divisor: 1
      };
      meshData.attributes.a_colorCloud0 = {
        data: color0,
        divisor: 1
      };
      meshData.attributes.a_colorCloud1 = {
        data: color1,
        divisor: 1
      };
      meshData.attributes.a_colorCloud2 = {
        data: color2,
        divisor: 1
      };
      meshData.attributes.a_colorCloud3 = {
        data: color3,
        divisor: 1
      };
      meshData.attributes.a_colorCloud4 = {
        data: color4,
        divisor: 1
      };

      if (this.hasCloudColor) {
        meshData.attributes.a_fillCloudColor = {
          data: fillColor,
          divisor: 1
        };
        meshData.attributes.a_strokeCloudColor = {
          data: strokeColor,
          divisor: 1
        };
      }

      return meshData;
    }
  }, {
    key: "program",
    get: function get() {
      return this[_mesh].program;
    }
  }]);

  return _default;
}();



/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "grayscale", function() { return grayscale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brightness", function() { return brightness; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saturate", function() { return saturate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "contrast", function() { return contrast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sepia", function() { return sepia; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "opacity", function() { return opacity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hueRotate", function() { return hueRotate; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
__webpack_require__(1).glMatrix.setMatrixArrayType(Array);


function multiply(a, b) {
  var out = [];
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3],
      a04 = a[4]; // eslint-disable-line one-var-declaration-per-line

  var a10 = a[5],
      a11 = a[6],
      a12 = a[7],
      a13 = a[8],
      a14 = a[9]; // eslint-disable-line one-var-declaration-per-line

  var a20 = a[10],
      a21 = a[11],
      a22 = a[12],
      a23 = a[13],
      a24 = a[14]; // eslint-disable-line one-var-declaration-per-line

  var a30 = a[15],
      a31 = a[16],
      a32 = a[17],
      a33 = a[18],
      a34 = a[19]; // eslint-disable-line one-var-declaration-per-line
  // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4]; // eslint-disable-line one-var-declaration-per-line

  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  out[4] = b0 * a04 + b1 * a14 + b2 * a24 + b3 * a34 + b4;
  b0 = b[5];
  b1 = b[6];
  b2 = b[7];
  b3 = b[8];
  b4 = b[9];
  out[5] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[6] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[7] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[8] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  out[9] = b0 * a04 + b1 * a14 + b2 * a24 + b3 * a34 + b4;
  b0 = b[10];
  b1 = b[11];
  b2 = b[12];
  b3 = b[13];
  b4 = b[14];
  out[10] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[11] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[12] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[13] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  out[14] = b0 * a04 + b1 * a14 + b2 * a24 + b3 * a34 + b4;
  b0 = b[15];
  b1 = b[16];
  b2 = b[17];
  b3 = b[18];
  b4 = b[19];
  out[15] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[16] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[17] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[18] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  out[19] = b0 * a04 + b1 * a14 + b2 * a24 + b3 * a34 + b4;
  return out;
} // export function transformColor(color, m) {
//   const [r, g, b, a] = color;
//   color[0] = m[0] * r + m[1] * g + m[2] * b + m[3] * a + m[4];
//   color[1] = m[5] * r + m[6] * g + m[7] * b + m[8] * a + m[9];
//   color[2] = m[10] * r + m[11] * g + m[12] * b + m[13] * a + m[14];
//   color[3] = m[15] * r + m[16] * g + m[17] * b + m[18] * a + m[19];
//   return color;
// }

function grayscale(p) {
  p = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clamp"])(0, 1, p);
  var r = 0.2126 * p;
  var g = 0.7152 * p;
  var b = 0.0722 * p;
  return [r + 1 - p, g, b, 0, 0, r, g + 1 - p, b, 0, 0, r, g, b + 1 - p, 0, 0, 0, 0, 0, 1, 0];
}
function brightness(p) {
  return [p, 0, 0, 0, 0, 0, p, 0, 0, 0, 0, 0, p, 0, 0, 0, 0, 0, 1, 0];
}
function saturate(p) {
  // p = clamp(0, 1, p);
  var r = 0.2126 * (1 - p);
  var g = 0.7152 * (1 - p);
  var b = 0.0722 * (1 - p);
  return [r + p, g, b, 0, 0, r, g + p, b, 0, 0, r, g, b + p, 0, 0, 0, 0, 0, 1, 0];
}
function contrast(p) {
  var d = 0.5 * (1 - p);
  return [p, 0, 0, 0, d, 0, p, 0, 0, d, 0, 0, p, 0, d, 0, 0, 0, 1, 0];
}
function invert(p) {
  var d = 1 - 2 * p;
  return [d, 0, 0, 0, p, 0, d, 0, 0, p, 0, 0, d, 0, p, 0, 0, 0, 1, 0];
}
function sepia(p) {
  return [1 - 0.607 * p, 0.769 * p, 0.189 * p, 0, 0, 0.349 * p, 1 - 0.314 * p, 0.168 * p, 0, 0, 0.272 * p, 0.534 * p, 1 - 0.869 * p, 0, 0, 0, 0, 0, 1, 0];
}
function opacity(p) {
  return [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, p, 0];
}
function hueRotate(deg) {
  var rotation = deg / 180 * Math.PI;
  var cos = Math.cos(rotation),
      sin = Math.sin(rotation),
      lumR = 0.2126,
      lumG = 0.7152,
      lumB = 0.0722;
  return [lumR + cos * (1 - lumR) + sin * -lumR, lumG + cos * -lumG + sin * -lumG, lumB + cos * -lumB + sin * (1 - lumB), 0, 0, lumR + cos * -lumR + sin * 0.143, lumG + cos * (1 - lumG) + sin * 0.140, lumB + cos * -lumB + sin * -0.283, 0, 0, lumR + cos * -lumR + sin * -(1 - lumR), lumG + cos * -lumG + sin * lumG, lumB + cos * (1 - lumB) + sin * lumB, 0, 0, 0, 0, 0, 1, 0];
}

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseColor; });
/* harmony import */ var color_rgba__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48);
/* harmony import */ var color_rgba__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(color_rgba__WEBPACK_IMPORTED_MODULE_0__);
__webpack_require__(1).glMatrix.setMatrixArrayType(Array);


function parseColor(colorStr) {
  var ret = color_rgba__WEBPACK_IMPORTED_MODULE_0___default()(colorStr);
  if (!ret || !ret.length) throw new TypeError('Invalid color value.');
  return [ret[0] / 255, ret[1] / 255, ret[2] / 255, ret[3]];
}

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @module  color-rgba */



var parse = __webpack_require__(49)
var hsl = __webpack_require__(53)
var clamp = __webpack_require__(55)

module.exports = function rgba (color) {
	var values, i, l

	//attempt to parse non-array arguments
	var parsed = parse(color)

	if (!parsed.space) return []

	values = Array(3)
	values[0] = clamp(parsed.values[0], 0, 255)
	values[1] = clamp(parsed.values[1], 0, 255)
	values[2] = clamp(parsed.values[2], 0, 255)

	if (parsed.space[0] === 'h') {
		values = hsl.rgb(values)
	}

	values.push(clamp(parsed.alpha, 0, 1))

	return values
}


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**
 * @module color-parse
 */



var names = __webpack_require__(50)
var isObject = __webpack_require__(51)
var defined = __webpack_require__(52)

module.exports = parse

/**
 * Base hues
 * http://dev.w3.org/csswg/css-color/#typedef-named-hue
 */
//FIXME: use external hue detector
var baseHues = {
	red: 0,
	orange: 60,
	yellow: 120,
	green: 180,
	blue: 240,
	purple: 300
}

/**
 * Parse color from the string passed
 *
 * @return {Object} A space indicator `space`, an array `values` and `alpha`
 */
function parse (cstr) {
	var m, parts = [], alpha = 1, space

	if (typeof cstr === 'string') {
		//keyword
		if (names[cstr]) {
			parts = names[cstr].slice()
			space = 'rgb'
		}

		//reserved words
		else if (cstr === 'transparent') {
			alpha = 0
			space = 'rgb'
			parts = [0,0,0]
		}

		//hex
		else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
			var base = cstr.slice(1)
			var size = base.length
			var isShort = size <= 4
			alpha = 1

			if (isShort) {
				parts = [
					parseInt(base[0] + base[0], 16),
					parseInt(base[1] + base[1], 16),
					parseInt(base[2] + base[2], 16)
				]
				if (size === 4) {
					alpha = parseInt(base[3] + base[3], 16) / 255
				}
			}
			else {
				parts = [
					parseInt(base[0] + base[1], 16),
					parseInt(base[2] + base[3], 16),
					parseInt(base[4] + base[5], 16)
				]
				if (size === 8) {
					alpha = parseInt(base[6] + base[7], 16) / 255
				}
			}

			if (!parts[0]) parts[0] = 0
			if (!parts[1]) parts[1] = 0
			if (!parts[2]) parts[2] = 0

			space = 'rgb'
		}

		//color space
		else if (m = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
			var name = m[1]
			var isRGB = name === 'rgb'
			var base = name.replace(/a$/, '')
			space = base
			var size = base === 'cmyk' ? 4 : base === 'gray' ? 1 : 3
			parts = m[2].trim()
				.split(/\s*,\s*/)
				.map(function (x, i) {
					//<percentage>
					if (/%$/.test(x)) {
						//alpha
						if (i === size)	return parseFloat(x) / 100
						//rgb
						if (base === 'rgb') return parseFloat(x) * 255 / 100
						return parseFloat(x)
					}
					//hue
					else if (base[i] === 'h') {
						//<deg>
						if (/deg$/.test(x)) {
							return parseFloat(x)
						}
						//<base-hue>
						else if (baseHues[x] !== undefined) {
							return baseHues[x]
						}
					}
					return parseFloat(x)
				})

			if (name === base) parts.push(1)
			alpha = (isRGB) ? 1 : (parts[size] === undefined) ? 1 : parts[size]
			parts = parts.slice(0, size)
		}

		//named channels case
		else if (cstr.length > 10 && /[0-9](?:\s|\/)/.test(cstr)) {
			parts = cstr.match(/([0-9]+)/g).map(function (value) {
				return parseFloat(value)
			})

			space = cstr.match(/([a-z])/ig).join('').toLowerCase()
		}
	}

	//numeric case
	else if (!isNaN(cstr)) {
		space = 'rgb'
		parts = [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff]
	}

	//object case - detects css cases of rgb and hsl
	else if (isObject(cstr)) {
		var r = defined(cstr.r, cstr.red, cstr.R, null)

		if (r !== null) {
			space = 'rgb'
			parts = [
				r,
				defined(cstr.g, cstr.green, cstr.G),
				defined(cstr.b, cstr.blue, cstr.B)
			]
		}
		else {
			space = 'hsl'
			parts = [
				defined(cstr.h, cstr.hue, cstr.H),
				defined(cstr.s, cstr.saturation, cstr.S),
				defined(cstr.l, cstr.lightness, cstr.L, cstr.b, cstr.brightness)
			]
		}

		alpha = defined(cstr.a, cstr.alpha, cstr.opacity, 1)

		if (cstr.opacity != null) alpha /= 100
	}

	//array
	else if (Array.isArray(cstr) || global.ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(cstr)) {
		parts = [cstr[0], cstr[1], cstr[2]]
		space = 'rgb'
		alpha = cstr.length === 4 ? cstr[3] : 1
	}

	return {
		space: space,
		values: parts,
		alpha: alpha
	}
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(38)))

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toString = Object.prototype.toString;

module.exports = function (x) {
	var prototype;
	return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
};


/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = function () {
    for (var i = 0; i < arguments.length; i++) {
        if (arguments[i] !== undefined) return arguments[i];
    }
};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @module color-space/hsl
 */


var rgb = __webpack_require__(54);

module.exports = {
	name: 'hsl',
	min: [0,0,0],
	max: [360,100,100],
	channel: ['hue', 'saturation', 'lightness'],
	alias: ['HSL'],

	rgb: function(hsl) {
		var h = hsl[0] / 360,
				s = hsl[1] / 100,
				l = hsl[2] / 100,
				t1, t2, t3, rgb, val;

		if (s === 0) {
			val = l * 255;
			return [val, val, val];
		}

		if (l < 0.5) {
			t2 = l * (1 + s);
		}
		else {
			t2 = l + s - l * s;
		}
		t1 = 2 * l - t2;

		rgb = [0, 0, 0];
		for (var i = 0; i < 3; i++) {
			t3 = h + 1 / 3 * - (i - 1);
			if (t3 < 0) {
				t3++;
			}
			else if (t3 > 1) {
				t3--;
			}

			if (6 * t3 < 1) {
				val = t1 + (t2 - t1) * 6 * t3;
			}
			else if (2 * t3 < 1) {
				val = t2;
			}
			else if (3 * t3 < 2) {
				val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
			}
			else {
				val = t1;
			}

			rgb[i] = val * 255;
		}

		return rgb;
	}
};


//extend rgb
rgb.hsl = function(rgb) {
	var r = rgb[0]/255,
			g = rgb[1]/255,
			b = rgb[2]/255,
			min = Math.min(r, g, b),
			max = Math.max(r, g, b),
			delta = max - min,
			h, s, l;

	if (max === min) {
		h = 0;
	}
	else if (r === max) {
		h = (g - b) / delta;
	}
	else if (g === max) {
		h = 2 + (b - r) / delta;
	}
	else if (b === max) {
		h = 4 + (r - g)/ delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	}
	else if (l <= 0.5) {
		s = delta / (max + min);
	}
	else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * RGB space.
 *
 * @module  color-space/rgb
 */


module.exports = {
	name: 'rgb',
	min: [0,0,0],
	max: [255,255,255],
	channel: ['red', 'green', 'blue'],
	alias: ['RGB']
};


/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = clamp

function clamp(value, min, max) {
  return min < max
    ? (value < min ? min : value > max ? max : value)
    : (value < max ? max : value > min ? min : value)
}


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Figure2D; });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_toArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);
/* harmony import */ var _babel_runtime_helpers_toArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toArray__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var parse_svg_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58);
/* harmony import */ var parse_svg_path__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(parse_svg_path__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var bound_points__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(59);
/* harmony import */ var bound_points__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(bound_points__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var abs_svg_path__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(60);
/* harmony import */ var abs_svg_path__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(abs_svg_path__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _normalize_svg_path__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(61);
/* harmony import */ var _svg_path_contours__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(63);
/* harmony import */ var _svg_path_contours__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_svg_path_contours__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _utils_contours__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(70);
/* harmony import */ var _utils_ellipse__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(72);





__webpack_require__(1).glMatrix.setMatrixArrayType(Array);









var _contours = Symbol('contours');

var _path = Symbol('path');

var _simplify = Symbol('simplify');

var _scale = Symbol('scale');

var PI2 = 2 * Math.PI;

var Figure2D = /*#__PURE__*/function () {
  function Figure2D() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default()(this, Figure2D);

    if (typeof options === 'string') options = {
      path: options
    };
    if (options.path) this[_path] = parse_svg_path__WEBPACK_IMPORTED_MODULE_4___default()(options.path);else this[_path] = [];
    this[_contours] = null;
    this[_simplify] = options.simplify != null ? options.simplify : 0;
    this[_scale] = options.scale != null ? options.scale : 2;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default()(Figure2D, [{
    key: "normalize",
    value: function normalize() {
      var _this$_path;

      var x0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var path = Object(_normalize_svg_path__WEBPACK_IMPORTED_MODULE_7__["default"])(abs_svg_path__WEBPACK_IMPORTED_MODULE_6___default()(this[_path])).map(function (_ref) {
        var _ref2 = _babel_runtime_helpers_toArray__WEBPACK_IMPORTED_MODULE_1___default()(_ref),
            cmd = _ref2[0],
            args = _ref2.slice(1);

        var transformed = [cmd];

        for (var i = 0; i < args.length; i += 2) {
          var x = args[i] - x0,
              y = args[i + 1] - y0;
          transformed.push(x, y);
        }

        return transformed;
      });

      this.beginPath();

      (_this$_path = this[_path]).push.apply(_this$_path, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(path));

      return this;
    }
  }, {
    key: "getPointAtLength",
    value: function getPointAtLength(length) {
      if (this.contours) {
        return Object(_utils_contours__WEBPACK_IMPORTED_MODULE_9__["getPointAtLength"])(this[_contours], length);
      }

      return null;
    }
  }, {
    key: "getTotalLength",
    value: function getTotalLength() {
      if (this.contours) {
        return Object(_utils_contours__WEBPACK_IMPORTED_MODULE_9__["getTotalLength"])(this[_contours]);
      }

      return 0;
    }
  }, {
    key: "addPath",
    value: function addPath(path) {
      var _this$_path2;

      this[_contours] = null;
      if (typeof path === 'string') path = parse_svg_path__WEBPACK_IMPORTED_MODULE_4___default()(path);

      (_this$_path2 = this[_path]).push.apply(_this$_path2, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(path));
    }
  }, {
    key: "beginPath",
    value: function beginPath() {
      this[_path] = [];
      this[_contours] = null;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.beginPath();
    }
  }, {
    key: "ellipse",
    value: function ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle) {
      var anticlockwise = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      startAngle += rotation;
      endAngle += rotation;
      if (radiusX <= 0 || radiusY <= 0 || endAngle === startAngle) return;

      if (endAngle < startAngle) {
        endAngle = startAngle + PI2 + (endAngle - startAngle) % PI2;
      }

      if (endAngle - startAngle > PI2) {
        endAngle = startAngle + PI2;
      }

      var delta = endAngle - startAngle;

      if (delta >= PI2) {
        endAngle -= 1e-3;
      }

      var path = this[_path].length > 0 && delta < PI2 ? 'L' : 'M';
      var startPoint = Object(_utils_ellipse__WEBPACK_IMPORTED_MODULE_10__["getPoint"])(x, y, radiusX, radiusY, startAngle);
      var endPoint = Object(_utils_ellipse__WEBPACK_IMPORTED_MODULE_10__["getPoint"])(x, y, radiusX, radiusY, endAngle);
      var sweepFlag = Number(!anticlockwise);
      var largeArcFlag = delta > Math.PI ? 1 : 0;
      if (anticlockwise) largeArcFlag = 1 - largeArcFlag;
      path += startPoint.join(' ');
      path += "A".concat(radiusX, " ").concat(radiusY, " 0 ").concat(largeArcFlag, " ").concat(sweepFlag, " ").concat(endPoint.join(' '));

      if (delta >= PI2) {
        path += 'Z';
      }

      this.addPath(path);
    }
  }, {
    key: "arc",
    value: function arc(x, y, radius, startAngle, endAngle) {
      var anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      return this.ellipse(x, y, radius, radius, 0, startAngle, endAngle, anticlockwise);
    }
  }, {
    key: "arcTo",
    value: function arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
      this[_contours] = null;

      this[_path].push(['A', rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y]);
    }
  }, {
    key: "moveTo",
    value: function moveTo(x, y) {
      this[_contours] = null;

      this[_path].push(['M', x, y]);
    }
  }, {
    key: "lineTo",
    value: function lineTo(x, y) {
      this[_contours] = null;

      this[_path].push(['L', x, y]);
    }
  }, {
    key: "bezierCurveTo",
    value: function bezierCurveTo(x1, y1, x2, y2, x, y) {
      this[_contours] = null;

      this[_path].push(['C', x1, y1, x2, y2, x, y]);
    }
  }, {
    key: "quadraticCurveTo",
    value: function quadraticCurveTo(x1, y1, x, y) {
      this[_contours] = null;

      this[_path].push(['Q', x1, y1, x, y]);
    }
  }, {
    key: "rect",
    value: function rect(x, y, width, height) {
      var path = "M".concat(x, " ").concat(y, "L").concat(x + width, " ").concat(y, "L").concat(x + width, " ").concat(y + height, "L").concat(x, " ").concat(y + height, "Z");
      this.addPath(path);
    }
  }, {
    key: "closePath",
    value: function closePath() {
      this[_contours] = null;
      var lastPath = [];
      var len = this[_path].length;

      if (len > 0) {
        lastPath = this[_path][len - 1];
      }

      if (lastPath[0] !== 'Z' && lastPath[0] !== 'z') {
        this[_path].push(['Z']);
      }
    }
  }, {
    key: "contours",
    get: function get() {
      var ret = null;

      if (!this[_contours] && this[_path]) {
        var path = Object(_normalize_svg_path__WEBPACK_IMPORTED_MODULE_7__["default"])(abs_svg_path__WEBPACK_IMPORTED_MODULE_6___default()(this[_path]));

        this[_contours] = _svg_path_contours__WEBPACK_IMPORTED_MODULE_8___default()(path, this[_scale], this[_simplify]);
        this[_contours].path = path;
        this[_contours].simplify = this[_simplify];
        this[_contours].scale = this[_scale];
      }

      if (this[_contours]) {
        ret = this[_contours].map(function (c) {
          return _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(c);
        });
        ret.path = this[_contours].path;
        ret.simplify = this[_contours].simplify;
        ret.scale = this[_contours].scale;
      }

      return ret;
    }
  }, {
    key: "path",
    get: function get() {
      return this[_path];
    }
  }, {
    key: "simplify",
    get: function get() {
      return this[_simplify];
    }
  }, {
    key: "boundingBox",
    get: function get() {
      var contours = this.contours;

      if (contours && contours.length) {
        var points = contours.reduce(function (a, b) {
          return [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(a), _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(b));
        });
        return bound_points__WEBPACK_IMPORTED_MODULE_5___default()(points);
      }

      return [[0, 0], [0, 0]];
    }
  }, {
    key: "boundingCenter",
    get: function get() {
      var bound = this.boundingBox;

      if (bound) {
        return [0.5 * (bound[0][0] + bound[1][0]), 0.5 * (bound[0][1] + bound[1][1])];
      }

      return [0, 0];
    }
  }]);

  return Figure2D;
}();



/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(14);

var iterableToArray = __webpack_require__(21);

var unsupportedIterableToArray = __webpack_require__(16);

var nonIterableRest = __webpack_require__(18);

function _toArray(arr) {
  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();
}

module.exports = _toArray;

/***/ }),
/* 58 */
/***/ (function(module, exports) {


module.exports = parse

/**
 * expected argument lengths
 * @type {Object}
 */

var length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}

/**
 * segment pattern
 * @type {RegExp}
 */

var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig

/**
 * parse an svg path data string. Generates an Array
 * of commands where each command is an Array of the
 * form `[command, arg1, arg2, ...]`
 *
 * @param {String} path
 * @return {Array}
 */

function parse(path) {
	var data = []
	path.replace(segment, function(_, command, args){
		var type = command.toLowerCase()
		args = parseValues(args)

		// overloaded moveTo
		if (type == 'm' && args.length > 2) {
			data.push([command].concat(args.splice(0, 2)))
			type = 'l'
			command = command == 'm' ? 'l' : 'L'
		}

		while (true) {
			if (args.length == length[type]) {
				args.unshift(command)
				return data.push(args)
			}
			if (args.length < length[type]) throw new Error('malformed path data')
			data.push([command].concat(args.splice(0, length[type])))
		}
	})
	return data
}

var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig

function parseValues(args) {
	var numbers = args.match(number)
	return numbers ? numbers.map(Number) : []
}


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = findBounds

function findBounds(points) {
  var n = points.length
  if(n === 0) {
    return [[], []]
  }
  var d = points[0].length
  var lo = points[0].slice()
  var hi = points[0].slice()
  for(var i=1; i<n; ++i) {
    var p = points[i]
    for(var j=0; j<d; ++j) {
      var x = p[j]
      lo[j] = Math.min(lo[j], x)
      hi[j] = Math.max(hi[j], x)
    }
  }
  return [lo, hi]
}

/***/ }),
/* 60 */
/***/ (function(module, exports) {


module.exports = absolutize

/**
 * redefine `path` with absolute coordinates
 *
 * @param {Array} path
 * @return {Array}
 */

function absolutize(path){
	var startX = 0
	var startY = 0
	var x = 0
	var y = 0

	return path.map(function(seg){
		seg = seg.slice()
		var type = seg[0]
		var command = type.toUpperCase()

		// is relative
		if (type != command) {
			seg[0] = command
			switch (type) {
				case 'a':
					seg[6] += x
					seg[7] += y
					break
				case 'v':
					seg[1] += y
					break
				case 'h':
					seg[1] += x
					break
				default:
					for (var i = 1; i < seg.length;) {
						seg[i++] += x
						seg[i++] += y
					}
			}
		}

		// update cursor state
		switch (command) {
			case 'Z':
				x = startX
				y = startY
				break
			case 'H':
				x = seg[1]
				break
			case 'V':
				y = seg[1]
				break
			case 'M':
				x = startX = seg[1]
				y = startY = seg[2]
				break
			default:
				x = seg[seg.length - 2]
				y = seg[seg.length - 1]
		}

		return seg
	})
}


/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalize; });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _a2c__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62);


__webpack_require__(1).glMatrix.setMatrixArrayType(Array);

// https://github.com/jkroso/normalize-svg-path

/* eslint-disable */

function normalize(path) {
  // init state
  var prev;
  var result = [];
  var bezierX = 0;
  var bezierY = 0;
  var startX = 0;
  var startY = 0;
  var quadX = null;
  var quadY = null;
  var x = 0;
  var y = 0;

  for (var i = 0, len = path.length; i < len; i++) {
    var seg = path[i];
    var command = seg[0];

    switch (command) {
      case 'M':
        startX = seg[1];
        startY = seg[2];
        break;

      case 'A':
        var curves = Object(_a2c__WEBPACK_IMPORTED_MODULE_1__["default"])(x, y, seg[6], seg[7], seg[4], seg[5], seg[1], seg[2], seg[3]);
        if (!curves.length) continue;
        curves = curves.map(function (curve) {
          var _curve = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(curve, 8),
              x0 = _curve[0],
              y0 = _curve[1],
              x1 = _curve[2],
              y1 = _curve[3],
              x2 = _curve[4],
              y2 = _curve[5],
              x = _curve[6],
              y = _curve[7];

          return {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2,
            x: x,
            y: y
          };
        });

        for (var j = 0, c; j < curves.length; j++) {
          c = curves[j];
          seg = ['C', c.x1, c.y1, c.x2, c.y2, c.x, c.y];
          if (j < curves.length - 1) result.push(seg);
        }

        break;

      case 'S':
        // default control point
        var cx = x;
        var cy = y;

        if (prev == 'C' || prev == 'S') {
          cx += cx - bezierX; // reflect the previous command's control

          cy += cy - bezierY; // point relative to the current point
        }

        seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]];
        break;

      case 'T':
        if (prev == 'Q' || prev == 'T') {
          quadX = x * 2 - quadX; // as with 'S' reflect previous control point

          quadY = y * 2 - quadY;
        } else {
          quadX = x;
          quadY = y;
        }

        seg = quadratic(x, y, quadX, quadY, seg[1], seg[2]);
        break;

      case 'Q':
        quadX = seg[1];
        quadY = seg[2];
        seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4]);
        break;

      case 'L':
        seg = line(x, y, seg[1], seg[2]);
        break;

      case 'H':
        seg = line(x, y, seg[1], y);
        break;

      case 'V':
        seg = line(x, y, x, seg[1]);
        break;

      case 'Z':
        seg = line(x, y, startX, startY);
        break;
    } // update state


    prev = command;
    x = seg[seg.length - 2];
    y = seg[seg.length - 1];

    if (seg.length > 4) {
      bezierX = seg[seg.length - 4];
      bezierY = seg[seg.length - 3];
    } else {
      bezierX = x;
      bezierY = y;
    }

    result.push(seg);
  }

  return result;
}

function line(x1, y1, x2, y2) {
  return ['C', x1, y1, x2, y2, x2, y2];
}

function quadratic(x1, y1, cx, cy, x2, y2) {
  return ['C', x1 / 3 + 2 / 3 * cx, y1 / 3 + 2 / 3 * cy, x2 / 3 + 2 / 3 * cx, y2 / 3 + 2 / 3 * cy, x2, y2];
}
/* eslint-enable */

/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return a2c; });
__webpack_require__(1).glMatrix.setMatrixArrayType(Array);

// https://github.com/colinmeinke/svg-arc-to-cubic-bezier
//
// Convert an arc to a sequence of cubic bézier curves
//
var TAU = Math.PI * 2;
/* eslint-disable space-infix-ops */
// Calculate an angle between two unit vectors
//
// Since we measure angle between radii of circular arcs,
// we can use simplified math (without length normalization)
//

function unit_vector_angle(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
  var dot = ux * vx + uy * vy; // Add this to work with arbitrary vectors:
  // dot /= Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);
  // rounding errors, e.g. -1.0000000000000002 can screw up this

  if (dot > 1.0) {
    dot = 1.0;
  }

  if (dot < -1.0) {
    dot = -1.0;
  }

  return sign * Math.acos(dot);
} // Convert from endpoint to center parameterization,
// see http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
//
// Return [cx, cy, theta1, delta_theta]
//


function get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi) {
  // Step 1.
  //
  // Moving an ellipse so origin will be the middlepoint between our two
  // points. After that, rotate it to line up ellipse axes with coordinate
  // axes.
  //
  var x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
  var y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;
  var rx_sq = rx * rx;
  var ry_sq = ry * ry;
  var x1p_sq = x1p * x1p;
  var y1p_sq = y1p * y1p; // Step 2.
  //
  // Compute coordinates of the centre of this ellipse (cx', cy')
  // in the new coordinate system.
  //

  var radicant = rx_sq * ry_sq - rx_sq * y1p_sq - ry_sq * x1p_sq;

  if (radicant < 0) {
    // due to rounding errors it might be e.g. -1.3877787807814457e-17
    radicant = 0;
  }

  radicant /= rx_sq * y1p_sq + ry_sq * x1p_sq;
  radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);
  var cxp = radicant * rx / ry * y1p;
  var cyp = radicant * -ry / rx * x1p; // Step 3.
  //
  // Transform back to get centre coordinates (cx, cy) in the original
  // coordinate system.
  //

  var cx = cos_phi * cxp - sin_phi * cyp + (x1 + x2) / 2;
  var cy = sin_phi * cxp + cos_phi * cyp + (y1 + y2) / 2; // Step 4.
  //
  // Compute angles (theta1, delta_theta).
  //

  var v1x = (x1p - cxp) / rx;
  var v1y = (y1p - cyp) / ry;
  var v2x = (-x1p - cxp) / rx;
  var v2y = (-y1p - cyp) / ry;
  var theta1 = unit_vector_angle(1, 0, v1x, v1y);
  var delta_theta = unit_vector_angle(v1x, v1y, v2x, v2y);

  if (fs === 0 && delta_theta > 0) {
    delta_theta -= TAU;
  }

  if (fs === 1 && delta_theta < 0) {
    delta_theta += TAU;
  }

  return [cx, cy, theta1, delta_theta];
} //
// Approximate one unit arc segment with bézier curves,
// see http://math.stackexchange.com/questions/873224
//


function approximate_unit_arc(theta1, delta_theta) {
  var alpha = 4 / 3 * Math.tan(delta_theta / 4);
  var x1 = Math.cos(theta1);
  var y1 = Math.sin(theta1);
  var x2 = Math.cos(theta1 + delta_theta);
  var y2 = Math.sin(theta1 + delta_theta);
  return [x1, y1, x1 - y1 * alpha, y1 + x1 * alpha, x2 + y2 * alpha, y2 - x2 * alpha, x2, y2];
}

function a2c(x1, y1, x2, y2, fa, fs, rx, ry, phi) {
  var sin_phi = Math.sin(phi * TAU / 360);
  var cos_phi = Math.cos(phi * TAU / 360); // Make sure radii are valid
  //

  var x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
  var y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;

  if (x1p === 0 && y1p === 0) {
    // we're asked to draw line to itself
    return [];
  }

  if (rx === 0 || ry === 0) {
    // one of the radii is zero
    return [];
  } // Compensate out-of-range radii
  //


  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var lambda = x1p * x1p / (rx * rx) + y1p * y1p / (ry * ry);

  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  } // Get center parameters (cx, cy, theta1, delta_theta)
  //


  var cc = get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi);
  var result = [];
  var theta1 = cc[2];
  var delta_theta = cc[3]; // Split an arc to multiple segments, so each segment
  // will be less than τ/4 (= 90°)
  //

  var segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);
  delta_theta /= segments;

  for (var i = 0; i < segments; i++) {
    result.push(approximate_unit_arc(theta1, delta_theta));
    theta1 += delta_theta;
  } // We have a bezier approximation of a unit circle,
  // now need to transform back to the original ellipse
  //


  return result.map(function (curve) {
    for (var _i = 0; _i < curve.length; _i += 2) {
      var x = curve[_i + 0];
      var y = curve[_i + 1]; // scale

      x *= rx;
      y *= ry; // rotate

      var xp = cos_phi * x - sin_phi * y;
      var yp = sin_phi * x + cos_phi * y; // translate

      curve[_i + 0] = xp + cc[0];
      curve[_i + 1] = yp + cc[1];
    }

    return curve;
  });
}

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(1).glMatrix.setMatrixArrayType(Array);

// https://github.com/mattdesl/svg-path-contours

/* eslint-disable */
var bezier = __webpack_require__(64);

var _require = __webpack_require__(66),
    copy = _require.copy;

var simplify = __webpack_require__(67);

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

var tmp1 = [0, 0],
    tmp2 = [0, 0],
    tmp3 = [0, 0];

function bezierTo(points, scale, start, seg) {
  bezier(start, set(tmp1, seg[1], seg[2]), set(tmp2, seg[3], seg[4]), set(tmp3, seg[5], seg[6]), scale, points);
}

module.exports = function contours(svg, scale, simp) {
  var paths = [];
  var points = [];
  var pen = [0, 0];
  svg.forEach(function (segment, i, self) {
    if (segment[0] === 'M') {
      copy(pen, segment.slice(1));

      if (points.length > 0) {
        paths.push(points);
        points = [];
      }
    } else if (segment[0] === 'C') {
      bezierTo(points, scale, pen, segment);
      set(pen, segment[5], segment[6]);
    } else {
      throw new Error('illegal type in SVG: ' + segment[0]);
    }
  });
  if (points.length > 0) paths.push(points);
  return paths.map(function (points) {
    return simplify(points, simp || 0);
  });
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(65)()

/***/ }),
/* 65 */
/***/ (function(module, exports) {

function clone(point) { //TODO: use gl-vec2 for this
    return [point[0], point[1]]
}

function vec2(x, y) {
    return [x, y]
}

module.exports = function createBezierBuilder(opt) {
    opt = opt||{}

    var RECURSION_LIMIT = typeof opt.recursion === 'number' ? opt.recursion : 8
    var FLT_EPSILON = typeof opt.epsilon === 'number' ? opt.epsilon : 1.19209290e-7
    var PATH_DISTANCE_EPSILON = typeof opt.pathEpsilon === 'number' ? opt.pathEpsilon : 1.0

    var curve_angle_tolerance_epsilon = typeof opt.angleEpsilon === 'number' ? opt.angleEpsilon : 0.01
    var m_angle_tolerance = opt.angleTolerance || 0
    var m_cusp_limit = opt.cuspLimit || 0

    return function bezierCurve(start, c1, c2, end, scale, points) {
        if (!points)
            points = []

        scale = typeof scale === 'number' ? scale : 1.0
        var distanceTolerance = PATH_DISTANCE_EPSILON / scale
        distanceTolerance *= distanceTolerance
        begin(start, c1, c2, end, points, distanceTolerance)
        return points
    }


    ////// Based on:
    ////// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp

    function begin(start, c1, c2, end, points, distanceTolerance) {
        points.push(clone(start))
        var x1 = start[0],
            y1 = start[1],
            x2 = c1[0],
            y2 = c1[1],
            x3 = c2[0],
            y3 = c2[1],
            x4 = end[0],
            y4 = end[1]
        recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, 0)
        points.push(clone(end))
    }

    function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
        if(level > RECURSION_LIMIT) 
            return

        var pi = Math.PI

        // Calculate all the mid-points of the line segments
        //----------------------
        var x12   = (x1 + x2) / 2
        var y12   = (y1 + y2) / 2
        var x23   = (x2 + x3) / 2
        var y23   = (y2 + y3) / 2
        var x34   = (x3 + x4) / 2
        var y34   = (y3 + y4) / 2
        var x123  = (x12 + x23) / 2
        var y123  = (y12 + y23) / 2
        var x234  = (x23 + x34) / 2
        var y234  = (y23 + y34) / 2
        var x1234 = (x123 + x234) / 2
        var y1234 = (y123 + y234) / 2

        if(level > 0) { // Enforce subdivision first time
            // Try to approximate the full cubic curve by a single straight line
            //------------------
            var dx = x4-x1
            var dy = y4-y1

            var d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx)
            var d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx)

            var da1, da2

            if(d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
                // Regular care
                //-----------------
                if((d2 + d3)*(d2 + d3) <= distanceTolerance * (dx*dx + dy*dy)) {
                    // If the curvature doesn't exceed the distanceTolerance value
                    // we tend to finish subdivisions.
                    //----------------------
                    if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                        points.push(vec2(x1234, y1234))
                        return
                    }

                    // Angle & Cusp Condition
                    //----------------------
                    var a23 = Math.atan2(y3 - y2, x3 - x2)
                    da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1))
                    da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23)
                    if(da1 >= pi) da1 = 2*pi - da1
                    if(da2 >= pi) da2 = 2*pi - da2

                    if(da1 + da2 < m_angle_tolerance) {
                        // Finally we can stop the recursion
                        //----------------------
                        points.push(vec2(x1234, y1234))
                        return
                    }

                    if(m_cusp_limit !== 0.0) {
                        if(da1 > m_cusp_limit) {
                            points.push(vec2(x2, y2))
                            return
                        }

                        if(da2 > m_cusp_limit) {
                            points.push(vec2(x3, y3))
                            return
                        }
                    }
                }
            }
            else {
                if(d2 > FLT_EPSILON) {
                    // p1,p3,p4 are collinear, p2 is considerable
                    //----------------------
                    if(d2 * d2 <= distanceTolerance * (dx*dx + dy*dy)) {
                        if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                            points.push(vec2(x1234, y1234))
                            return
                        }

                        // Angle Condition
                        //----------------------
                        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1))
                        if(da1 >= pi) da1 = 2*pi - da1

                        if(da1 < m_angle_tolerance) {
                            points.push(vec2(x2, y2))
                            points.push(vec2(x3, y3))
                            return
                        }

                        if(m_cusp_limit !== 0.0) {
                            if(da1 > m_cusp_limit) {
                                points.push(vec2(x2, y2))
                                return
                            }
                        }
                    }
                }
                else if(d3 > FLT_EPSILON) {
                    // p1,p2,p4 are collinear, p3 is considerable
                    //----------------------
                    if(d3 * d3 <= distanceTolerance * (dx*dx + dy*dy)) {
                        if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                            points.push(vec2(x1234, y1234))
                            return
                        }

                        // Angle Condition
                        //----------------------
                        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2))
                        if(da1 >= pi) da1 = 2*pi - da1

                        if(da1 < m_angle_tolerance) {
                            points.push(vec2(x2, y2))
                            points.push(vec2(x3, y3))
                            return
                        }

                        if(m_cusp_limit !== 0.0) {
                            if(da1 > m_cusp_limit)
                            {
                                points.push(vec2(x3, y3))
                                return
                            }
                        }
                    }
                }
                else {
                    // Collinear case
                    //-----------------
                    dx = x1234 - (x1 + x4) / 2
                    dy = y1234 - (y1 + y4) / 2
                    if(dx*dx + dy*dy <= distanceTolerance) {
                        points.push(vec2(x1234, y1234))
                        return
                    }
                }
            }
        }

        // Continue subdivision
        //----------------------
        recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1) 
        recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1) 
    }
}


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeMiter", function() { return computeMiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normal", function() { return normal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "direction", function() { return direction; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
__webpack_require__(1).glMatrix.setMatrixArrayType(Array);



function clone(arr) {
  return [arr[0], arr[1]];
}

function create() {
  return [0, 0];
}

var copy = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].copy;
var scaleAndAdd = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].scaleAndAdd;
var dot = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].dot;
var rotate = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].rotate;
var cross = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].cross;
var sub = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].sub;
var add = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].add;
var normalize = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].normalize;
var set = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].set;
var tmp = create();

function computeMiter(tangent, miter, lineA, lineB, halfThick) {
  // get tangent line
  add(tangent, lineA, lineB);
  normalize(tangent, tangent); // get miter as a unit vector

  set(miter, -tangent[1], tangent[0]);
  set(tmp, -lineA[1], lineA[0]); // get the necessary length of our miter

  var miterLen = halfThick / dot(miter, tmp);
  return Math.abs(miterLen); // avoid -Infinity
}

function normal(out, dir) {
  // get perpendicular
  set(out, -dir[1], dir[0]);
  return out;
}

function direction(out, a, b) {
  // get unit dir of two lines
  sub(out, a, b);
  normalize(out, out);
  return out;
}



/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var simplifyRadialDist = __webpack_require__(68)
var simplifyDouglasPeucker = __webpack_require__(69)

//simplifies using both algorithms
module.exports = function simplify(points, tolerance) {
    points = simplifyRadialDist(points, tolerance);
    points = simplifyDouglasPeucker(points, tolerance);
    return points;
}

module.exports.radialDistance = simplifyRadialDist;
module.exports.douglasPeucker = simplifyDouglasPeucker;

/***/ }),
/* 68 */
/***/ (function(module, exports) {

function getSqDist(p1, p2) {
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// basic distance-based simplification
module.exports = function simplifyRadialDist(points, tolerance) {
    if (points.length<=1)
        return points;
    tolerance = typeof tolerance === 'number' ? tolerance : 1;
    var sqTolerance = tolerance * tolerance;
    
    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

/***/ }),
/* 69 */
/***/ (function(module, exports) {

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance,
        index;

    for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }

    if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
}

// simplification using Ramer-Douglas-Peucker algorithm
module.exports = function simplifyDouglasPeucker(points, tolerance) {
    if (points.length<=1)
        return points;
    tolerance = typeof tolerance === 'number' ? tolerance : 1;
    var sqTolerance = tolerance * tolerance;
    
    var last = points.length - 1;

    var simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTotalLength", function() { return getTotalLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPointAtLength", function() { return getPointAtLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDashContours", function() { return getDashContours; });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _positions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71);


__webpack_require__(1).glMatrix.setMatrixArrayType(Array);


function getTotalLength(contours) {
  if (contours.totalLength != null) return contours.totalLength;
  var length = 0;
  contours.forEach(function (points) {
    var s = points[0];

    for (var i = 1; i < points.length; i++) {
      var p = points[i];
      length += Object(_positions__WEBPACK_IMPORTED_MODULE_1__["distance"])(s, p);
      s = p;
    }
  });
  contours.totalLength = length;
  return length;
}

function splitContours(contours, length) {
  var rest = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  length = Number(length);

  if (!Number.isFinite(length)) {
    throw new TypeError('Failed to execute \'getPointAtLength\' on figure: The provided float value is non-finite.');
  }

  if (length <= 0) {
    throw new TypeError('Length must > 0');
  }

  var contoursLength = getTotalLength(contours);

  if (length >= contoursLength) {
    var points = contours[contours.length - 1];
    var p0 = points[points.length - 2];
    var p1 = points[points.length - 1];
    var angle = Math.atan2(p1[1] - p0[1], p1[0] - p0[0]);
    return {
      current: contours.map(function (c) {
        return _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(c);
      }),
      point: {
        x: p1[0],
        y: p1[1],
        angle: angle
      }
    };
  }

  var current = [];

  for (var i = 0; i < contours.length; i++) {
    current[i] = [];
    var _points = contours[i];
    var _p = _points[0];

    for (var j = 1; j < _points.length; j++) {
      var _p2 = _points[j];
      var d = Object(_positions__WEBPACK_IMPORTED_MODULE_1__["distance"])(_p, _p2);

      if (length < d) {
        var p = length / d;

        var _angle = Math.atan2(_p2[1] - _p[1], _p2[0] - _p[0]);

        var point = {
          x: _p[0] * (1 - p) + _p2[0] * p,
          y: _p[1] * (1 - p) + _p2[1] * p,
          angle: _angle
        };
        current[i].push(_p);
        if (length > 0) current[i].push([point.x, point.y]);

        if (!rest) {
          return {
            current: current,
            point: point
          };
        }

        var restContours = [];
        var o = i;

        for (; i < contours.length; i++) {
          restContours[i - o] = [];
          if (i === o) restContours[0].push([point.x, point.y]);

          for (; j < _points.length; j++) {
            restContours[i - o].push(_points[j]);
          }

          j = 0;
        }

        return {
          current: current,
          point: point,
          rest: restContours
        };
      }

      length -= d;
      current[i].push(_p);
      _p = _p2;
    }
  }
}

function getPointAtLength(contours, length) {
  length = Number(length);

  if (!Number.isFinite(length)) {
    throw new TypeError('Failed to execute \'getPointAtLength\' on figure: The provided float value is non-finite.');
  }

  if (contours.length <= 0) return {
    x: 0,
    y: 0,
    angle: 0
  };

  if (length <= 0) {
    var p0 = contours[0][0];
    var p1 = contours[0][1];
    var angle = Math.atan2(p1[1] - p0[1], p1[0] - p0[0]);
    return {
      x: p0[0],
      y: p0[1],
      angle: angle
    };
  }

  return splitContours(contours, length, false).point;
}
function getDashContours(contours, lineDash, lineDashOffset) {
  var idx = 0;
  var dash = lineDash[0];
  var rest = contours;
  var splitedContours = [];
  var lineDashLen = lineDash.length;

  if (lineDashOffset > 0) {
    do {
      lineDashOffset -= lineDash[idx % lineDashLen];
      idx++;
    } while (lineDashOffset > 0);

    if (lineDashOffset < 0) {
      dash = -lineDashOffset;
      idx--;
    }
  } else if (lineDashOffset < 0) {
    idx = -1;

    do {
      lineDashOffset += lineDash[idx % lineDashLen + lineDashLen - 1];
      idx--;
    } while (lineDashOffset < 0);

    if (lineDashOffset >= 0) {
      idx++;
      dash = lineDash[idx % lineDashLen + lineDashLen - 1] - lineDashOffset;
    }
  }

  do {
    var splited = splitContours(rest, dash);
    rest = splited.rest;
    if (++idx % 2) splitedContours.push.apply(splitedContours, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(splited.current));
    var dashIndex = idx % lineDashLen;
    if (dashIndex < 0) dashIndex += lineDashLen;
    dash = lineDash[dashIndex];
  } while (rest);

  return splitedContours;
}

/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);


__webpack_require__(1).glMatrix.setMatrixArrayType(Array);

function normalize(_ref, w, h, d) {
  var _ref2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref, 3),
      x = _ref2[0],
      y = _ref2[1],
      z = _ref2[2];

  x = x * 2 / w - 1;
  y = 1 - y * 2 / h;

  if (Number.isFinite(d)) {
    z = z * 2 / d - 1;
    return [x, y, z];
  }

  return [x, y];
}
function distance(_ref3, _ref4) {
  var _ref5 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref3, 3),
      x1 = _ref5[0],
      y1 = _ref5[1],
      _ref5$ = _ref5[2],
      z1 = _ref5$ === void 0 ? 0 : _ref5$;

  var _ref6 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref4, 3),
      x2 = _ref6[0],
      y2 = _ref6[1],
      _ref6$ = _ref6[2],
      z2 = _ref6$ === void 0 ? 0 : _ref6$;

  return Math.hypot(x2 - x1, y2 - y1, z2 - z1);
}

/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPoint", function() { return getPoint; });
__webpack_require__(1).glMatrix.setMatrixArrayType(Array);

// 根据椭圆旋转角度求椭圆上的点
var PI2 = Math.PI * 2;
function getPoint(x0, y0, a, b, theta) {
  theta %= PI2;
  if (theta < 0) theta += PI2;
  var k = Math.tan(theta);

  if (Math.abs(k) < 1e5) {
    // y - y0 = k (x - x0)
    // y = k x + (y0 - k x0)
    // (x - x0) ** 2 / a ** 2 + (y - y0) ** 2 / b ** 2 = 1
    var c = y0 - k * x0;
    var t = 1 / Math.pow(a, 2) + Math.pow(k, 2) / Math.pow(b, 2);
    var d = -1;
    if (theta <= Math.PI / 2 || theta > 3 * Math.PI / 2) d = 1;
    var x = d * Math.sqrt(1 / t) + x0;
    var y = k * x + c;
    return [x, y];
  }

  if (theta < Math.PI) {
    return [x0, y0 + b];
  }

  return [x0, y0 - b];
}

/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Mesh2D; });
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74);
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(13);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1);
/* harmony import */ var bound_points__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(59);
/* harmony import */ var bound_points__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(bound_points__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _extrude_contours__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(76);
/* harmony import */ var _utils_flatten_meshes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(44);
/* harmony import */ var _utils_vector_to_rgba__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(40);
/* harmony import */ var _utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(46);
/* harmony import */ var _utils_transform__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(78);
/* harmony import */ var _utils_contours__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(70);
/* harmony import */ var _triangulate_contours__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(79);
/* harmony import */ var _triangulate_contours__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_triangulate_contours__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _svg_path_contours__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(63);
/* harmony import */ var _svg_path_contours__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_svg_path_contours__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _utils_parse_color__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(47);
/* harmony import */ var _figure2d__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(56);
/* harmony import */ var _utils_env__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(37);






__webpack_require__(1).glMatrix.setMatrixArrayType(Array);















var _mesh = Symbol('mesh');

var _contours = Symbol('contours');

var _stroke = Symbol('stroke');

var _fill = Symbol('fill');

var _strokeColor = Symbol('strokeColor');

var _fillColor = Symbol('fillColor');

var _transform = Symbol('transform');

var _invertTransform = Symbol('invertTransform');

var _uniforms = Symbol('uniforms');

var _texOptions = Symbol('texOptions');

var _blend = Symbol('blend');

var _applyTexture = Symbol('applyTexture');

var _applyTransform = Symbol('applyTransform');

var _applyGradientTransform = Symbol('applyGradientTransform');

var _applyProgram = Symbol('applyProgram');

var _gradient = Symbol('gradient');

var _filter = Symbol('filter');

var _opacity = Symbol('opacity');

var _program = Symbol('program');

var _attributes = Symbol('attributes');

var _pass = Symbol('pass');

var _clipContext = Symbol('clipContext');

var _applyClipPath = Symbol('applyClipPath'); // function normalizePoints(points, bound) {
//   const [w, h] = bound[1];
//   for(let i = 0; i < points.length; i++) {
//     const point = points[i];
//     point[0] = 2 * point[0] / w - 1;
//     point[1] = 1 - 2 * point[1] / h;
//   }
// }


function generateUV(bounds, positions) {
  var w = bounds[1][0] - bounds[0][0],
      h = bounds[1][1] - bounds[0][1];
  var ret = [];

  for (var j = 0; j < positions.length; j++) {
    var p = positions[j];
    var uv = [(p[0] - bounds[0][0]) / w, 1 - (p[1] - bounds[0][1]) / h];
    ret.push(uv);
  }

  return ret;
}

function getTexCoord(_ref, _ref2, _ref3) {
  var _ref4 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref, 2),
      x = _ref4[0],
      y = _ref4[1];

  var _ref5 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref2, 4),
      ox = _ref5[0],
      oy = _ref5[1],
      w = _ref5[2],
      h = _ref5[3];

  var scale = _ref3.scale;

  if (!scale) {
    x /= w;
    y = 1 - y / h;
    x -= ox;
    y += oy;
  }

  return [x, y, 0];
}

function _accurate(path, scale, simplify) {
  var contours = _svg_path_contours__WEBPACK_IMPORTED_MODULE_14___default()(path, scale, simplify);
  contours.path = path;
  contours.simplify = simplify;
  contours.scale = scale;
  return contours;
}

var Mesh2D = /*#__PURE__*/function () {
  function Mesh2D(figure) {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default()(this, Mesh2D);

    this[_stroke] = null;
    this[_fill] = null;
    this[_transform] = [1, 0, 0, 1, 0, 0];
    this[_opacity] = 1.0;
    this[_uniforms] = {};
    this[_filter] = [];
    this[_blend] = null;
    this[_texOptions] = {};
    this.contours = figure.contours;
    this[_program] = null;
    this[_attributes] = {};
    this[_pass] = [];
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default()(Mesh2D, [{
    key: "setProgram",
    value: function setProgram(program) {
      this[_program] = program;

      if (this[_mesh]) {
        this[_applyProgram](program);
      }
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(key, setter) {
      if (setter == null) {
        delete this[_attributes][key];
      } else {
        this[_attributes][key] = setter;
      }
    }
  }, {
    key: "getOpacity",
    value: function getOpacity() {
      return this[_opacity];
    }
  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      if (value < 0 || value > 1.0) throw new TypeError('Invalid opacity value.');

      if (this[_mesh]) {
        this[_mesh].positions.forEach(function (p) {
          p[2] = 1 / p[2] > 0 ? value : -value;
        });
      }

      this[_opacity] = value;
    }
  }, {
    key: "setClipPath",
    value: function setClipPath(path) {
      this.clipPath = path;

      if (this[_uniforms].u_clipSampler) {
        this[_uniforms].u_clipSampler.delete();
      }

      this.setUniforms({
        u_clipSampler: null
      });

      if (this[_mesh]) {
        delete this[_mesh].attributes.a_clipUV;
      }

      if (path && this[_mesh]) {
        this[_applyClipPath]();
      }
    }
  }, {
    key: _applyClipPath,
    value: function value() {
      if (this.clipPath) {
        if (!this[_clipContext]) {
          this[_clipContext] = _utils_env__WEBPACK_IMPORTED_MODULE_17__["default"].createCanvas(1, 1);
        }

        var _this$boundingBox = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(this.boundingBox, 2),
            _this$boundingBox$ = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_this$boundingBox[0], 2),
            _x = _this$boundingBox$[0],
            y = _this$boundingBox$[1],
            _this$boundingBox$2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_this$boundingBox[1], 2),
            w = _this$boundingBox$2[0],
            h = _this$boundingBox$2[1];

        if (w && h) {
          this[_clipContext].width = w - _x;
          this[_clipContext].height = h - y;
        }

        var context = this[_clipContext].getContext('2d');

        var path = new Path2D(this.clipPath);
        context.clearRect(0, 0, this[_clipContext].width, this[_clipContext].height);
        context.save();
        context.translate(-_x, -y);
        context.fillStyle = 'white';
        context.fill(path);
        context.restore();
        this[_mesh].clipPath = this[_clipContext];
        var uv = generateUV(this.boundingBox, this[_mesh].position0);
        this[_mesh].attributes.a_clipUV = uv;
      }
    }
  }, {
    key: "getPointAtLength",
    value: function getPointAtLength(length) {
      return Object(_utils_contours__WEBPACK_IMPORTED_MODULE_12__["getPointAtLength"])(this[_contours], length);
    }
  }, {
    key: "getTotalLength",
    value: function getTotalLength() {
      return Object(_utils_contours__WEBPACK_IMPORTED_MODULE_12__["getTotalLength"])(this[_contours]);
    }
  }, {
    key: _applyProgram,
    value: function value(program) {
      var attributes = this[_attributes];
      var positions = this[_mesh].position0;
      var attribs = Object.entries(program._attribute);

      for (var i = 0; i < attribs.length; i++) {
        var _attribs$i = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(attribs[i], 2),
            name = _attribs$i[0],
            opts = _attribs$i[1];

        if (name !== 'a_color' && name !== 'a_sourceRect' && opts !== 'ignored') {
          var setter = attributes[name]; // console.log(opts.size);

          if (name === 'uv' && !setter) {
            var bounds = this[_mesh].boundingBox || bound_points__WEBPACK_IMPORTED_MODULE_6___default()(positions);
            this[_mesh].attributes[name] = generateUV(bounds, positions);
          } else {
            this[_mesh].attributes[name] = [];

            for (var j = 0; j < positions.length; j++) {
              var p = positions[j];

              this[_mesh].attributes[name].push(setter ? setter(p, i, positions) : Array(opts.size).fill(0));
            }
          }
        }
      }
    } // {stroke, fill}

  }, {
    key: _applyTransform,
    value: function value(mesh, m) {
      var positions = mesh.positions,
          p = mesh.position0;

      for (var i = 0; i < positions.length; i++) {
        var _p$i = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(p[i], 2),
            _x2 = _p$i[0],
            y = _p$i[1];

        var position = positions[i];
        position[0] = _x2 * m[0] + y * m[2] + m[4];
        position[1] = _x2 * m[1] + y * m[3] + m[5];
      }

      this._updateMatrix = false;
    }
  }, {
    key: _applyGradientTransform,
    value: function value() {
      var m = this[_transform];

      var vector = _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(this._radialGradientVector);

      if (vector) {
        var _vector2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(vector, 5),
            x1 = _vector2[0],
            y1 = _vector2[1],
            x2 = _vector2[3],
            y2 = _vector2[4];

        vector[0] = x1 * m[0] + y1 * m[2] + m[4];
        vector[1] = x1 * m[1] + y1 * m[3] + m[5];
        vector[3] = x2 * m[0] + y2 * m[2] + m[4];
        vector[4] = x2 * m[1] + y2 * m[3] + m[5];
        this[_uniforms].u_radialGradientVector = vector;
      }
    }
  }, {
    key: _applyTexture,
    value: function value(mesh, options) {
      function compareRect(r1, r2) {
        if (r1 == null && r2 == null) return true;
        if (r1 == null || r2 == null) return false;
        return r1[0] === r2[0] && r1[1] === r2[1] && r1[2] === r2[2] && r1[3] === r2[3];
      }

      var texture = this[_uniforms].u_texSampler;
      if (!texture) return;
      var _texture$_img = texture._img,
          imgWidth = _texture$_img.width,
          imgHeight = _texture$_img.height;
      var srcRect = options.srcRect;
      var rect = options.rect || [0, 0];

      if (options.rotated) {
        rect = [-rect[1], rect[0], rect[3], rect[2]];
      }

      if (rect[2] == null) rect[2] = srcRect ? srcRect[2] : imgWidth;
      if (rect[3] == null) rect[3] = srcRect ? srcRect[3] : imgHeight;

      if (options.hidden) {
        mesh.textureCoord = mesh.positions.map(function () {
          return [-1, -1, -1];
        });
      } else if (!mesh.textureCoord || !compareRect(this[_texOptions].rect, options.rect) || this[_texOptions].hidden !== options.hidden || this[_texOptions].rotated !== options.rotated) {
        var m = null;

        if (options.rotated) {
          m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].rotate(Array.of(0, 0, 0, 0, 0, 0), gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].fromValues(1, 0, 0, 1, 0, 0), 0.5 * Math.PI);
          m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0, 0, 0, 0, 0, 0), m, [0, -rect[2]]);
        }

        mesh.textureCoord = mesh.position0.map(function (_ref6) {
          var _ref7 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref6, 3),
              x = _ref7[0],
              y = _ref7[1],
              z = _ref7[2];

          if (1 / z > 0) {
            // fillTag
            if (options.rotated) {
              var x0 = x * m[0] + y * m[2] + m[4];
              var y0 = x * m[1] + y * m[3] + m[5];
              x = x0;
              y = y0;
            }

            var texCoord = getTexCoord([x, y], [rect[0] / rect[2], rect[1] / rect[3], rect[2], rect[3]], options);
            if (options.repeat) texCoord[2] = 1;
            return texCoord;
          }

          return [-1, -1, -1];
        });
      }

      if (srcRect) {
        var sRect = [srcRect[0] / imgWidth, srcRect[1] / imgHeight, srcRect[2] / imgWidth, srcRect[3] / imgHeight];
        mesh.attributes.a_sourceRect = mesh.positions.map(function () {
          return [].concat(sRect);
        });
      } else {
        mesh.attributes.a_sourceRect = mesh.positions.map(function () {
          return [0, 0, 0, 0];
        });
      }
    }
  }, {
    key: "accurate",
    value: function accurate(scale) {
      if (!this.contours) return;
      var path = this.contours.path;

      if (path) {
        var simplify = this.contours.simplify;

        var contours = _accurate(this.contours.path, 2 * scale, simplify);

        this[_mesh] = null;
        this[_contours] = contours;
      }
    }
  }, {
    key: "canIgnore",
    value: function canIgnore() {
      var noStroke = this[_stroke] == null || this[_stroke].lineWidth === 0 || this[_strokeColor][3] === 0;
      var noFill = this[_fill] == null || this[_fillColor][3] === 0;
      var noGradient = this[_uniforms].u_radialGradientVector == null;
      var noTexture = this[_uniforms].u_texSampler == null;
      return this[_opacity] === 0 || this[_program] == null && noStroke && noFill && noGradient && noTexture && !this.beforeRender && !this.afterRender;
    } // join: 'miter' or 'bevel'
    // cap: 'butt' or 'square'
    // lineDash: null
    // lineDashOffset: 0

  }, {
    key: "setStroke",
    value: function setStroke() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref8$thickness = _ref8.thickness,
          thickness = _ref8$thickness === void 0 ? 1 : _ref8$thickness,
          _ref8$cap = _ref8.cap,
          cap = _ref8$cap === void 0 ? 'butt' : _ref8$cap,
          _ref8$join = _ref8.join,
          join = _ref8$join === void 0 ? 'miter' : _ref8$join,
          _ref8$miterLimit = _ref8.miterLimit,
          miterLimit = _ref8$miterLimit === void 0 ? 10 : _ref8$miterLimit,
          _ref8$color = _ref8.color,
          color = _ref8$color === void 0 ? [0, 0, 0, 0] : _ref8$color,
          _ref8$lineDash = _ref8.lineDash,
          lineDash = _ref8$lineDash === void 0 ? null : _ref8$lineDash,
          _ref8$lineDashOffset = _ref8.lineDashOffset,
          lineDashOffset = _ref8$lineDashOffset === void 0 ? 0 : _ref8$lineDashOffset,
          _ref8$roundSegments = _ref8.roundSegments,
          roundSegments = _ref8$roundSegments === void 0 ? 20 : _ref8$roundSegments;

      this[_mesh] = null;
      this[_stroke] = new _extrude_contours__WEBPACK_IMPORTED_MODULE_7__["default"]({
        lineWidth: thickness,
        lineCap: cap,
        lineJoin: join,
        miterLimit: miterLimit,
        roundSegments: roundSegments
      });
      if (typeof color === 'string') color = Object(_utils_parse_color__WEBPACK_IMPORTED_MODULE_15__["default"])(color);
      this[_strokeColor] = color;
      this[_stroke].lineDash = lineDash;
      this[_stroke].lineDashOffset = lineDashOffset;
      return this;
    }
  }, {
    key: "setFill",
    value: function setFill() {
      var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref9$rule = _ref9.rule,
          rule = _ref9$rule === void 0 ? this.fillRule : _ref9$rule,
          _ref9$color = _ref9.color,
          color = _ref9$color === void 0 ? [0, 0, 0, 0] : _ref9$color;

      this[_mesh] = null;
      this[_fill] = {
        rule: rule
      };
      if (typeof color === 'string') color = Object(_utils_parse_color__WEBPACK_IMPORTED_MODULE_15__["default"])(color);
      this[_fillColor] = color;
      return this;
    }
    /**
      options: {
        scale: false,
        repeat: false,
        rotated: false,
        rect: [10, 10],
        srcRect: [...],
        hidden: false,
      }
     */

  }, {
    key: "setTexture",
    value: function setTexture(texture) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (texture && texture.image) {
        var _texture = texture,
            image = _texture.image,
            rect = _texture.rect;
        texture = image;

        if (options.rect) {
          for (var i = 0; i < options.rect.length; i++) {
            rect[i] = options.rect[i];
          }
        }

        options.rect = rect;
      }

      if (!this[_fill]) {
        this.setFill();
      }

      this.setUniforms({
        u_texSampler: texture
      });

      if (this[_mesh]) {
        this[_applyTexture](this[_mesh], options);
      }

      this[_texOptions] = options;
      return this;
    }
  }, {
    key: "setCircularGradient",
    value: function setCircularGradient() {
      var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          vector = _ref10.vector,
          gradientColors = _ref10.colors,
          _ref10$type = _ref10.type,
          type = _ref10$type === void 0 ? 'fill' : _ref10$type;

      if (vector.length !== 3) throw new TypeError('Invalid linearGradient.');
      this.setGradient({
        vector: vector,
        colors: gradientColors,
        type: type
      });
    }
  }, {
    key: "setLinearGradient",
    value: function setLinearGradient() {
      var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          vector = _ref11.vector,
          gradientColors = _ref11.colors,
          _ref11$type = _ref11.type,
          type = _ref11$type === void 0 ? 'fill' : _ref11$type;

      if (vector.length !== 4) throw new TypeError('Invalid linearGradient.');
      this.setGradient({
        vector: vector,
        colors: gradientColors,
        type: type
      });
    }
  }, {
    key: "setRadialGradient",
    value: function setRadialGradient() {
      var _ref12 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          vector = _ref12.vector,
          gradientColors = _ref12.colors,
          _ref12$type = _ref12.type,
          type = _ref12$type === void 0 ? 'fill' : _ref12$type;

      if (vector.length !== 6) throw new TypeError('Invalid radialGradient.');
      this.setGradient({
        vector: vector,
        colors: gradientColors,
        type: type
      });
    }
    /**
      vector: [x0, y0, r0, x1, y1, r1],
      colors: [{offset:0, color}, {offset:1, color}, ...],
     */

  }, {
    key: "setGradient",
    value: function setGradient() {
      var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          vector = _ref13.vector,
          gradientColors = _ref13.colors,
          _ref13$type = _ref13.type,
          type = _ref13$type === void 0 ? 'fill' : _ref13$type;

      gradientColors = gradientColors.map(function (_ref14) {
        var offset = _ref14.offset,
            color = _ref14.color;
        if (typeof color === 'string') color = Object(_utils_parse_color__WEBPACK_IMPORTED_MODULE_15__["default"])(color);
        return {
          offset: offset,
          color: color
        };
      });
      this[_gradient] = this[_gradient] || {};
      this[_gradient][type] = {
        vector: vector,
        colors: gradientColors
      };
      gradientColors.sort(function (a, b) {
        return a.offset - b.offset;
      });
      var colorSteps = [];
      gradientColors.forEach(function (_ref15) {
        var offset = _ref15.offset,
            color = _ref15.color;
        colorSteps.push.apply(colorSteps, [offset].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(color)));
      });

      var _vector;

      if (vector.length === 4) {
        // linear gradient;
        _vector = [vector[0], vector[1], 0, vector[2], vector[3], 0];
      } else {
        _vector = _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(vector);
      }

      if (colorSteps.length < 40) colorSteps.push(-1);
      if (colorSteps.length > 40) throw new Error('Too many colors, should be less than 8 colors');
      this._radialGradientVector = _vector;
      this[_uniforms].u_colorSteps = colorSteps;
      if (type === 'fill') this[_uniforms].u_gradientType = 1;else this[_uniforms].u_gradientType = 0;

      this[_applyGradientTransform]();

      return this;
    }
  }, {
    key: "setUniforms",
    value: function setUniforms() {
      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      Object.assign(this[_uniforms], uniforms);
      return this;
    }
  }, {
    key: "setTransform",
    value: function setTransform() {
      var transform = this[_transform];

      for (var _len = arguments.length, m = new Array(_len), _key = 0; _key < _len; _key++) {
        m[_key] = arguments[_key];
      }

      if (!gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].equals(m, transform)) {
        this[_transform] = m;
        delete this[_invertTransform];
        this._updateMatrix = true;
      }

      return this;
    }
  }, {
    key: "transform",
    value: function transform() {
      var transform = this[_transform];

      for (var _len2 = arguments.length, m = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        m[_key2] = arguments[_key2];
      }

      this[_transform] = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].multiply(Array.of(0, 0, 0, 0, 0, 0), transform, m);
      delete this[_invertTransform];
      this._updateMatrix = true;
      return this;
    }
  }, {
    key: "translate",
    value: function translate(x, y) {
      var m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].create();
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0, 0, 0, 0, 0, 0), m, [x, y]);
      return this.transform.apply(this, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(m));
    }
  }, {
    key: "rotate",
    value: function rotate(rad) {
      var _ref16 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0],
          _ref17 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref16, 2),
          ox = _ref17[0],
          oy = _ref17[1];

      var m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].create();
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0, 0, 0, 0, 0, 0), m, [ox, oy]);
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].rotate(Array.of(0, 0, 0, 0, 0, 0), m, rad);
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0, 0, 0, 0, 0, 0), m, [-ox, -oy]);
      return this.transform.apply(this, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(m));
    }
  }, {
    key: "scale",
    value: function scale(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;

      var _ref18 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0],
          _ref19 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref18, 2),
          ox = _ref19[0],
          oy = _ref19[1];

      var m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].create();
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0, 0, 0, 0, 0, 0), m, [ox, oy]);
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].scale(Array.of(0, 0, 0, 0, 0, 0), m, [x, y]);
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0, 0, 0, 0, 0, 0), m, [-ox, -oy]);
      return this.transform.apply(this, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(m));
    }
  }, {
    key: "skew",
    value: function skew(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;

      var _ref20 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0],
          _ref21 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref20, 2),
          ox = _ref21[0],
          oy = _ref21[1];

      var m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].create();
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0, 0, 0, 0, 0, 0), m, [ox, oy]);
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].multiply(Array.of(0, 0, 0, 0, 0, 0), m, gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].fromValues(1, Math.tan(y), Math.tan(x), 1, 0, 0));
      m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].translate(Array.of(0, 0, 0, 0, 0, 0), m, [-ox, -oy]);
      return this.transform.apply(this, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(m));
    }
  }, {
    key: "clearFilter",
    value: function clearFilter() {
      this.setColorTransform(null);
      this[_filter].length = 0;
      return this;
    }
  }, {
    key: "setColorTransform",
    value: function setColorTransform() {
      for (var _len3 = arguments.length, m = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        m[_key3] = arguments[_key3];
      }

      if (m[0] === null) {
        this.setUniforms({
          u_filterFlag: 0,
          u_colorMatrix: 0
        });
      } else {
        this.setUniforms({
          u_filterFlag: 1,
          u_colorMatrix: m
        });
      }

      return this;
    } // apply linear color transform

  }, {
    key: "transformColor",
    value: function transformColor() {
      var transform = this.uniforms.u_colorMatrix;

      for (var _len4 = arguments.length, m = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        m[_key4] = arguments[_key4];
      }

      if (transform) {
        transform = Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["multiply"])(transform, m);
      } else {
        transform = m;
      }

      this.setColorTransform.apply(this, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(transform));
      return this;
    }
  }, {
    key: "blur",
    value: function blur(length) {
      this[_filter].push("blur(".concat(length, "px)"));

      return this;
    }
  }, {
    key: "brightness",
    value: function brightness() {
      var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;

      this[_filter].push("brightness(".concat(100 * p, "%)"));

      return this.transformColor.apply(this, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["brightness"])(p)));
    }
  }, {
    key: "contrast",
    value: function contrast() {
      var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;

      this[_filter].push("contrast(".concat(100 * p, "%)"));

      return this.transformColor.apply(this, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["contrast"])(p)));
    }
  }, {
    key: "dropShadow",
    value: function dropShadow(offsetX, offsetY) {
      var blurRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, 0, 0, 1];
      if (Array.isArray(color)) color = Object(_utils_vector_to_rgba__WEBPACK_IMPORTED_MODULE_9__["default"])(color);

      this[_filter].push("drop-shadow(".concat(offsetX, "px ").concat(offsetY, "px ").concat(blurRadius, "px ").concat(color, ")"));

      return this;
    }
  }, {
    key: "grayscale",
    value: function grayscale() {
      var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;

      this[_filter].push("grayscale(".concat(100 * p, "%)"));

      return this.transformColor.apply(this, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["grayscale"])(p)));
    } // https://github.com/phoboslab/WebGLImageFilter/blob/master/webgl-image-filter.js#L371

  }, {
    key: "hueRotate",
    value: function hueRotate() {
      var deg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      this[_filter].push("hue-rotate(".concat(deg, "deg)"));

      return this.transformColor.apply(this, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["hueRotate"])(deg)));
    }
  }, {
    key: "invert",
    value: function invert() {
      var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;

      this[_filter].push("invert(".concat(100 * p, "%)"));

      return this.transformColor.apply(this, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["invert"])(p)));
    }
  }, {
    key: "opacity",
    value: function opacity() {
      var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;

      this[_filter].push("opacity(".concat(100 * p, "%)"));

      return this.transformColor.apply(this, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["opacity"])(p)));
    }
  }, {
    key: "saturate",
    value: function saturate() {
      var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;

      this[_filter].push("saturate(".concat(100 * p, "%)"));

      return this.transformColor.apply(this, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["saturate"])(p)));
    }
  }, {
    key: "sepia",
    value: function sepia() {
      var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;

      this[_filter].push("sepia(".concat(100 * p, "%)"));

      return this.transformColor.apply(this, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(Object(_utils_color_matrix__WEBPACK_IMPORTED_MODULE_10__["sepia"])(p)));
    }
  }, {
    key: "url",
    value: function url(svgFilter) {
      this[_filter].push("url(".concat(svgFilter, ")"));

      return this;
    }
  }, {
    key: "isPointCollision",
    value: function isPointCollision(x, y) {
      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'both';
      var meshData = this.meshData;
      var positions = meshData.positions,
          cells = meshData.cells;
      var m = this.invertMatrix;
      var x0 = m[0] * x + m[2] * y + m[4];
      var y0 = m[1] * x + m[3] * y + m[5];
      var box = this.boundingBox;

      if (x0 < box[0][0] || x0 > box[1][0] || y0 < box[0][1] || y0 > box[1][1]) {
        return false;
      }

      function projectionOn(_ref22, _ref23, _ref24) {
        var _ref25 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref22, 2),
            x0 = _ref25[0],
            y0 = _ref25[1];

        var _ref26 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref23, 2),
            x1 = _ref26[0],
            y1 = _ref26[1];

        var _ref27 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref24, 2),
            x2 = _ref27[0],
            y2 = _ref27[1];

        var v2x = x2 - x1;
        var v2y = y2 - y1;
        var p = ((x0 - x1) * v2x + (y0 - y1) * v2y) / (Math.pow(v2x, 2) + Math.pow(v2y, 2));
        return p >= 0 && p <= 1;
      }

      for (var i = 0; i < cells.length; i++) {
        var cell = cells[i];
        if (type === 'fill' && cell[0] >= meshData.fillPointCount) break;
        if (type === 'stroke' && cell[0] < meshData.fillPointCount) continue; // eslint-disable-line no-continue

        var _cell$map = cell.map(function (idx) {
          return positions[idx];
        }),
            _cell$map2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_cell$map, 3),
            _cell$map2$ = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_cell$map2[0], 2),
            x1 = _cell$map2$[0],
            y1 = _cell$map2$[1],
            _cell$map2$2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_cell$map2[1], 2),
            x2 = _cell$map2$2[0],
            y2 = _cell$map2$2[1],
            _cell$map2$3 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_cell$map2[2], 2),
            x3 = _cell$map2$3[0],
            y3 = _cell$map2$3[1];

        var s1 = Math.sign((x - x1) * (y2 - y1) - (x2 - x1) * (y - y1));

        if (s1 === 0 && projectionOn([x, y], [x1, y1], [x2, y2])) {
          return true;
        }

        var s2 = Math.sign((x - x2) * (y3 - y2) - (x3 - x2) * (y - y2));

        if (s2 === 0 && projectionOn([x, y], [x2, y2], [x3, y3])) {
          return true;
        }

        var s3 = Math.sign((x - x3) * (y1 - y3) - (x1 - x3) * (y - y3));

        if (s3 === 0 && projectionOn([x, y], [x3, y3], [x1, y1])) {
          return true;
        }

        if (s1 === 1 && s2 === 1 && s3 === 1 || s1 === -1 && s2 === -1 && s3 === -1) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "isPointInFill",
    value: function isPointInFill(x, y) {
      return this.isPointCollision(x, y, 'fill');
    }
  }, {
    key: "isPointInStroke",
    value: function isPointInStroke(x, y) {
      return this.isPointCollision(x, y, 'stroke');
    }
  }, {
    key: "addPass",
    value: function addPass(program) {
      var _ref28 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          width = _ref28.width,
          height = _ref28.height,
          uniforms = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default()(_ref28, ["width", "height"]);

      var figure = new _figure2d__WEBPACK_IMPORTED_MODULE_16__["default"]();
      figure.rect(0, 0, width, height);
      var mesh = new Mesh2D(figure, {
        width: width,
        height: height
      });
      mesh.setUniforms(uniforms);
      mesh.setProgram(program);

      this[_pass].push(mesh);
    }
  }, {
    key: "contours",
    get: function get() {
      return this[_contours];
    },
    set: function set(contours) {
      this[_mesh] = null;
      this[_contours] = contours;
      var scale = contours.scale;
      var acc = this.transformScale / scale;

      if (acc > 1.5) {
        this.accurate(this.transformScale);
      }
    }
  }, {
    key: "program",
    get: function get() {
      return this[_program];
    }
  }, {
    key: "blend",
    get: function get() {
      return this[_blend] == null ? 'auto' : this[_blend];
    },
    set: function set(blend) {
      this[_blend] = blend;
      if (this[_mesh]) this[_mesh].enableBlend = this.enableBlend;
    }
  }, {
    key: "boundingBox",
    get: function get() {
      if (this[_mesh] && this[_mesh].boundingBox) return this[_mesh].boundingBox;
      var meshData = this.meshData;

      if (meshData) {
        var positions = meshData.position0;
        if (positions.length) meshData.boundingBox = bound_points__WEBPACK_IMPORTED_MODULE_6___default()(positions);else return [[0, 0], [0, 0]];
        return meshData.boundingBox;
      }

      return [[0, 0], [0, 0]];
    }
  }, {
    key: "boundingCenter",
    get: function get() {
      var bound = this.boundingBox;

      if (bound) {
        return [0.5 * (bound[0][0] + bound[1][0]), 0.5 * (bound[0][1] + bound[1][1])];
      }

      return [0, 0];
    }
  }, {
    key: "fillRule",
    get: function get() {
      if (this[_fill]) {
        return this[_fill].rule;
      }

      return 'nonzero';
    }
  }, {
    key: "lineWidth",
    get: function get() {
      if (this[_stroke]) {
        return this[_stroke].lineWidth;
      }

      return 0;
    }
  }, {
    key: "lineCap",
    get: function get() {
      if (this[_stroke]) {
        return this[_stroke].lineCap;
      }

      return '';
    }
  }, {
    key: "lineJoin",
    get: function get() {
      if (this[_stroke]) {
        return this[_stroke].lineJoin;
      }

      return '';
    }
  }, {
    key: "miterLimit",
    get: function get() {
      if (this[_stroke]) {
        return this[_stroke].miterLimit;
      }

      return 0;
    }
  }, {
    key: "strokeStyle",
    get: function get() {
      if (this[_strokeColor] && this[_strokeColor][3] !== 0) {
        return Object(_utils_vector_to_rgba__WEBPACK_IMPORTED_MODULE_9__["default"])(this[_strokeColor]);
      }

      return '';
    }
  }, {
    key: "lineDash",
    get: function get() {
      if (this[_stroke]) {
        return this[_stroke].lineDash;
      }

      return null;
    }
  }, {
    key: "lineDashOffset",
    get: function get() {
      if (this[_stroke]) {
        return this[_stroke].lineDashOffset;
      }

      return 0;
    }
  }, {
    key: "fillStyle",
    get: function get() {
      if (this[_fillColor] && this[_fillColor][3] !== 0) {
        return Object(_utils_vector_to_rgba__WEBPACK_IMPORTED_MODULE_9__["default"])(this[_fillColor]);
      }

      return '';
    }
  }, {
    key: "gradient",
    get: function get() {
      return this[_gradient];
    }
  }, {
    key: "texture",
    get: function get() {
      if (this[_uniforms].u_texSampler) {
        return {
          image: this[_uniforms].u_texSampler._img,
          options: this[_texOptions]
        };
      }

      return null;
    }
  }, {
    key: "enableBlend",
    get: function get() {
      if (this[_blend] === true || this[_blend] === false) return this[_blend];
      return this[_opacity] < 1.0 || this[_strokeColor] != null && this[_strokeColor][3] < 1.0 || this[_fillColor] != null && this[_fillColor][3] < 1.0 || this[_uniforms].u_colorMatrix != null && this[_uniforms].u_colorMatrix[18] < 1.0 || this[_uniforms].u_radialGradientVector != null || this.beforeRender || this.afterRender;
    }
  }, {
    key: "filterCanvas",
    get: function get() {
      return /blur|drop-shadow|url/.test(this.filter);
    }
  }, {
    key: "filter",
    get: function get() {
      return this[_filter].join(' ');
    }
  }, {
    key: "transformMatrix",
    get: function get() {
      return this[_transform];
    }
  }, {
    key: "invertMatrix",
    get: function get() {
      if (!this[_invertTransform]) {
        var m = gl_matrix__WEBPACK_IMPORTED_MODULE_5__["mat2d"].invert(Array.of(0, 0, 0, 0, 0, 0), this[_transform]);
        this[_invertTransform] = m;
      }

      return this[_invertTransform];
    }
  }, {
    key: "transformScale",
    get: function get() {
      var m = this[_transform];
      return Math.max(Math.hypot(m[0], m[1]), Math.hypot(m[2], m[3]));
    }
  }, {
    key: "uniforms",
    get: function get() {
      return this[_uniforms];
    }
  }, {
    key: "pass",
    get: function get() {
      return this[_pass];
    }
  }, {
    key: "meshData",
    get: function get() {
      var _this = this;

      // eslint-disable-line complexity
      if (this._updateMatrix) {
        var acc = this.transformScale / this.contours.scale;

        if (acc > 1.5) {
          this.accurate(this.transformScale);
        }
      }

      if (!this[_mesh]) {
        if (!this[_fill] && !this[_stroke]) {
          this.setFill();
        }

        var contours = this[_contours];
        var meshes = {};

        if (contours && contours.length) {
          if (this[_fill]) {
            try {
              var _mesh2 = _triangulate_contours__WEBPACK_IMPORTED_MODULE_13___default()(contours, this[_fill]);

              _mesh2.positions = _mesh2.positions.map(function (p) {
                p.push(_this[_opacity]);
                return p;
              });
              _mesh2.attributes = {
                a_color: Array.from({
                  length: _mesh2.positions.length
                }).map(function () {
                  return _this[_fillColor].map(function (c) {
                    return Math.round(255 * c);
                  });
                }) // a_sourceRect: Array.from({length: mesh.positions.length}).map(() => [0, 0, 0, 0]),

              };
              meshes.fill = _mesh2;
            } catch (ex) {// ignore this[_fill]
            }
          }

          if (this[_stroke]) {
            var lineDash = this[_stroke].lineDash;
            var strokeContours = contours;

            if (lineDash) {
              var lineDashOffset = this[_stroke].lineDashOffset;
              strokeContours = Object(_utils_contours__WEBPACK_IMPORTED_MODULE_12__["getDashContours"])(contours, lineDash, lineDashOffset);
            }

            var _meshes = strokeContours.map(function (lines, i) {
              var closed = lines.length > 1 && gl_matrix__WEBPACK_IMPORTED_MODULE_5__["vec2"].equals(lines[0], lines[lines.length - 1]);

              var points = _this[_stroke].build(lines, closed);

              return _triangulate_contours__WEBPACK_IMPORTED_MODULE_13___default()([points]);
            });

            _meshes.forEach(function (mesh) {
              mesh.positions = mesh.positions.map(function (p) {
                p.push(-_this[_opacity]);
                return p;
              });
              mesh.attributes = {
                a_color: Array.from({
                  length: mesh.positions.length
                }).map(function () {
                  return _this[_strokeColor].map(function (c) {
                    return Math.round(255 * c);
                  });
                })
              };
            });

            meshes.stroke = Object(_utils_flatten_meshes__WEBPACK_IMPORTED_MODULE_8__["default"])(_meshes);
          }
        }

        var mesh = Object(_utils_flatten_meshes__WEBPACK_IMPORTED_MODULE_8__["default"])([meshes.fill, meshes.stroke]);
        mesh.fillPointCount = meshes.fill ? meshes.fill.positions.length : 0;
        mesh.enableBlend = this.enableBlend;
        mesh.position0 = mesh.positions.map(function (_ref29) {
          var _ref30 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_4___default()(_ref29, 3),
              x = _ref30[0],
              y = _ref30[1],
              z = _ref30[2];

          return [x, y, z];
        });
        mesh.uniforms = this[_uniforms]; // if(!mesh.uniforms.u_filterFlag) mesh.uniforms.u_filterFlag = 0;
        // if(!mesh.uniforms.u_radialGradientVector) mesh.uniforms.u_radialGradientVector = [0, 0, 0, 0, 0, 0];

        this[_mesh] = mesh;

        if (!this[_uniforms].u_texSampler) {// mesh.textureCoord = mesh.positions.map(() => [0, 0]);
        } else {
          this[_applyTexture](mesh, this[_texOptions]);
        }

        var transform = this[_transform];

        if (!Object(_utils_transform__WEBPACK_IMPORTED_MODULE_11__["isUnitTransform"])(transform)) {
          this[_applyTransform](mesh, transform);

          if (this[_uniforms].u_radialGradientVector) this[_applyGradientTransform]();
        }

        if (this.clipPath) {
          this[_applyClipPath]();
        }

        if (this[_program]) this[_applyProgram](this[_program]);
      }

      if (this._updateMatrix) {
        this[_mesh].matrix = this[_transform];

        this[_applyTransform](this[_mesh], this[_transform]);

        if (this[_uniforms].u_radialGradientVector) this[_applyGradientTransform]();
      }

      return this[_mesh];
    }
  }]);

  return Mesh2D;
}();



/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var objectWithoutPropertiesLoose = __webpack_require__(75);

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

module.exports = _objectWithoutProperties;

/***/ }),
/* 75 */
/***/ (function(module, exports) {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;

/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _stroke__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77);
__webpack_require__(1).glMatrix.setMatrixArrayType(Array);


/* harmony default export */ __webpack_exports__["default"] = (_stroke__WEBPACK_IMPORTED_MODULE_0__["Stroke"]);

/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stroke", function() { return Stroke; });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(66);




__webpack_require__(1).glMatrix.setMatrixArrayType(Array);


var tmp = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])();
var lineA = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])();
var lineB = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])();
var tangent = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])();
var miter = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])();
var MAX_MITER_VALUE = 1e20; // infinity * 0 cause NaN, fix #7

var Stroke = /*#__PURE__*/function () {
  function Stroke() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$lineWidth = _ref.lineWidth,
        lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth,
        _ref$lineJoin = _ref.lineJoin,
        lineJoin = _ref$lineJoin === void 0 ? 'miter' : _ref$lineJoin,
        _ref$miterLimit = _ref.miterLimit,
        miterLimit = _ref$miterLimit === void 0 ? 10 : _ref$miterLimit,
        _ref$lineCap = _ref.lineCap,
        lineCap = _ref$lineCap === void 0 ? 'butt' : _ref$lineCap,
        _ref$roundSegments = _ref.roundSegments,
        roundSegments = _ref$roundSegments === void 0 ? 20 : _ref$roundSegments;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Stroke);

    this.lineWidth = lineWidth;
    this.lineJoin = lineJoin;
    this.miterLimit = miterLimit;
    this.lineCap = lineCap;
    this.roundSegments = roundSegments;
    this._normal = null;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Stroke, [{
    key: "build",
    value: function build(points) {
      var closed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var total = points.length;
      points = _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(points);
      if (total < 2) return points;

      if (closed) {
        if (points[0][0] !== points[total - 1][0] || points[0][1] !== points[total - 1][1]) {
          points.push(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(points[0]));
        }

        points.push(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(points[1]));
      }

      total = points.length; // clear flags

      this._normal = null;
      var contours = {
        left: [],
        right: []
      };
      var halfThick = this.lineWidth / 2;
      var cap = this.lineCap;

      if (!closed && cap === 'square') {
        Object(_utils__WEBPACK_IMPORTED_MODULE_3__["direction"])(lineA, points[0], points[1]);
        Object(_utils__WEBPACK_IMPORTED_MODULE_3__["scaleAndAdd"])(points[0], points[0], lineA, halfThick);
        var idx = points.length - 1;
        Object(_utils__WEBPACK_IMPORTED_MODULE_3__["direction"])(lineA, points[idx], points[idx - 1]);
        Object(_utils__WEBPACK_IMPORTED_MODULE_3__["scaleAndAdd"])(points[idx], points[idx], lineA, halfThick);
      } // join each segment


      for (var i = 1; i < total; i++) {
        var last = points[i - 1];
        var cur = points[i];
        var next = points[i + 1];

        this._seg(contours, last, cur, next, halfThick, closed);
      }

      if (!closed && cap === 'round') {
        capRound(contours, this.roundSegments);
      }

      var ret = [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(contours.left), _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(contours.right.reverse()));
      return ret;
    }
  }, {
    key: "_seg",
    value: function _seg(contours, last, cur, next, halfThick, closed) {
      var joinBevel = this.lineJoin === 'bevel';
      var joinRound = this.lineJoin === 'round'; // get unit direction of line

      Object(_utils__WEBPACK_IMPORTED_MODULE_3__["direction"])(lineA, cur, last); // if we don't yet have a normal from previous join,
      // compute based on line start - end

      if (!this._normal) {
        this._normal = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])();
        Object(_utils__WEBPACK_IMPORTED_MODULE_3__["normal"])(this._normal, lineA);
      }

      if (!contours.left.length) {
        // start
        extrusions(contours, last, this._normal, halfThick);
      }

      if (!next) {
        // no next segment, simple extrusion
        Object(_utils__WEBPACK_IMPORTED_MODULE_3__["normal"])(this._normal, lineA);

        if (!closed) {
          extrusions(contours, cur, this._normal, halfThick);
        } else {
          extrusions(contours, last, this._normal, halfThick);
        }
      } else {
        // we have a next segment, start with miter
        // get unit dir of next line
        Object(_utils__WEBPACK_IMPORTED_MODULE_3__["direction"])(lineB, next, cur); // stores tangent & miter

        var miterLen = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["computeMiter"])(tangent, miter, lineA, lineB, halfThick); // infinity * 0 cause NaN, fix #7

        miterLen = Math.min(miterLen, MAX_MITER_VALUE); // get orientation

        var flip = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["dot"])(tangent, this._normal) < 0 ? -1 : 1;
        var bevel = joinBevel || joinRound;

        if (!bevel && this.lineJoin === 'miter') {
          var limit = miterLen / halfThick;

          if (limit > this.miterLimit) {
            // miterLen = this.miterLimit * halfThick;
            bevel = true;
          }
        } // let len = Infinity;
        // if(next && !nextnext) len = Math.hypot(next[0] - cur[0], next[1] - cur[1]);


        if (bevel) {
          // next two points in our first segment
          Object(_utils__WEBPACK_IMPORTED_MODULE_3__["scaleAndAdd"])(tmp, cur, this._normal, -halfThick * flip);
          addPoint(contours, tmp, flip);
          var maxLen = Infinity;

          if (last) {
            maxLen = Math.min(maxLen, Math.hypot(cur[0] - last[0], cur[1] - last[1]));
          }

          if (next) {
            maxLen = Math.min(maxLen, Math.hypot(next[0] - cur[0], next[1] - cur[1]));
          }

          var len = Math.max(halfThick, Math.min(miterLen, maxLen));
          Object(_utils__WEBPACK_IMPORTED_MODULE_3__["scaleAndAdd"])(tmp, cur, miter, len * flip);
          addPoint(contours, tmp, -flip);

          if (next) {
            Object(_utils__WEBPACK_IMPORTED_MODULE_3__["normal"])(tmp, lineB);
            Object(_utils__WEBPACK_IMPORTED_MODULE_3__["copy"])(this._normal, tmp); // store normal for next round

            Object(_utils__WEBPACK_IMPORTED_MODULE_3__["scaleAndAdd"])(tmp, cur, tmp, -halfThick * flip);

            if (joinRound) {
              var pEnd = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["clone"])(tmp);
              var pStart = flip > 0 ? contours.left[contours.left.length - 1] : contours.right[contours.right.length - 1];
              var o = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["clone"])(cur);
              var p1 = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["sub"])(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])(), pStart, o);
              var p2 = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["sub"])(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])(), pEnd, o);
              var delta = Math.PI / this.roundSegments;

              for (var i = 0; i < this.roundSegments; i++) {
                Object(_utils__WEBPACK_IMPORTED_MODULE_3__["rotate"])(p1, p1, [0, 0], flip * delta);

                if (Math.sign(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["cross"])(tmp, p1, p2)[2]) !== flip) {
                  break;
                } else {
                  Object(_utils__WEBPACK_IMPORTED_MODULE_3__["add"])(tmp, p1, o);
                }

                addPoint(contours, tmp, flip);
              }

              addPoint(contours, pEnd, flip);
            } else {
              addPoint(contours, tmp, flip);
            }
          }
        } else {
          extrusions(contours, cur, miter, miterLen);
          Object(_utils__WEBPACK_IMPORTED_MODULE_3__["copy"])(this._normal, miter);
        }
      }
    }
  }]);

  return Stroke;
}();

function addPoint(contours, point, flip) {
  if (flip > 0) {
    contours.left.push(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["clone"])(point));
  } else {
    contours.right.push(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["clone"])(point));
  }
}

function extrusions(contours, point, normal, scale) {
  var flip = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;
  // next two points to end our segment
  Object(_utils__WEBPACK_IMPORTED_MODULE_3__["scaleAndAdd"])(tmp, point, normal, -scale);
  addPoint(contours, tmp, -flip);
  Object(_utils__WEBPACK_IMPORTED_MODULE_3__["scaleAndAdd"])(tmp, point, normal, scale);
  addPoint(contours, tmp, flip);
}

function capRound(_ref2, roundSegments) {
  var left = _ref2.left,
      right = _ref2.right;
  var t = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])();
  var normal = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["create"])();
  var pStart = left[0];
  var pEnd = right[0];
  var center = [0.5 * (pStart[0] + pEnd[0]), 0.5 * (pStart[1] + pEnd[1])];
  Object(_utils__WEBPACK_IMPORTED_MODULE_3__["sub"])(normal, pStart, center);

  for (var i = 1; i <= roundSegments; i++) {
    var rad = -1 * Math.PI * i / roundSegments;
    Object(_utils__WEBPACK_IMPORTED_MODULE_3__["rotate"])(t, normal, [0, 0], rad);
    Object(_utils__WEBPACK_IMPORTED_MODULE_3__["add"])(tmp, center, t);
    left.unshift(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["clone"])(tmp));
  }

  pStart = right[right.length - 1];
  pEnd = left[left.length - 1];
  center = [0.5 * (pStart[0] + pEnd[0]), 0.5 * (pStart[1] + pEnd[1])];
  Object(_utils__WEBPACK_IMPORTED_MODULE_3__["sub"])(normal, pStart, center);

  for (var _i = 1; _i <= roundSegments; _i++) {
    var _rad = -1 * Math.PI * _i / roundSegments;

    Object(_utils__WEBPACK_IMPORTED_MODULE_3__["rotate"])(t, normal, [0, 0], _rad);
    Object(_utils__WEBPACK_IMPORTED_MODULE_3__["add"])(tmp, center, t);
    right.push(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["clone"])(tmp));
  }
}

/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isUnitTransform", function() { return isUnitTransform; });
__webpack_require__(1).glMatrix.setMatrixArrayType(Array);

function isUnitTransform(m) {
  return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0;
}

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(1).glMatrix.setMatrixArrayType(Array);

// https://github.com/mattdesl/triangulate-contours

/* eslint-disable */
var Tess2 = __webpack_require__(80);

var xtend = __webpack_require__(81);

module.exports = function (contours, opt) {
  opt = opt || {};
  contours = contours.filter(function (c) {
    return c.length > 2;
  });

  if (contours.length === 0) {
    return {
      positions: [],
      cells: []
    };
  }

  if (typeof opt.vertexSize !== 'number') opt.vertexSize = contours[0][0].length; //flatten for tess2.js

  contours = contours.map(function (c) {
    return c.reduce(function (a, b) {
      return a.concat(b);
    });
  });
  var windingRule = opt.rule === 'evenodd' ? Tess2.WINDING_ODD : Tess2.WINDING_NONZERO; // Tesselate

  var res = Tess2.tesselate(xtend({
    contours: contours,
    windingRule: windingRule,
    elementType: Tess2.POLYGONS,
    polySize: 3,
    vertexSize: 2
  }, opt));
  var positions = [];

  for (var i = 0; i < res.vertices.length; i += opt.vertexSize) {
    var pos = res.vertices.slice(i, i + opt.vertexSize);
    positions.push(pos);
  }

  var cells = [];

  for (i = 0; i < res.elements.length; i += 3) {
    var a = res.elements[i],
        b = res.elements[i + 1],
        c = res.elements[i + 2];
    cells.push([a, b, c]);
  } //return a simplicial complex


  return {
    positions: positions,
    cells: cells
  };
};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disabled */

/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) [dates of first publication] Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/

/*
** Author: Mikko Mononen, Aug 2013.
** The code is based on GLU libtess by Eric Veach, July 1994
*/

/* Public API */

__webpack_require__(1).glMatrix.setMatrixArrayType(Array);

var Tess2 = {};
var Geom = {};
module.exports = Tess2;
Tess2.WINDING_ODD = 0;
Tess2.WINDING_NONZERO = 1;
Tess2.WINDING_POSITIVE = 2;
Tess2.WINDING_NEGATIVE = 3;
Tess2.WINDING_ABS_GEQ_TWO = 4;
Tess2.POLYGONS = 0;
Tess2.CONNECTED_POLYGONS = 1;
Tess2.BOUNDARY_CONTOURS = 2;

Tess2.tesselate = function (opts) {
  var debug = opts.debug || false;
  var tess = new Tesselator();

  for (var i = 0; i < opts.contours.length; i++) {
    tess.addContour(opts.vertexSize || 2, opts.contours[i]);
  }

  tess.tesselate(opts.windingRule || Tess2.WINDING_ODD, opts.elementType || Tess2.POLYGONS, opts.polySize || 3, opts.vertexSize || 2, opts.normal || [0, 0, 1]);
  return {
    vertices: tess.vertices,
    vertexIndices: tess.vertexIndices,
    vertexCount: tess.vertexCount,
    elements: tess.elements,
    elementCount: tess.elementCount,
    mesh: debug ? tess.mesh : undefined
  };
};
/* Internal */


var assert = function assert(cond) {
  if (!cond) {
    throw "Assertion Failed!";
  }
};
/* The mesh structure is similar in spirit, notation, and operations
* to the "quad-edge" structure (see L. Guibas and J. Stolfi, Primitives
* for the manipulation of general subdivisions and the computation of
* Voronoi diagrams, ACM Transactions on Graphics, 4(2):74-123, April 1985).
* For a simplified description, see the course notes for CS348a,
* "Mathematical Foundations of Computer Graphics", available at the
* Stanford bookstore (and taught during the fall quarter).
* The implementation also borrows a tiny subset of the graph-based approach
* use in Mantyla's Geometric Work Bench (see M. Mantyla, An Introduction
* to Sold Modeling, Computer Science Press, Rockville, Maryland, 1988).
*
* The fundamental data structure is the "half-edge".  Two half-edges
* go together to make an edge, but they point in opposite directions.
* Each half-edge has a pointer to its mate (the "symmetric" half-edge Sym),
* its origin vertex (Org), the face on its left side (Lface), and the
* adjacent half-edges in the CCW direction around the origin vertex
* (Onext) and around the left face (Lnext).  There is also a "next"
* pointer for the global edge list (see below).
*
* The notation used for mesh navigation:
*  Sym   = the mate of a half-edge (same edge, but opposite direction)
*  Onext = edge CCW around origin vertex (keep same origin)
*  Dnext = edge CCW around destination vertex (keep same dest)
*  Lnext = edge CCW around left face (dest becomes new origin)
*  Rnext = edge CCW around right face (origin becomes new dest)
*
* "prev" means to substitute CW for CCW in the definitions above.
*
* The mesh keeps global lists of all vertices, faces, and edges,
* stored as doubly-linked circular lists with a dummy header node.
* The mesh stores pointers to these dummy headers (vHead, fHead, eHead).
*
* The circular edge list is special; since half-edges always occur
* in pairs (e and e->Sym), each half-edge stores a pointer in only
* one direction.  Starting at eHead and following the e->next pointers
* will visit each *edge* once (ie. e or e->Sym, but not both).
* e->Sym stores a pointer in the opposite direction, thus it is
* always true that e->Sym->next->Sym->next == e.
*
* Each vertex has a pointer to next and previous vertices in the
* circular list, and a pointer to a half-edge with this vertex as
* the origin (NULL if this is the dummy header).  There is also a
* field "data" for client data.
*
* Each face has a pointer to the next and previous faces in the
* circular list, and a pointer to a half-edge with this face as
* the left face (NULL if this is the dummy header).  There is also
* a field "data" for client data.
*
* Note that what we call a "face" is really a loop; faces may consist
* of more than one loop (ie. not simply connected), but there is no
* record of this in the data structure.  The mesh may consist of
* several disconnected regions, so it may not be possible to visit
* the entire mesh by starting at a half-edge and traversing the edge
* structure.
*
* The mesh does NOT support isolated vertices; a vertex is deleted along
* with its last edge.  Similarly when two faces are merged, one of the
* faces is deleted (see tessMeshDelete below).  For mesh operations,
* all face (loop) and vertex pointers must not be NULL.  However, once
* mesh manipulation is finished, TESSmeshZapFace can be used to delete
* faces of the mesh, one at a time.  All external faces can be "zapped"
* before the mesh is returned to the client; then a NULL face indicates
* a region which is not part of the output polygon.
*/


function TESSvertex() {
  this.next = null;
  /* next vertex (never NULL) */

  this.prev = null;
  /* previous vertex (never NULL) */

  this.anEdge = null;
  /* a half-edge with this origin */

  /* Internal data (keep hidden) */

  this.coords = [0, 0, 0];
  /* vertex location in 3D */

  this.s = 0.0;
  this.t = 0.0;
  /* projection onto the sweep plane */

  this.pqHandle = 0;
  /* to allow deletion from priority queue */

  this.n = 0;
  /* to allow identify unique vertices */

  this.idx = 0;
  /* to allow map result to original verts */
}

function TESSface() {
  this.next = null;
  /* next face (never NULL) */

  this.prev = null;
  /* previous face (never NULL) */

  this.anEdge = null;
  /* a half edge with this left face */

  /* Internal data (keep hidden) */

  this.trail = null;
  /* "stack" for conversion to strips */

  this.n = 0;
  /* to allow identiy unique faces */

  this.marked = false;
  /* flag for conversion to strips */

  this.inside = false;
  /* this face is in the polygon interior */
}

;

function TESShalfEdge(side) {
  this.next = null;
  /* doubly-linked list (prev==Sym->next) */

  this.Sym = null;
  /* same edge, opposite direction */

  this.Onext = null;
  /* next edge CCW around origin */

  this.Lnext = null;
  /* next edge CCW around left face */

  this.Org = null;
  /* origin vertex (Overtex too long) */

  this.Lface = null;
  /* left face */

  /* Internal data (keep hidden) */

  this.activeRegion = null;
  /* a region with this upper edge (sweep.c) */

  this.winding = 0;
  /* change in winding number when crossing
  from the right face to the left face */

  this.side = side;
}

;
TESShalfEdge.prototype = {
  get Rface() {
    return this.Sym.Lface;
  },

  set Rface(v) {
    this.Sym.Lface = v;
  },

  get Dst() {
    return this.Sym.Org;
  },

  set Dst(v) {
    this.Sym.Org = v;
  },

  get Oprev() {
    return this.Sym.Lnext;
  },

  set Oprev(v) {
    this.Sym.Lnext = v;
  },

  get Lprev() {
    return this.Onext.Sym;
  },

  set Lprev(v) {
    this.Onext.Sym = v;
  },

  get Dprev() {
    return this.Lnext.Sym;
  },

  set Dprev(v) {
    this.Lnext.Sym = v;
  },

  get Rprev() {
    return this.Sym.Onext;
  },

  set Rprev(v) {
    this.Sym.Onext = v;
  },

  get Dnext() {
    return (
      /*this.Rprev*/
      this.Sym.Onext.Sym
    );
  },

  /* 3 pointers */
  set Dnext(v) {
    /*this.Rprev*/
    this.Sym.Onext.Sym = v;
  },

  /* 3 pointers */
  get Rnext() {
    return (
      /*this.Oprev*/
      this.Sym.Lnext.Sym
    );
  },

  /* 3 pointers */
  set Rnext(v) {
    /*this.Oprev*/
    this.Sym.Lnext.Sym = v;
  }
  /* 3 pointers */


};

function TESSmesh() {
  var v = new TESSvertex();
  var f = new TESSface();
  var e = new TESShalfEdge(0);
  var eSym = new TESShalfEdge(1);
  v.next = v.prev = v;
  v.anEdge = null;
  f.next = f.prev = f;
  f.anEdge = null;
  f.trail = null;
  f.marked = false;
  f.inside = false;
  e.next = e;
  e.Sym = eSym;
  e.Onext = null;
  e.Lnext = null;
  e.Org = null;
  e.Lface = null;
  e.winding = 0;
  e.activeRegion = null;
  eSym.next = eSym;
  eSym.Sym = e;
  eSym.Onext = null;
  eSym.Lnext = null;
  eSym.Org = null;
  eSym.Lface = null;
  eSym.winding = 0;
  eSym.activeRegion = null;
  this.vHead = v;
  /* dummy header for vertex list */

  this.fHead = f;
  /* dummy header for face list */

  this.eHead = e;
  /* dummy header for edge list */

  this.eHeadSym = eSym;
  /* and its symmetric counterpart */
}

;
/* The mesh operations below have three motivations: completeness,
* convenience, and efficiency.  The basic mesh operations are MakeEdge,
* Splice, and Delete.  All the other edge operations can be implemented
* in terms of these.  The other operations are provided for convenience
* and/or efficiency.
*
* When a face is split or a vertex is added, they are inserted into the
* global list *before* the existing vertex or face (ie. e->Org or e->Lface).
* This makes it easier to process all vertices or faces in the global lists
* without worrying about processing the same data twice.  As a convenience,
* when a face is split, the "inside" flag is copied from the old face.
* Other internal data (v->data, v->activeRegion, f->data, f->marked,
* f->trail, e->winding) is set to zero.
*
* ********************** Basic Edge Operations **************************
*
* tessMeshMakeEdge( mesh ) creates one edge, two vertices, and a loop.
* The loop (face) consists of the two new half-edges.
*
* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
* mesh connectivity and topology.  It changes the mesh so that
*  eOrg->Onext <- OLD( eDst->Onext )
*  eDst->Onext <- OLD( eOrg->Onext )
* where OLD(...) means the value before the meshSplice operation.
*
* This can have two effects on the vertex structure:
*  - if eOrg->Org != eDst->Org, the two vertices are merged together
*  - if eOrg->Org == eDst->Org, the origin is split into two vertices
* In both cases, eDst->Org is changed and eOrg->Org is untouched.
*
* Similarly (and independently) for the face structure,
*  - if eOrg->Lface == eDst->Lface, one loop is split into two
*  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
* In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
*
* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
* if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
* eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
* the newly created loop will contain eDel->Dst.  If the deletion of eDel
* would create isolated vertices, those are deleted as well.
*
* ********************** Other Edge Operations **************************
*
* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
* eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
* eOrg and eNew will have the same left face.
*
* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
* such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
* eOrg and eNew will have the same left face.
*
* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
* to eDst->Org, and returns the corresponding half-edge eNew.
* If eOrg->Lface == eDst->Lface, this splits one loop into two,
* and the newly created loop is eNew->Lface.  Otherwise, two disjoint
* loops are merged into one, and the loop eDst->Lface is destroyed.
*
* ************************ Other Operations *****************************
*
* tessMeshNewMesh() creates a new mesh with no edges, no vertices,
* and no loops (what we usually call a "face").
*
* tessMeshUnion( mesh1, mesh2 ) forms the union of all structures in
* both meshes, and returns the new mesh (the old meshes are destroyed).
*
* tessMeshDeleteMesh( mesh ) will free all storage for any valid mesh.
*
* tessMeshZapFace( fZap ) destroys a face and removes it from the
* global face list.  All edges of fZap will have a NULL pointer as their
* left face.  Any edges which also have a NULL pointer as their right face
* are deleted entirely (along with any isolated vertices this produces).
* An entire mesh can be deleted by zapping its faces, one at a time,
* in any order.  Zapped faces cannot be used in further mesh operations!
*
* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
*/

TESSmesh.prototype = {
  /* MakeEdge creates a new pair of half-edges which form their own loop.
  * No vertex or face structures are allocated, but these must be assigned
  * before the current edge operation is completed.
  */
  //static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )
  makeEdge_: function makeEdge_(eNext) {
    var e = new TESShalfEdge(0);
    var eSym = new TESShalfEdge(1);
    /* Make sure eNext points to the first edge of the edge pair */

    if (eNext.Sym.side < eNext.side) {
      eNext = eNext.Sym;
    }
    /* Insert in circular doubly-linked list before eNext.
    * Note that the prev pointer is stored in Sym->next.
    */


    var ePrev = eNext.Sym.next;
    eSym.next = ePrev;
    ePrev.Sym.next = e;
    e.next = eNext;
    eNext.Sym.next = eSym;
    e.Sym = eSym;
    e.Onext = e;
    e.Lnext = eSym;
    e.Org = null;
    e.Lface = null;
    e.winding = 0;
    e.activeRegion = null;
    eSym.Sym = e;
    eSym.Onext = eSym;
    eSym.Lnext = e;
    eSym.Org = null;
    eSym.Lface = null;
    eSym.winding = 0;
    eSym.activeRegion = null;
    return e;
  },

  /* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
  * CS348a notes (see mesh.h).  Basically it modifies the mesh so that
  * a->Onext and b->Onext are exchanged.  This can have various effects
  * depending on whether a and b belong to different face or vertex rings.
  * For more explanation see tessMeshSplice() below.
  */
  // static void Splice( TESShalfEdge *a, TESShalfEdge *b )
  splice_: function splice_(a, b) {
    var aOnext = a.Onext;
    var bOnext = b.Onext;
    aOnext.Sym.Lnext = b;
    bOnext.Sym.Lnext = a;
    a.Onext = bOnext;
    b.Onext = aOnext;
  },

  /* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the
  * origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
  * a place to insert the new vertex in the global vertex list.  We insert
  * the new vertex *before* vNext so that algorithms which walk the vertex
  * list will not see the newly created vertices.
  */
  //static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )
  makeVertex_: function makeVertex_(newVertex, eOrig, vNext) {
    var vNew = newVertex;
    assert(vNew !== null);
    /* insert in circular doubly-linked list before vNext */

    var vPrev = vNext.prev;
    vNew.prev = vPrev;
    vPrev.next = vNew;
    vNew.next = vNext;
    vNext.prev = vNew;
    vNew.anEdge = eOrig;
    /* leave coords, s, t undefined */

    /* fix other edges on this vertex loop */

    var e = eOrig;

    do {
      e.Org = vNew;
      e = e.Onext;
    } while (e !== eOrig);
  },

  /* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left
  * face of all edges in the face loop to which eOrig belongs.  "fNext" gives
  * a place to insert the new face in the global face list.  We insert
  * the new face *before* fNext so that algorithms which walk the face
  * list will not see the newly created faces.
  */
  // static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )
  makeFace_: function makeFace_(newFace, eOrig, fNext) {
    var fNew = newFace;
    assert(fNew !== null);
    /* insert in circular doubly-linked list before fNext */

    var fPrev = fNext.prev;
    fNew.prev = fPrev;
    fPrev.next = fNew;
    fNew.next = fNext;
    fNext.prev = fNew;
    fNew.anEdge = eOrig;
    fNew.trail = null;
    fNew.marked = false;
    /* The new face is marked "inside" if the old one was.  This is a
    * convenience for the common case where a face has been split in two.
    */

    fNew.inside = fNext.inside;
    /* fix other edges on this face loop */

    var e = eOrig;

    do {
      e.Lface = fNew;
      e = e.Lnext;
    } while (e !== eOrig);
  },

  /* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
  * and removes from the global edge list.
  */
  //static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )
  killEdge_: function killEdge_(eDel) {
    /* Half-edges are allocated in pairs, see EdgePair above */
    if (eDel.Sym.side < eDel.side) {
      eDel = eDel.Sym;
    }
    /* delete from circular doubly-linked list */


    var eNext = eDel.next;
    var ePrev = eDel.Sym.next;
    eNext.Sym.next = ePrev;
    ePrev.Sym.next = eNext;
  },

  /* KillVertex( vDel ) destroys a vertex and removes it from the global
  * vertex list.  It updates the vertex loop to point to a given new vertex.
  */
  //static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )
  killVertex_: function killVertex_(vDel, newOrg) {
    var eStart = vDel.anEdge;
    /* change the origin of all affected edges */

    var e = eStart;

    do {
      e.Org = newOrg;
      e = e.Onext;
    } while (e !== eStart);
    /* delete from circular doubly-linked list */


    var vPrev = vDel.prev;
    var vNext = vDel.next;
    vNext.prev = vPrev;
    vPrev.next = vNext;
  },

  /* KillFace( fDel ) destroys a face and removes it from the global face
  * list.  It updates the face loop to point to a given new face.
  */
  //static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )
  killFace_: function killFace_(fDel, newLface) {
    var eStart = fDel.anEdge;
    /* change the left face of all affected edges */

    var e = eStart;

    do {
      e.Lface = newLface;
      e = e.Lnext;
    } while (e !== eStart);
    /* delete from circular doubly-linked list */


    var fPrev = fDel.prev;
    var fNext = fDel.next;
    fNext.prev = fPrev;
    fPrev.next = fNext;
  },

  /****************** Basic Edge Operations **********************/

  /* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).
  * The loop consists of the two new half-edges.
  */
  //TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )
  makeEdge: function makeEdge() {
    var newVertex1 = new TESSvertex();
    var newVertex2 = new TESSvertex();
    var newFace = new TESSface();
    var e = this.makeEdge_(this.eHead);
    this.makeVertex_(newVertex1, e, this.vHead);
    this.makeVertex_(newVertex2, e.Sym, this.vHead);
    this.makeFace_(newFace, e, this.fHead);
    return e;
  },

  /* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
  * mesh connectivity and topology.  It changes the mesh so that
  *	eOrg->Onext <- OLD( eDst->Onext )
  *	eDst->Onext <- OLD( eOrg->Onext )
  * where OLD(...) means the value before the meshSplice operation.
  *
  * This can have two effects on the vertex structure:
  *  - if eOrg->Org != eDst->Org, the two vertices are merged together
  *  - if eOrg->Org == eDst->Org, the origin is split into two vertices
  * In both cases, eDst->Org is changed and eOrg->Org is untouched.
  *
  * Similarly (and independently) for the face structure,
  *  - if eOrg->Lface == eDst->Lface, one loop is split into two
  *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
  * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
  *
  * Some special cases:
  * If eDst == eOrg, the operation has no effect.
  * If eDst == eOrg->Lnext, the new face will have a single edge.
  * If eDst == eOrg->Lprev, the old face will have a single edge.
  * If eDst == eOrg->Onext, the new vertex will have a single edge.
  * If eDst == eOrg->Oprev, the old vertex will have a single edge.
  */
  //int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )
  splice: function splice(eOrg, eDst) {
    var joiningLoops = false;
    var joiningVertices = false;
    if (eOrg === eDst) return;

    if (eDst.Org !== eOrg.Org) {
      /* We are merging two disjoint vertices -- destroy eDst->Org */
      joiningVertices = true;
      this.killVertex_(eDst.Org, eOrg.Org);
    }

    if (eDst.Lface !== eOrg.Lface) {
      /* We are connecting two disjoint loops -- destroy eDst->Lface */
      joiningLoops = true;
      this.killFace_(eDst.Lface, eOrg.Lface);
    }
    /* Change the edge structure */


    this.splice_(eDst, eOrg);

    if (!joiningVertices) {
      var newVertex = new TESSvertex();
      /* We split one vertex into two -- the new vertex is eDst->Org.
      * Make sure the old vertex points to a valid half-edge.
      */

      this.makeVertex_(newVertex, eDst, eOrg.Org);
      eOrg.Org.anEdge = eOrg;
    }

    if (!joiningLoops) {
      var newFace = new TESSface();
      /* We split one loop into two -- the new loop is eDst->Lface.
      * Make sure the old face points to a valid half-edge.
      */

      this.makeFace_(newFace, eDst, eOrg.Lface);
      eOrg.Lface.anEdge = eOrg;
    }
  },

  /* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
  * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
  * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
  * the newly created loop will contain eDel->Dst.  If the deletion of eDel
  * would create isolated vertices, those are deleted as well.
  *
  * This function could be implemented as two calls to tessMeshSplice
  * plus a few calls to memFree, but this would allocate and delete
  * unnecessary vertices and faces.
  */
  //int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )
  delete: function _delete(eDel) {
    var eDelSym = eDel.Sym;
    var joiningLoops = false;
    /* First step: disconnect the origin vertex eDel->Org.  We make all
    * changes to get a consistent mesh in this "intermediate" state.
    */

    if (eDel.Lface !== eDel.Rface) {
      /* We are joining two loops into one -- remove the left face */
      joiningLoops = true;
      this.killFace_(eDel.Lface, eDel.Rface);
    }

    if (eDel.Onext === eDel) {
      this.killVertex_(eDel.Org, null);
    } else {
      /* Make sure that eDel->Org and eDel->Rface point to valid half-edges */
      eDel.Rface.anEdge = eDel.Oprev;
      eDel.Org.anEdge = eDel.Onext;
      this.splice_(eDel, eDel.Oprev);

      if (!joiningLoops) {
        var newFace = new TESSface();
        /* We are splitting one loop into two -- create a new loop for eDel. */

        this.makeFace_(newFace, eDel, eDel.Lface);
      }
    }
    /* Claim: the mesh is now in a consistent state, except that eDel->Org
    * may have been deleted.  Now we disconnect eDel->Dst.
    */


    if (eDelSym.Onext === eDelSym) {
      this.killVertex_(eDelSym.Org, null);
      this.killFace_(eDelSym.Lface, null);
    } else {
      /* Make sure that eDel->Dst and eDel->Lface point to valid half-edges */
      eDel.Lface.anEdge = eDelSym.Oprev;
      eDelSym.Org.anEdge = eDelSym.Onext;
      this.splice_(eDelSym, eDelSym.Oprev);
    }
    /* Any isolated vertices or faces have already been freed. */


    this.killEdge_(eDel);
  },

  /******************** Other Edge Operations **********************/

  /* All these routines can be implemented with the basic edge
  * operations above.  They are provided for convenience and efficiency.
  */

  /* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
  * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
  * eOrg and eNew will have the same left face.
  */
  // TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );
  addEdgeVertex: function addEdgeVertex(eOrg) {
    var eNew = this.makeEdge_(eOrg);
    var eNewSym = eNew.Sym;
    /* Connect the new edge appropriately */

    this.splice_(eNew, eOrg.Lnext);
    /* Set the vertex and face information */

    eNew.Org = eOrg.Dst;
    var newVertex = new TESSvertex();
    this.makeVertex_(newVertex, eNewSym, eNew.Org);
    eNew.Lface = eNewSym.Lface = eOrg.Lface;
    return eNew;
  },

  /* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
  * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
  * eOrg and eNew will have the same left face.
  */
  // TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );
  splitEdge: function splitEdge(eOrg, eDst) {
    var tempHalfEdge = this.addEdgeVertex(eOrg);
    var eNew = tempHalfEdge.Sym;
    /* Disconnect eOrg from eOrg->Dst and connect it to eNew->Org */

    this.splice_(eOrg.Sym, eOrg.Sym.Oprev);
    this.splice_(eOrg.Sym, eNew);
    /* Set the vertex and face information */

    eOrg.Dst = eNew.Org;
    eNew.Dst.anEdge = eNew.Sym;
    /* may have pointed to eOrg->Sym */

    eNew.Rface = eOrg.Rface;
    eNew.winding = eOrg.winding;
    /* copy old winding information */

    eNew.Sym.winding = eOrg.Sym.winding;
    return eNew;
  },

  /* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
  * to eDst->Org, and returns the corresponding half-edge eNew.
  * If eOrg->Lface == eDst->Lface, this splits one loop into two,
  * and the newly created loop is eNew->Lface.  Otherwise, two disjoint
  * loops are merged into one, and the loop eDst->Lface is destroyed.
  *
  * If (eOrg == eDst), the new face will have only two edges.
  * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
  * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
  */
  // TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );
  connect: function connect(eOrg, eDst) {
    var joiningLoops = false;
    var eNew = this.makeEdge_(eOrg);
    var eNewSym = eNew.Sym;

    if (eDst.Lface !== eOrg.Lface) {
      /* We are connecting two disjoint loops -- destroy eDst->Lface */
      joiningLoops = true;
      this.killFace_(eDst.Lface, eOrg.Lface);
    }
    /* Connect the new edge appropriately */


    this.splice_(eNew, eOrg.Lnext);
    this.splice_(eNewSym, eDst);
    /* Set the vertex and face information */

    eNew.Org = eOrg.Dst;
    eNewSym.Org = eDst.Org;
    eNew.Lface = eNewSym.Lface = eOrg.Lface;
    /* Make sure the old face points to a valid half-edge */

    eOrg.Lface.anEdge = eNewSym;

    if (!joiningLoops) {
      var newFace = new TESSface();
      /* We split one loop into two -- the new loop is eNew->Lface */

      this.makeFace_(newFace, eNew, eOrg.Lface);
    }

    return eNew;
  },

  /* tessMeshZapFace( fZap ) destroys a face and removes it from the
  * global face list.  All edges of fZap will have a NULL pointer as their
  * left face.  Any edges which also have a NULL pointer as their right face
  * are deleted entirely (along with any isolated vertices this produces).
  * An entire mesh can be deleted by zapping its faces, one at a time,
  * in any order.  Zapped faces cannot be used in further mesh operations!
  */
  zapFace: function zapFace(fZap) {
    var eStart = fZap.anEdge;
    var e, eNext, eSym;
    var fPrev, fNext;
    /* walk around face, deleting edges whose right face is also NULL */

    eNext = eStart.Lnext;

    do {
      e = eNext;
      eNext = e.Lnext;
      e.Lface = null;

      if (e.Rface === null) {
        /* delete the edge -- see TESSmeshDelete above */
        if (e.Onext === e) {
          this.killVertex_(e.Org, null);
        } else {
          /* Make sure that e->Org points to a valid half-edge */
          e.Org.anEdge = e.Onext;
          this.splice_(e, e.Oprev);
        }

        eSym = e.Sym;

        if (eSym.Onext === eSym) {
          this.killVertex_(eSym.Org, null);
        } else {
          /* Make sure that eSym->Org points to a valid half-edge */
          eSym.Org.anEdge = eSym.Onext;
          this.splice_(eSym, eSym.Oprev);
        }

        this.killEdge_(e);
      }
    } while (e != eStart);
    /* delete from circular doubly-linked list */


    fPrev = fZap.prev;
    fNext = fZap.next;
    fNext.prev = fPrev;
    fPrev.next = fNext;
  },
  countFaceVerts_: function countFaceVerts_(f) {
    var eCur = f.anEdge;
    var n = 0;

    do {
      n++;
      eCur = eCur.Lnext;
    } while (eCur !== f.anEdge);

    return n;
  },
  //int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )
  mergeConvexFaces: function mergeConvexFaces(maxVertsPerFace) {
    var f;
    var eCur, eNext, eSym;
    var vStart;
    var curNv, symNv;

    for (f = this.fHead.next; f !== this.fHead; f = f.next) {
      // Skip faces which are outside the result.
      if (!f.inside) continue;
      eCur = f.anEdge;
      vStart = eCur.Org;

      while (true) {
        eNext = eCur.Lnext;
        eSym = eCur.Sym; // Try to merge if the neighbour face is valid.

        if (eSym && eSym.Lface && eSym.Lface.inside) {
          // Try to merge the neighbour faces if the resulting polygons
          // does not exceed maximum number of vertices.
          curNv = this.countFaceVerts_(f);
          symNv = this.countFaceVerts_(eSym.Lface);

          if (curNv + symNv - 2 <= maxVertsPerFace) {
            // Merge if the resulting poly is convex.
            if (Geom.vertCCW(eCur.Lprev.Org, eCur.Org, eSym.Lnext.Lnext.Org) && Geom.vertCCW(eSym.Lprev.Org, eSym.Org, eCur.Lnext.Lnext.Org)) {
              eNext = eSym.Lnext;
              this.delete(eSym);
              eCur = null;
              eSym = null;
            }
          }
        }

        if (eCur && eCur.Lnext.Org === vStart) break; // Continue to next edge.

        eCur = eNext;
      }
    }

    return true;
  },

  /* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
  */
  check: function check() {
    var fHead = this.fHead;
    var vHead = this.vHead;
    var eHead = this.eHead;
    var f, fPrev, v, vPrev, e, ePrev;
    fPrev = fHead;

    for (fPrev = fHead; (f = fPrev.next) !== fHead; fPrev = f) {
      assert(f.prev === fPrev);
      e = f.anEdge;

      do {
        assert(e.Sym !== e);
        assert(e.Sym.Sym === e);
        assert(e.Lnext.Onext.Sym === e);
        assert(e.Onext.Sym.Lnext === e);
        assert(e.Lface === f);
        e = e.Lnext;
      } while (e !== f.anEdge);
    }

    assert(f.prev === fPrev && f.anEdge === null);
    vPrev = vHead;

    for (vPrev = vHead; (v = vPrev.next) !== vHead; vPrev = v) {
      assert(v.prev === vPrev);
      e = v.anEdge;

      do {
        assert(e.Sym !== e);
        assert(e.Sym.Sym === e);
        assert(e.Lnext.Onext.Sym === e);
        assert(e.Onext.Sym.Lnext === e);
        assert(e.Org === v);
        e = e.Onext;
      } while (e !== v.anEdge);
    }

    assert(v.prev === vPrev && v.anEdge === null);
    ePrev = eHead;

    for (ePrev = eHead; (e = ePrev.next) !== eHead; ePrev = e) {
      assert(e.Sym.next === ePrev.Sym);
      assert(e.Sym !== e);
      assert(e.Sym.Sym === e);
      assert(e.Org !== null);
      assert(e.Dst !== null);
      assert(e.Lnext.Onext.Sym === e);
      assert(e.Onext.Sym.Lnext === e);
    }

    assert(e.Sym.next === ePrev.Sym && e.Sym === this.eHeadSym && e.Sym.Sym === e && e.Org === null && e.Dst === null && e.Lface === null && e.Rface === null);
  }
};

Geom.vertEq = function (u, v) {
  return u.s === v.s && u.t === v.t;
};
/* Returns TRUE if u is lexicographically <= v. */


Geom.vertLeq = function (u, v) {
  return u.s < v.s || u.s === v.s && u.t <= v.t;
};
/* Versions of VertLeq, EdgeSign, EdgeEval with s and t transposed. */


Geom.transLeq = function (u, v) {
  return u.t < v.t || u.t === v.t && u.s <= v.s;
};

Geom.edgeGoesLeft = function (e) {
  return Geom.vertLeq(e.Dst, e.Org);
};

Geom.edgeGoesRight = function (e) {
  return Geom.vertLeq(e.Org, e.Dst);
};

Geom.vertL1dist = function (u, v) {
  return Math.abs(u.s - v.s) + Math.abs(u.t - v.t);
}; //TESSreal tesedgeEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )


Geom.edgeEval = function (u, v, w) {
  /* Given three vertices u,v,w such that VertLeq(u,v) && VertLeq(v,w),
  * evaluates the t-coord of the edge uw at the s-coord of the vertex v.
  * Returns v->t - (uw)(v->s), ie. the signed distance from uw to v.
  * If uw is vertical (and thus passes thru v), the result is zero.
  *
  * The calculation is extremely accurate and stable, even when v
  * is very close to u or w.  In particular if we set v->t = 0 and
  * let r be the negated result (this evaluates (uw)(v->s)), then
  * r is guaranteed to satisfy MIN(u->t,w->t) <= r <= MAX(u->t,w->t).
  */
  assert(Geom.vertLeq(u, v) && Geom.vertLeq(v, w));
  var gapL = v.s - u.s;
  var gapR = w.s - v.s;

  if (gapL + gapR > 0.0) {
    if (gapL < gapR) {
      return v.t - u.t + (u.t - w.t) * (gapL / (gapL + gapR));
    } else {
      return v.t - w.t + (w.t - u.t) * (gapR / (gapL + gapR));
    }
  }
  /* vertical line */


  return 0.0;
}; //TESSreal tesedgeSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )


Geom.edgeSign = function (u, v, w) {
  /* Returns a number whose sign matches EdgeEval(u,v,w) but which
  * is cheaper to evaluate.  Returns > 0, == 0 , or < 0
  * as v is above, on, or below the edge uw.
  */
  assert(Geom.vertLeq(u, v) && Geom.vertLeq(v, w));
  var gapL = v.s - u.s;
  var gapR = w.s - v.s;

  if (gapL + gapR > 0.0) {
    return (v.t - w.t) * gapL + (v.t - u.t) * gapR;
  }
  /* vertical line */


  return 0.0;
};
/***********************************************************************
* Define versions of EdgeSign, EdgeEval with s and t transposed.
*/
//TESSreal testransEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )


Geom.transEval = function (u, v, w) {
  /* Given three vertices u,v,w such that TransLeq(u,v) && TransLeq(v,w),
  * evaluates the t-coord of the edge uw at the s-coord of the vertex v.
  * Returns v->s - (uw)(v->t), ie. the signed distance from uw to v.
  * If uw is vertical (and thus passes thru v), the result is zero.
  *
  * The calculation is extremely accurate and stable, even when v
  * is very close to u or w.  In particular if we set v->s = 0 and
  * let r be the negated result (this evaluates (uw)(v->t)), then
  * r is guaranteed to satisfy MIN(u->s,w->s) <= r <= MAX(u->s,w->s).
  */
  assert(Geom.transLeq(u, v) && Geom.transLeq(v, w));
  var gapL = v.t - u.t;
  var gapR = w.t - v.t;

  if (gapL + gapR > 0.0) {
    if (gapL < gapR) {
      return v.s - u.s + (u.s - w.s) * (gapL / (gapL + gapR));
    } else {
      return v.s - w.s + (w.s - u.s) * (gapR / (gapL + gapR));
    }
  }
  /* vertical line */


  return 0.0;
}; //TESSreal testransSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )


Geom.transSign = function (u, v, w) {
  /* Returns a number whose sign matches TransEval(u,v,w) but which
  * is cheaper to evaluate.  Returns > 0, == 0 , or < 0
  * as v is above, on, or below the edge uw.
  */
  assert(Geom.transLeq(u, v) && Geom.transLeq(v, w));
  var gapL = v.t - u.t;
  var gapR = w.t - v.t;

  if (gapL + gapR > 0.0) {
    return (v.s - w.s) * gapL + (v.s - u.s) * gapR;
  }
  /* vertical line */


  return 0.0;
}; //int tesvertCCW( TESSvertex *u, TESSvertex *v, TESSvertex *w )


Geom.vertCCW = function (u, v, w) {
  /* For almost-degenerate situations, the results are not reliable.
  * Unless the floating-point arithmetic can be performed without
  * rounding errors, *any* implementation will give incorrect results
  * on some degenerate inputs, so the client must have some way to
  * handle this situation.
  */
  return u.s * (v.t - w.t) + v.s * (w.t - u.t) + w.s * (u.t - v.t) >= 0.0;
};
/* Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),
* or (x+y)/2 if a==b==0.  It requires that a,b >= 0, and enforces
* this in the rare case that one argument is slightly negative.
* The implementation is extremely stable numerically.
* In particular it guarantees that the result r satisfies
* MIN(x,y) <= r <= MAX(x,y), and the results are very accurate
* even when a and b differ greatly in magnitude.
*/


Geom.interpolate = function (a, x, b, y) {
  return a = a < 0 ? 0 : a, b = b < 0 ? 0 : b, a <= b ? b === 0 ? (x + y) / 2 : x + (y - x) * (a / (a + b)) : y + (x - y) * (b / (a + b));
};
/*
#ifndef FOR_TRITE_TEST_PROGRAM
#define Interpolate(a,x,b,y)	RealInterpolate(a,x,b,y)
#else

// Claim: the ONLY property the sweep algorithm relies on is that
// MIN(x,y) <= r <= MAX(x,y).  This is a nasty way to test that.
#include <stdlib.h>
extern int RandomInterpolate;

double Interpolate( double a, double x, double b, double y)
{
  printf("*********************%d\n",RandomInterpolate);
  if( RandomInterpolate ) {
    a = 1.2 * drand48() - 0.1;
    a = (a < 0) ? 0 : ((a > 1) ? 1 : a);
    b = 1.0 - a;
  }
  return RealInterpolate(a,x,b,y);
}
#endif*/


Geom.intersect = function (o1, d1, o2, d2, v) {
  /* Given edges (o1,d1) and (o2,d2), compute their point of intersection.
  * The computed point is guaranteed to lie in the intersection of the
  * bounding rectangles defined by each edge.
  */
  var z1, z2;
  var t;
  /* This is certainly not the most efficient way to find the intersection
  * of two line segments, but it is very numerically stable.
  *
  * Strategy: find the two middle vertices in the VertLeq ordering,
  * and interpolate the intersection s-value from these.  Then repeat
  * using the TransLeq ordering to find the intersection t-value.
  */

  if (!Geom.vertLeq(o1, d1)) {
    t = o1;
    o1 = d1;
    d1 = t;
  } //swap( o1, d1 ); }


  if (!Geom.vertLeq(o2, d2)) {
    t = o2;
    o2 = d2;
    d2 = t;
  } //swap( o2, d2 ); }


  if (!Geom.vertLeq(o1, o2)) {
    t = o1;
    o1 = o2;
    o2 = t;
    t = d1;
    d1 = d2;
    d2 = t;
  } //swap( o1, o2 ); swap( d1, d2 ); }


  if (!Geom.vertLeq(o2, d1)) {
    /* Technically, no intersection -- do our best */
    v.s = (o2.s + d1.s) / 2;
  } else if (Geom.vertLeq(d1, d2)) {
    /* Interpolate between o2 and d1 */
    z1 = Geom.edgeEval(o1, o2, d1);
    z2 = Geom.edgeEval(o2, d1, d2);

    if (z1 + z2 < 0) {
      z1 = -z1;
      z2 = -z2;
    }

    v.s = Geom.interpolate(z1, o2.s, z2, d1.s);
  } else {
    /* Interpolate between o2 and d2 */
    z1 = Geom.edgeSign(o1, o2, d1);
    z2 = -Geom.edgeSign(o1, d2, d1);

    if (z1 + z2 < 0) {
      z1 = -z1;
      z2 = -z2;
    }

    v.s = Geom.interpolate(z1, o2.s, z2, d2.s);
  }
  /* Now repeat the process for t */


  if (!Geom.transLeq(o1, d1)) {
    t = o1;
    o1 = d1;
    d1 = t;
  } //swap( o1, d1 ); }


  if (!Geom.transLeq(o2, d2)) {
    t = o2;
    o2 = d2;
    d2 = t;
  } //swap( o2, d2 ); }


  if (!Geom.transLeq(o1, o2)) {
    t = o1;
    o1 = o2;
    o2 = t;
    t = d1;
    d1 = d2;
    d2 = t;
  } //swap( o1, o2 ); swap( d1, d2 ); }


  if (!Geom.transLeq(o2, d1)) {
    /* Technically, no intersection -- do our best */
    v.t = (o2.t + d1.t) / 2;
  } else if (Geom.transLeq(d1, d2)) {
    /* Interpolate between o2 and d1 */
    z1 = Geom.transEval(o1, o2, d1);
    z2 = Geom.transEval(o2, d1, d2);

    if (z1 + z2 < 0) {
      z1 = -z1;
      z2 = -z2;
    }

    v.t = Geom.interpolate(z1, o2.t, z2, d1.t);
  } else {
    /* Interpolate between o2 and d2 */
    z1 = Geom.transSign(o1, o2, d1);
    z2 = -Geom.transSign(o1, d2, d1);

    if (z1 + z2 < 0) {
      z1 = -z1;
      z2 = -z2;
    }

    v.t = Geom.interpolate(z1, o2.t, z2, d2.t);
  }
};

function DictNode() {
  this.key = null;
  this.next = null;
  this.prev = null;
}

;

function Dict(frame, leq) {
  this.head = new DictNode();
  this.head.next = this.head;
  this.head.prev = this.head;
  this.frame = frame;
  this.leq = leq;
}

;
Dict.prototype = {
  min: function min() {
    return this.head.next;
  },
  max: function max() {
    return this.head.prev;
  },
  insert: function insert(k) {
    return this.insertBefore(this.head, k);
  },
  search: function search(key) {
    /* Search returns the node with the smallest key greater than or equal
    * to the given key.  If there is no such key, returns a node whose
    * key is NULL.  Similarly, Succ(Max(d)) has a NULL key, etc.
    */
    var node = this.head;

    do {
      node = node.next;
    } while (node.key !== null && !this.leq(this.frame, key, node.key));

    return node;
  },
  insertBefore: function insertBefore(node, key) {
    do {
      node = node.prev;
    } while (node.key !== null && !this.leq(this.frame, node.key, key));

    var newNode = new DictNode();
    newNode.key = key;
    newNode.next = node.next;
    node.next.prev = newNode;
    newNode.prev = node;
    node.next = newNode;
    return newNode;
  },
  delete: function _delete(node) {
    node.next.prev = node.prev;
    node.prev.next = node.next;
  }
};

function PQnode() {
  this.handle = null;
}

function PQhandleElem() {
  this.key = null;
  this.node = null;
}

function PriorityQ(size, leq) {
  this.size = 0;
  this.max = size;
  this.nodes = [];
  this.nodes.length = size + 1;
  var i;

  for (i = 0; i < this.nodes.length; i++) {
    this.nodes[i] = new PQnode();
  }

  this.handles = [];
  this.handles.length = size + 1;

  for (i = 0; i < this.handles.length; i++) {
    this.handles[i] = new PQhandleElem();
  }

  this.initialized = false;
  this.freeList = 0;
  this.leq = leq;
  this.nodes[1].handle = 1;
  /* so that Minimum() returns NULL */

  this.handles[1].key = null;
}

;
PriorityQ.prototype = {
  floatDown_: function floatDown_(curr) {
    var n = this.nodes;
    var h = this.handles;
    var hCurr, hChild;
    var child;
    hCurr = n[curr].handle;

    for (;;) {
      child = curr << 1;

      if (child < this.size && this.leq(h[n[child + 1].handle].key, h[n[child].handle].key)) {
        ++child;
      }

      assert(child <= this.max);
      hChild = n[child].handle;

      if (child > this.size || this.leq(h[hCurr].key, h[hChild].key)) {
        n[curr].handle = hCurr;
        h[hCurr].node = curr;
        break;
      }

      n[curr].handle = hChild;
      h[hChild].node = curr;
      curr = child;
    }
  },
  floatUp_: function floatUp_(curr) {
    var n = this.nodes;
    var h = this.handles;
    var hCurr, hParent;
    var parent;
    hCurr = n[curr].handle;

    for (;;) {
      parent = curr >> 1;
      hParent = n[parent].handle;

      if (parent === 0 || this.leq(h[hParent].key, h[hCurr].key)) {
        n[curr].handle = hCurr;
        h[hCurr].node = curr;
        break;
      }

      n[curr].handle = hParent;
      h[hParent].node = curr;
      curr = parent;
    }
  },
  init: function init() {
    /* This method of building a heap is O(n), rather than O(n lg n). */
    for (var i = this.size; i >= 1; --i) {
      this.floatDown_(i);
    }

    this.initialized = true;
  },
  min: function min() {
    return this.handles[this.nodes[1].handle].key;
  },

  /* really pqHeapInsert */

  /* returns INV_HANDLE iff out of memory */
  //PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )
  insert: function insert(keyNew) {
    var curr;
    var free;
    curr = ++this.size;

    if (curr * 2 > this.max) {
      this.max *= 2;
      var i;
      var s;
      s = this.nodes.length;
      this.nodes.length = this.max + 1;

      for (i = s; i < this.nodes.length; i++) {
        this.nodes[i] = new PQnode();
      }

      s = this.handles.length;
      this.handles.length = this.max + 1;

      for (i = s; i < this.handles.length; i++) {
        this.handles[i] = new PQhandleElem();
      }
    }

    if (this.freeList === 0) {
      free = curr;
    } else {
      free = this.freeList;
      this.freeList = this.handles[free].node;
    }

    this.nodes[curr].handle = free;
    this.handles[free].node = curr;
    this.handles[free].key = keyNew;

    if (this.initialized) {
      this.floatUp_(curr);
    }

    return free;
  },
  //PQkey pqHeapExtractMin( PriorityQHeap *pq )
  extractMin: function extractMin() {
    var n = this.nodes;
    var h = this.handles;
    var hMin = n[1].handle;
    var min = h[hMin].key;

    if (this.size > 0) {
      n[1].handle = n[this.size].handle;
      h[n[1].handle].node = 1;
      h[hMin].key = null;
      h[hMin].node = this.freeList;
      this.freeList = hMin;
      --this.size;

      if (this.size > 0) {
        this.floatDown_(1);
      }
    }

    return min;
  },
  delete: function _delete(hCurr) {
    var n = this.nodes;
    var h = this.handles;
    var curr;
    assert(hCurr >= 1 && hCurr <= this.max && h[hCurr].key !== null);
    curr = h[hCurr].node;
    n[curr].handle = n[this.size].handle;
    h[n[curr].handle].node = curr;
    --this.size;

    if (curr <= this.size) {
      if (curr <= 1 || this.leq(h[n[curr >> 1].handle].key, h[n[curr].handle].key)) {
        this.floatDown_(curr);
      } else {
        this.floatUp_(curr);
      }
    }

    h[hCurr].key = null;
    h[hCurr].node = this.freeList;
    this.freeList = hCurr;
  }
};
/* For each pair of adjacent edges crossing the sweep line, there is
* an ActiveRegion to represent the region between them.  The active
* regions are kept in sorted order in a dynamic dictionary.  As the
* sweep line crosses each vertex, we update the affected regions.
*/

function ActiveRegion() {
  this.eUp = null;
  /* upper edge, directed right to left */

  this.nodeUp = null;
  /* dictionary node corresponding to eUp */

  this.windingNumber = 0;
  /* used to determine which regions are
  * inside the polygon */

  this.inside = false;
  /* is this region inside the polygon? */

  this.sentinel = false;
  /* marks fake edges at t = +/-infinity */

  this.dirty = false;
  /* marks regions where the upper or lower
  * edge has changed, but we haven't checked
  * whether they intersect yet */

  this.fixUpperEdge = false;
  /* marks temporary edges introduced when
  * we process a "right vertex" (one without
  * any edges leaving to the right) */
}

;
var Sweep = {};

Sweep.regionBelow = function (r) {
  return r.nodeUp.prev.key;
};

Sweep.regionAbove = function (r) {
  return r.nodeUp.next.key;
};

Sweep.debugEvent = function (tess) {// empty
};
/*
* Invariants for the Edge Dictionary.
* - each pair of adjacent edges e2=Succ(e1) satisfies EdgeLeq(e1,e2)
*   at any valid location of the sweep event
* - if EdgeLeq(e2,e1) as well (at any valid sweep event), then e1 and e2
*   share a common endpoint
* - for each e, e->Dst has been processed, but not e->Org
* - each edge e satisfies VertLeq(e->Dst,event) && VertLeq(event,e->Org)
*   where "event" is the current sweep line event.
* - no edge e has zero length
*
* Invariants for the Mesh (the processed portion).
* - the portion of the mesh left of the sweep line is a planar graph,
*   ie. there is *some* way to embed it in the plane
* - no processed edge has zero length
* - no two processed vertices have identical coordinates
* - each "inside" region is monotone, ie. can be broken into two chains
*   of monotonically increasing vertices according to VertLeq(v1,v2)
*   - a non-invariant: these chains may intersect (very slightly)
*
* Invariants for the Sweep.
* - if none of the edges incident to the event vertex have an activeRegion
*   (ie. none of these edges are in the edge dictionary), then the vertex
*   has only right-going edges.
* - if an edge is marked "fixUpperEdge" (it is a temporary edge introduced
*   by ConnectRightVertex), then it is the only right-going edge from
*   its associated vertex.  (This says that these edges exist only
*   when it is necessary.)
*/

/* When we merge two edges into one, we need to compute the combined
* winding of the new edge.
*/


Sweep.addWinding = function (eDst, eSrc) {
  eDst.winding += eSrc.winding;
  eDst.Sym.winding += eSrc.Sym.winding;
}; //static int EdgeLeq( TESStesselator *tess, ActiveRegion *reg1, ActiveRegion *reg2 )


Sweep.edgeLeq = function (tess, reg1, reg2) {
  /*
  * Both edges must be directed from right to left (this is the canonical
  * direction for the upper edge of each region).
  *
  * The strategy is to evaluate a "t" value for each edge at the
  * current sweep line position, given by tess->event.  The calculations
  * are designed to be very stable, but of course they are not perfect.
  *
  * Special case: if both edge destinations are at the sweep event,
  * we sort the edges by slope (they would otherwise compare equally).
  */
  var ev = tess.event;
  var t1, t2;
  var e1 = reg1.eUp;
  var e2 = reg2.eUp;

  if (e1.Dst === ev) {
    if (e2.Dst === ev) {
      /* Two edges right of the sweep line which meet at the sweep event.
      * Sort them by slope.
      */
      if (Geom.vertLeq(e1.Org, e2.Org)) {
        return Geom.edgeSign(e2.Dst, e1.Org, e2.Org) <= 0;
      }

      return Geom.edgeSign(e1.Dst, e2.Org, e1.Org) >= 0;
    }

    return Geom.edgeSign(e2.Dst, ev, e2.Org) <= 0;
  }

  if (e2.Dst === ev) {
    return Geom.edgeSign(e1.Dst, ev, e1.Org) >= 0;
  }
  /* General case - compute signed distance *from* e1, e2 to event */


  var t1 = Geom.edgeEval(e1.Dst, ev, e1.Org);
  var t2 = Geom.edgeEval(e2.Dst, ev, e2.Org);
  return t1 >= t2;
}; //static void DeleteRegion( TESStesselator *tess, ActiveRegion *reg )


Sweep.deleteRegion = function (tess, reg) {
  if (reg.fixUpperEdge) {
    /* It was created with zero winding number, so it better be
    * deleted with zero winding number (ie. it better not get merged
    * with a real edge).
    */
    assert(reg.eUp.winding === 0);
  }

  reg.eUp.activeRegion = null;
  tess.dict.delete(reg.nodeUp);
}; //static int FixUpperEdge( TESStesselator *tess, ActiveRegion *reg, TESShalfEdge *newEdge )


Sweep.fixUpperEdge = function (tess, reg, newEdge) {
  /*
  * Replace an upper edge which needs fixing (see ConnectRightVertex).
  */
  assert(reg.fixUpperEdge);
  tess.mesh.delete(reg.eUp);
  reg.fixUpperEdge = false;
  reg.eUp = newEdge;
  newEdge.activeRegion = reg;
}; //static ActiveRegion *TopLeftRegion( TESStesselator *tess, ActiveRegion *reg )


Sweep.topLeftRegion = function (tess, reg) {
  var org = reg.eUp.Org;
  var e;
  /* Find the region above the uppermost edge with the same origin */

  do {
    reg = Sweep.regionAbove(reg);
  } while (reg.eUp.Org === org);
  /* If the edge above was a temporary edge introduced by ConnectRightVertex,
  * now is the time to fix it.
  */


  if (reg.fixUpperEdge) {
    e = tess.mesh.connect(Sweep.regionBelow(reg).eUp.Sym, reg.eUp.Lnext);
    if (e === null) return null;
    Sweep.fixUpperEdge(tess, reg, e);
    reg = Sweep.regionAbove(reg);
  }

  return reg;
}; //static ActiveRegion *TopRightRegion( ActiveRegion *reg )


Sweep.topRightRegion = function (reg) {
  var dst = reg.eUp.Dst;
  /* Find the region above the uppermost edge with the same destination */

  do {
    reg = Sweep.regionAbove(reg);
  } while (reg.eUp.Dst === dst);

  return reg;
}; //static ActiveRegion *AddRegionBelow( TESStesselator *tess, ActiveRegion *regAbove, TESShalfEdge *eNewUp )


Sweep.addRegionBelow = function (tess, regAbove, eNewUp) {
  /*
  * Add a new active region to the sweep line, *somewhere* below "regAbove"
  * (according to where the new edge belongs in the sweep-line dictionary).
  * The upper edge of the new region will be "eNewUp".
  * Winding number and "inside" flag are not updated.
  */
  var regNew = new ActiveRegion();
  regNew.eUp = eNewUp;
  regNew.nodeUp = tess.dict.insertBefore(regAbove.nodeUp, regNew); //	if (regNew->nodeUp == NULL) longjmp(tess->env,1);

  regNew.fixUpperEdge = false;
  regNew.sentinel = false;
  regNew.dirty = false;
  eNewUp.activeRegion = regNew;
  return regNew;
}; //static int IsWindingInside( TESStesselator *tess, int n )


Sweep.isWindingInside = function (tess, n) {
  switch (tess.windingRule) {
    case Tess2.WINDING_ODD:
      return (n & 1) !== 0;

    case Tess2.WINDING_NONZERO:
      return n !== 0;

    case Tess2.WINDING_POSITIVE:
      return n > 0;

    case Tess2.WINDING_NEGATIVE:
      return n < 0;

    case Tess2.WINDING_ABS_GEQ_TWO:
      return n >= 2 || n <= -2;
  }

  assert(false);
  return false;
}; //static void ComputeWinding( TESStesselator *tess, ActiveRegion *reg )


Sweep.computeWinding = function (tess, reg) {
  reg.windingNumber = Sweep.regionAbove(reg).windingNumber + reg.eUp.winding;
  reg.inside = Sweep.isWindingInside(tess, reg.windingNumber);
}; //static void FinishRegion( TESStesselator *tess, ActiveRegion *reg )


Sweep.finishRegion = function (tess, reg) {
  /*
  * Delete a region from the sweep line.  This happens when the upper
  * and lower chains of a region meet (at a vertex on the sweep line).
  * The "inside" flag is copied to the appropriate mesh face (we could
  * not do this before -- since the structure of the mesh is always
  * changing, this face may not have even existed until now).
  */
  var e = reg.eUp;
  var f = e.Lface;
  f.inside = reg.inside;
  f.anEdge = e;
  /* optimization for tessMeshTessellateMonoRegion() */

  Sweep.deleteRegion(tess, reg);
}; //static TESShalfEdge *FinishLeftRegions( TESStesselator *tess, ActiveRegion *regFirst, ActiveRegion *regLast )


Sweep.finishLeftRegions = function (tess, regFirst, regLast) {
  /*
  * We are given a vertex with one or more left-going edges.  All affected
  * edges should be in the edge dictionary.  Starting at regFirst->eUp,
  * we walk down deleting all regions where both edges have the same
  * origin vOrg.  At the same time we copy the "inside" flag from the
  * active region to the face, since at this point each face will belong
  * to at most one region (this was not necessarily true until this point
  * in the sweep).  The walk stops at the region above regLast; if regLast
  * is NULL we walk as far as possible.  At the same time we relink the
  * mesh if necessary, so that the ordering of edges around vOrg is the
  * same as in the dictionary.
  */
  var e, ePrev;
  var reg = null;
  var regPrev = regFirst;
  var ePrev = regFirst.eUp;

  while (regPrev !== regLast) {
    regPrev.fixUpperEdge = false;
    /* placement was OK */

    reg = Sweep.regionBelow(regPrev);
    e = reg.eUp;

    if (e.Org != ePrev.Org) {
      if (!reg.fixUpperEdge) {
        /* Remove the last left-going edge.  Even though there are no further
        * edges in the dictionary with this origin, there may be further
        * such edges in the mesh (if we are adding left edges to a vertex
        * that has already been processed).  Thus it is important to call
        * FinishRegion rather than just DeleteRegion.
        */
        Sweep.finishRegion(tess, regPrev);
        break;
      }
      /* If the edge below was a temporary edge introduced by
      * ConnectRightVertex, now is the time to fix it.
      */


      e = tess.mesh.connect(ePrev.Lprev, e.Sym); //			if (e == NULL) longjmp(tess->env,1);

      Sweep.fixUpperEdge(tess, reg, e);
    }
    /* Relink edges so that ePrev->Onext == e */


    if (ePrev.Onext !== e) {
      tess.mesh.splice(e.Oprev, e);
      tess.mesh.splice(ePrev, e);
    }

    Sweep.finishRegion(tess, regPrev);
    /* may change reg->eUp */

    ePrev = reg.eUp;
    regPrev = reg;
  }

  return ePrev;
}; //static void AddRightEdges( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eFirst, TESShalfEdge *eLast, TESShalfEdge *eTopLeft, int cleanUp )


Sweep.addRightEdges = function (tess, regUp, eFirst, eLast, eTopLeft, cleanUp) {
  /*
  * Purpose: insert right-going edges into the edge dictionary, and update
  * winding numbers and mesh connectivity appropriately.  All right-going
  * edges share a common origin vOrg.  Edges are inserted CCW starting at
  * eFirst; the last edge inserted is eLast->Oprev.  If vOrg has any
  * left-going edges already processed, then eTopLeft must be the edge
  * such that an imaginary upward vertical segment from vOrg would be
  * contained between eTopLeft->Oprev and eTopLeft; otherwise eTopLeft
  * should be NULL.
  */
  var reg, regPrev;
  var e, ePrev;
  var firstTime = true;
  /* Insert the new right-going edges in the dictionary */

  e = eFirst;

  do {
    assert(Geom.vertLeq(e.Org, e.Dst));
    Sweep.addRegionBelow(tess, regUp, e.Sym);
    e = e.Onext;
  } while (e !== eLast);
  /* Walk *all* right-going edges from e->Org, in the dictionary order,
  * updating the winding numbers of each region, and re-linking the mesh
  * edges to match the dictionary ordering (if necessary).
  */


  if (eTopLeft === null) {
    eTopLeft = Sweep.regionBelow(regUp).eUp.Rprev;
  }

  regPrev = regUp;
  ePrev = eTopLeft;

  for (;;) {
    reg = Sweep.regionBelow(regPrev);
    e = reg.eUp.Sym;
    if (e.Org !== ePrev.Org) break;

    if (e.Onext !== ePrev) {
      /* Unlink e from its current position, and relink below ePrev */
      tess.mesh.splice(e.Oprev, e);
      tess.mesh.splice(ePrev.Oprev, e);
    }
    /* Compute the winding number and "inside" flag for the new regions */


    reg.windingNumber = regPrev.windingNumber - e.winding;
    reg.inside = Sweep.isWindingInside(tess, reg.windingNumber);
    /* Check for two outgoing edges with same slope -- process these
    * before any intersection tests (see example in tessComputeInterior).
    */

    regPrev.dirty = true;

    if (!firstTime && Sweep.checkForRightSplice(tess, regPrev)) {
      Sweep.addWinding(e, ePrev);
      Sweep.deleteRegion(tess, regPrev);
      tess.mesh.delete(ePrev);
    }

    firstTime = false;
    regPrev = reg;
    ePrev = e;
  }

  regPrev.dirty = true;
  assert(regPrev.windingNumber - e.winding === reg.windingNumber);

  if (cleanUp) {
    /* Check for intersections between newly adjacent edges. */
    Sweep.walkDirtyRegions(tess, regPrev);
  }
}; //static void SpliceMergeVertices( TESStesselator *tess, TESShalfEdge *e1, TESShalfEdge *e2 )


Sweep.spliceMergeVertices = function (tess, e1, e2) {
  /*
  * Two vertices with idential coordinates are combined into one.
  * e1->Org is kept, while e2->Org is discarded.
  */
  tess.mesh.splice(e1, e2);
}; //static void VertexWeights( TESSvertex *isect, TESSvertex *org, TESSvertex *dst, TESSreal *weights )


Sweep.vertexWeights = function (isect, org, dst) {
  /*
  * Find some weights which describe how the intersection vertex is
  * a linear combination of "org" and "dest".  Each of the two edges
  * which generated "isect" is allocated 50% of the weight; each edge
  * splits the weight between its org and dst according to the
  * relative distance to "isect".
  */
  var t1 = Geom.vertL1dist(org, isect);
  var t2 = Geom.vertL1dist(dst, isect);
  var w0 = 0.5 * t2 / (t1 + t2);
  var w1 = 0.5 * t1 / (t1 + t2);
  isect.coords[0] += w0 * org.coords[0] + w1 * dst.coords[0];
  isect.coords[1] += w0 * org.coords[1] + w1 * dst.coords[1];
  isect.coords[2] += w0 * org.coords[2] + w1 * dst.coords[2];
}; //static void GetIntersectData( TESStesselator *tess, TESSvertex *isect, TESSvertex *orgUp, TESSvertex *dstUp, TESSvertex *orgLo, TESSvertex *dstLo )


Sweep.getIntersectData = function (tess, isect, orgUp, dstUp, orgLo, dstLo) {
  /*
  * We've computed a new intersection point, now we need a "data" pointer
  * from the user so that we can refer to this new vertex in the
  * rendering callbacks.
  */
  isect.coords[0] = isect.coords[1] = isect.coords[2] = 0;
  isect.idx = -1;
  Sweep.vertexWeights(isect, orgUp, dstUp);
  Sweep.vertexWeights(isect, orgLo, dstLo);
}; //static int CheckForRightSplice( TESStesselator *tess, ActiveRegion *regUp )


Sweep.checkForRightSplice = function (tess, regUp) {
  /*
  * Check the upper and lower edge of "regUp", to make sure that the
  * eUp->Org is above eLo, or eLo->Org is below eUp (depending on which
  * origin is leftmost).
  *
  * The main purpose is to splice right-going edges with the same
  * dest vertex and nearly identical slopes (ie. we can't distinguish
  * the slopes numerically).  However the splicing can also help us
  * to recover from numerical errors.  For example, suppose at one
  * point we checked eUp and eLo, and decided that eUp->Org is barely
  * above eLo.  Then later, we split eLo into two edges (eg. from
  * a splice operation like this one).  This can change the result of
  * our test so that now eUp->Org is incident to eLo, or barely below it.
  * We must correct this condition to maintain the dictionary invariants.
  *
  * One possibility is to check these edges for intersection again
  * (ie. CheckForIntersect).  This is what we do if possible.  However
  * CheckForIntersect requires that tess->event lies between eUp and eLo,
  * so that it has something to fall back on when the intersection
  * calculation gives us an unusable answer.  So, for those cases where
  * we can't check for intersection, this routine fixes the problem
  * by just splicing the offending vertex into the other edge.
  * This is a guaranteed solution, no matter how degenerate things get.
  * Basically this is a combinatorial solution to a numerical problem.
  */
  var regLo = Sweep.regionBelow(regUp);
  var eUp = regUp.eUp;
  var eLo = regLo.eUp;

  if (Geom.vertLeq(eUp.Org, eLo.Org)) {
    if (Geom.edgeSign(eLo.Dst, eUp.Org, eLo.Org) > 0) return false;
    /* eUp->Org appears to be below eLo */

    if (!Geom.vertEq(eUp.Org, eLo.Org)) {
      /* Splice eUp->Org into eLo */
      tess.mesh.splitEdge(eLo.Sym);
      tess.mesh.splice(eUp, eLo.Oprev);
      regUp.dirty = regLo.dirty = true;
    } else if (eUp.Org !== eLo.Org) {
      /* merge the two vertices, discarding eUp->Org */
      tess.pq.delete(eUp.Org.pqHandle);
      Sweep.spliceMergeVertices(tess, eLo.Oprev, eUp);
    }
  } else {
    if (Geom.edgeSign(eUp.Dst, eLo.Org, eUp.Org) < 0) return false;
    /* eLo->Org appears to be above eUp, so splice eLo->Org into eUp */

    Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
    tess.mesh.splitEdge(eUp.Sym);
    tess.mesh.splice(eLo.Oprev, eUp);
  }

  return true;
}; //static int CheckForLeftSplice( TESStesselator *tess, ActiveRegion *regUp )


Sweep.checkForLeftSplice = function (tess, regUp) {
  /*
  * Check the upper and lower edge of "regUp", to make sure that the
  * eUp->Dst is above eLo, or eLo->Dst is below eUp (depending on which
  * destination is rightmost).
  *
  * Theoretically, this should always be true.  However, splitting an edge
  * into two pieces can change the results of previous tests.  For example,
  * suppose at one point we checked eUp and eLo, and decided that eUp->Dst
  * is barely above eLo.  Then later, we split eLo into two edges (eg. from
  * a splice operation like this one).  This can change the result of
  * the test so that now eUp->Dst is incident to eLo, or barely below it.
  * We must correct this condition to maintain the dictionary invariants
  * (otherwise new edges might get inserted in the wrong place in the
  * dictionary, and bad stuff will happen).
  *
  * We fix the problem by just splicing the offending vertex into the
  * other edge.
  */
  var regLo = Sweep.regionBelow(regUp);
  var eUp = regUp.eUp;
  var eLo = regLo.eUp;
  var e;
  assert(!Geom.vertEq(eUp.Dst, eLo.Dst));

  if (Geom.vertLeq(eUp.Dst, eLo.Dst)) {
    if (Geom.edgeSign(eUp.Dst, eLo.Dst, eUp.Org) < 0) return false;
    /* eLo->Dst is above eUp, so splice eLo->Dst into eUp */

    Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
    e = tess.mesh.splitEdge(eUp);
    tess.mesh.splice(eLo.Sym, e);
    e.Lface.inside = regUp.inside;
  } else {
    if (Geom.edgeSign(eLo.Dst, eUp.Dst, eLo.Org) > 0) return false;
    /* eUp->Dst is below eLo, so splice eUp->Dst into eLo */

    regUp.dirty = regLo.dirty = true;
    e = tess.mesh.splitEdge(eLo);
    tess.mesh.splice(eUp.Lnext, eLo.Sym);
    e.Rface.inside = regUp.inside;
  }

  return true;
}; //static int CheckForIntersect( TESStesselator *tess, ActiveRegion *regUp )


Sweep.checkForIntersect = function (tess, regUp) {
  /*
  * Check the upper and lower edges of the given region to see if
  * they intersect.  If so, create the intersection and add it
  * to the data structures.
  *
  * Returns TRUE if adding the new intersection resulted in a recursive
  * call to AddRightEdges(); in this case all "dirty" regions have been
  * checked for intersections, and possibly regUp has been deleted.
  */
  var regLo = Sweep.regionBelow(regUp);
  var eUp = regUp.eUp;
  var eLo = regLo.eUp;
  var orgUp = eUp.Org;
  var orgLo = eLo.Org;
  var dstUp = eUp.Dst;
  var dstLo = eLo.Dst;
  var tMinUp, tMaxLo;
  var isect = new TESSvertex(),
      orgMin;
  var e;
  assert(!Geom.vertEq(dstLo, dstUp));
  assert(Geom.edgeSign(dstUp, tess.event, orgUp) <= 0);
  assert(Geom.edgeSign(dstLo, tess.event, orgLo) >= 0);
  assert(orgUp !== tess.event && orgLo !== tess.event);
  assert(!regUp.fixUpperEdge && !regLo.fixUpperEdge);
  if (orgUp === orgLo) return false;
  /* right endpoints are the same */

  tMinUp = Math.min(orgUp.t, dstUp.t);
  tMaxLo = Math.max(orgLo.t, dstLo.t);
  if (tMinUp > tMaxLo) return false;
  /* t ranges do not overlap */

  if (Geom.vertLeq(orgUp, orgLo)) {
    if (Geom.edgeSign(dstLo, orgUp, orgLo) > 0) return false;
  } else {
    if (Geom.edgeSign(dstUp, orgLo, orgUp) < 0) return false;
  }
  /* At this point the edges intersect, at least marginally */


  Sweep.debugEvent(tess);
  Geom.intersect(dstUp, orgUp, dstLo, orgLo, isect);
  /* The following properties are guaranteed: */

  assert(Math.min(orgUp.t, dstUp.t) <= isect.t);
  assert(isect.t <= Math.max(orgLo.t, dstLo.t));
  assert(Math.min(dstLo.s, dstUp.s) <= isect.s);
  assert(isect.s <= Math.max(orgLo.s, orgUp.s));

  if (Geom.vertLeq(isect, tess.event)) {
    /* The intersection point lies slightly to the left of the sweep line,
    * so move it until it''s slightly to the right of the sweep line.
    * (If we had perfect numerical precision, this would never happen
    * in the first place).  The easiest and safest thing to do is
    * replace the intersection by tess->event.
    */
    isect.s = tess.event.s;
    isect.t = tess.event.t;
  }
  /* Similarly, if the computed intersection lies to the right of the
  * rightmost origin (which should rarely happen), it can cause
  * unbelievable inefficiency on sufficiently degenerate inputs.
  * (If you have the test program, try running test54.d with the
  * "X zoom" option turned on).
  */


  orgMin = Geom.vertLeq(orgUp, orgLo) ? orgUp : orgLo;

  if (Geom.vertLeq(orgMin, isect)) {
    isect.s = orgMin.s;
    isect.t = orgMin.t;
  }

  if (Geom.vertEq(isect, orgUp) || Geom.vertEq(isect, orgLo)) {
    /* Easy case -- intersection at one of the right endpoints */
    Sweep.checkForRightSplice(tess, regUp);
    return false;
  }

  if (!Geom.vertEq(dstUp, tess.event) && Geom.edgeSign(dstUp, tess.event, isect) >= 0 || !Geom.vertEq(dstLo, tess.event) && Geom.edgeSign(dstLo, tess.event, isect) <= 0) {
    /* Very unusual -- the new upper or lower edge would pass on the
    * wrong side of the sweep event, or through it.  This can happen
    * due to very small numerical errors in the intersection calculation.
    */
    if (dstLo === tess.event) {
      /* Splice dstLo into eUp, and process the new region(s) */
      tess.mesh.splitEdge(eUp.Sym);
      tess.mesh.splice(eLo.Sym, eUp);
      regUp = Sweep.topLeftRegion(tess, regUp); //			if (regUp == NULL) longjmp(tess->env,1);

      eUp = Sweep.regionBelow(regUp).eUp;
      Sweep.finishLeftRegions(tess, Sweep.regionBelow(regUp), regLo);
      Sweep.addRightEdges(tess, regUp, eUp.Oprev, eUp, eUp, true);
      return true;
    }

    if (dstUp === tess.event) {
      /* Splice dstUp into eLo, and process the new region(s) */
      tess.mesh.splitEdge(eLo.Sym);
      tess.mesh.splice(eUp.Lnext, eLo.Oprev);
      regLo = regUp;
      regUp = Sweep.topRightRegion(regUp);
      e = Sweep.regionBelow(regUp).eUp.Rprev;
      regLo.eUp = eLo.Oprev;
      eLo = Sweep.finishLeftRegions(tess, regLo, null);
      Sweep.addRightEdges(tess, regUp, eLo.Onext, eUp.Rprev, e, true);
      return true;
    }
    /* Special case: called from ConnectRightVertex.  If either
    * edge passes on the wrong side of tess->event, split it
    * (and wait for ConnectRightVertex to splice it appropriately).
    */


    if (Geom.edgeSign(dstUp, tess.event, isect) >= 0) {
      Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
      tess.mesh.splitEdge(eUp.Sym);
      eUp.Org.s = tess.event.s;
      eUp.Org.t = tess.event.t;
    }

    if (Geom.edgeSign(dstLo, tess.event, isect) <= 0) {
      regUp.dirty = regLo.dirty = true;
      tess.mesh.splitEdge(eLo.Sym);
      eLo.Org.s = tess.event.s;
      eLo.Org.t = tess.event.t;
    }
    /* leave the rest for ConnectRightVertex */


    return false;
  }
  /* General case -- split both edges, splice into new vertex.
  * When we do the splice operation, the order of the arguments is
  * arbitrary as far as correctness goes.  However, when the operation
  * creates a new face, the work done is proportional to the size of
  * the new face.  We expect the faces in the processed part of
  * the mesh (ie. eUp->Lface) to be smaller than the faces in the
  * unprocessed original contours (which will be eLo->Oprev->Lface).
  */


  tess.mesh.splitEdge(eUp.Sym);
  tess.mesh.splitEdge(eLo.Sym);
  tess.mesh.splice(eLo.Oprev, eUp);
  eUp.Org.s = isect.s;
  eUp.Org.t = isect.t;
  eUp.Org.pqHandle = tess.pq.insert(eUp.Org);
  Sweep.getIntersectData(tess, eUp.Org, orgUp, dstUp, orgLo, dstLo);
  Sweep.regionAbove(regUp).dirty = regUp.dirty = regLo.dirty = true;
  return false;
}; //static void WalkDirtyRegions( TESStesselator *tess, ActiveRegion *regUp )


Sweep.walkDirtyRegions = function (tess, regUp) {
  /*
  * When the upper or lower edge of any region changes, the region is
  * marked "dirty".  This routine walks through all the dirty regions
  * and makes sure that the dictionary invariants are satisfied
  * (see the comments at the beginning of this file).  Of course
  * new dirty regions can be created as we make changes to restore
  * the invariants.
  */
  var regLo = Sweep.regionBelow(regUp);
  var eUp, eLo;

  for (;;) {
    /* Find the lowest dirty region (we walk from the bottom up). */
    while (regLo.dirty) {
      regUp = regLo;
      regLo = Sweep.regionBelow(regLo);
    }

    if (!regUp.dirty) {
      regLo = regUp;
      regUp = Sweep.regionAbove(regUp);

      if (regUp === null || !regUp.dirty) {
        /* We've walked all the dirty regions */
        return;
      }
    }

    regUp.dirty = false;
    eUp = regUp.eUp;
    eLo = regLo.eUp;

    if (eUp.Dst !== eLo.Dst) {
      /* Check that the edge ordering is obeyed at the Dst vertices. */
      if (Sweep.checkForLeftSplice(tess, regUp)) {
        /* If the upper or lower edge was marked fixUpperEdge, then
        * we no longer need it (since these edges are needed only for
        * vertices which otherwise have no right-going edges).
        */
        if (regLo.fixUpperEdge) {
          Sweep.deleteRegion(tess, regLo);
          tess.mesh.delete(eLo);
          regLo = Sweep.regionBelow(regUp);
          eLo = regLo.eUp;
        } else if (regUp.fixUpperEdge) {
          Sweep.deleteRegion(tess, regUp);
          tess.mesh.delete(eUp);
          regUp = Sweep.regionAbove(regLo);
          eUp = regUp.eUp;
        }
      }
    }

    if (eUp.Org !== eLo.Org) {
      if (eUp.Dst !== eLo.Dst && !regUp.fixUpperEdge && !regLo.fixUpperEdge && (eUp.Dst === tess.event || eLo.Dst === tess.event)) {
        /* When all else fails in CheckForIntersect(), it uses tess->event
        * as the intersection location.  To make this possible, it requires
        * that tess->event lie between the upper and lower edges, and also
        * that neither of these is marked fixUpperEdge (since in the worst
        * case it might splice one of these edges into tess->event, and
        * violate the invariant that fixable edges are the only right-going
        * edge from their associated vertex).
        */
        if (Sweep.checkForIntersect(tess, regUp)) {
          /* WalkDirtyRegions() was called recursively; we're done */
          return;
        }
      } else {
        /* Even though we can't use CheckForIntersect(), the Org vertices
        * may violate the dictionary edge ordering.  Check and correct this.
        */
        Sweep.checkForRightSplice(tess, regUp);
      }
    }

    if (eUp.Org === eLo.Org && eUp.Dst === eLo.Dst) {
      /* A degenerate loop consisting of only two edges -- delete it. */
      Sweep.addWinding(eLo, eUp);
      Sweep.deleteRegion(tess, regUp);
      tess.mesh.delete(eUp);
      regUp = Sweep.regionAbove(regLo);
    }
  }
}; //static void ConnectRightVertex( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eBottomLeft )


Sweep.connectRightVertex = function (tess, regUp, eBottomLeft) {
  /*
  * Purpose: connect a "right" vertex vEvent (one where all edges go left)
  * to the unprocessed portion of the mesh.  Since there are no right-going
  * edges, two regions (one above vEvent and one below) are being merged
  * into one.  "regUp" is the upper of these two regions.
  *
  * There are two reasons for doing this (adding a right-going edge):
  *  - if the two regions being merged are "inside", we must add an edge
  *    to keep them separated (the combined region would not be monotone).
  *  - in any case, we must leave some record of vEvent in the dictionary,
  *    so that we can merge vEvent with features that we have not seen yet.
  *    For example, maybe there is a vertical edge which passes just to
  *    the right of vEvent; we would like to splice vEvent into this edge.
  *
  * However, we don't want to connect vEvent to just any vertex.  We don''t
  * want the new edge to cross any other edges; otherwise we will create
  * intersection vertices even when the input data had no self-intersections.
  * (This is a bad thing; if the user's input data has no intersections,
  * we don't want to generate any false intersections ourselves.)
  *
  * Our eventual goal is to connect vEvent to the leftmost unprocessed
  * vertex of the combined region (the union of regUp and regLo).
  * But because of unseen vertices with all right-going edges, and also
  * new vertices which may be created by edge intersections, we don''t
  * know where that leftmost unprocessed vertex is.  In the meantime, we
  * connect vEvent to the closest vertex of either chain, and mark the region
  * as "fixUpperEdge".  This flag says to delete and reconnect this edge
  * to the next processed vertex on the boundary of the combined region.
  * Quite possibly the vertex we connected to will turn out to be the
  * closest one, in which case we won''t need to make any changes.
  */
  var eNew;
  var eTopLeft = eBottomLeft.Onext;
  var regLo = Sweep.regionBelow(regUp);
  var eUp = regUp.eUp;
  var eLo = regLo.eUp;
  var degenerate = false;

  if (eUp.Dst !== eLo.Dst) {
    Sweep.checkForIntersect(tess, regUp);
  }
  /* Possible new degeneracies: upper or lower edge of regUp may pass
  * through vEvent, or may coincide with new intersection vertex
  */


  if (Geom.vertEq(eUp.Org, tess.event)) {
    tess.mesh.splice(eTopLeft.Oprev, eUp);
    regUp = Sweep.topLeftRegion(tess, regUp);
    eTopLeft = Sweep.regionBelow(regUp).eUp;
    Sweep.finishLeftRegions(tess, Sweep.regionBelow(regUp), regLo);
    degenerate = true;
  }

  if (Geom.vertEq(eLo.Org, tess.event)) {
    tess.mesh.splice(eBottomLeft, eLo.Oprev);
    eBottomLeft = Sweep.finishLeftRegions(tess, regLo, null);
    degenerate = true;
  }

  if (degenerate) {
    Sweep.addRightEdges(tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, true);
    return;
  }
  /* Non-degenerate situation -- need to add a temporary, fixable edge.
  * Connect to the closer of eLo->Org, eUp->Org.
  */


  if (Geom.vertLeq(eLo.Org, eUp.Org)) {
    eNew = eLo.Oprev;
  } else {
    eNew = eUp;
  }

  eNew = tess.mesh.connect(eBottomLeft.Lprev, eNew);
  /* Prevent cleanup, otherwise eNew might disappear before we've even
  * had a chance to mark it as a temporary edge.
  */

  Sweep.addRightEdges(tess, regUp, eNew, eNew.Onext, eNew.Onext, false);
  eNew.Sym.activeRegion.fixUpperEdge = true;
  Sweep.walkDirtyRegions(tess, regUp);
};
/* Because vertices at exactly the same location are merged together
* before we process the sweep event, some degenerate cases can't occur.
* However if someone eventually makes the modifications required to
* merge features which are close together, the cases below marked
* TOLERANCE_NONZERO will be useful.  They were debugged before the
* code to merge identical vertices in the main loop was added.
*/
//#define TOLERANCE_NONZERO	FALSE
//static void ConnectLeftDegenerate( TESStesselator *tess, ActiveRegion *regUp, TESSvertex *vEvent )


Sweep.connectLeftDegenerate = function (tess, regUp, vEvent) {
  /*
  * The event vertex lies exacty on an already-processed edge or vertex.
  * Adding the new vertex involves splicing it into the already-processed
  * part of the mesh.
  */
  var e, eTopLeft, eTopRight, eLast;
  var reg;
  e = regUp.eUp;

  if (Geom.vertEq(e.Org, vEvent)) {
    /* e->Org is an unprocessed vertex - just combine them, and wait
    * for e->Org to be pulled from the queue
    */
    assert(false
    /*TOLERANCE_NONZERO*/
    );
    Sweep.spliceMergeVertices(tess, e, vEvent.anEdge);
    return;
  }

  if (!Geom.vertEq(e.Dst, vEvent)) {
    /* General case -- splice vEvent into edge e which passes through it */
    tess.mesh.splitEdge(e.Sym);

    if (regUp.fixUpperEdge) {
      /* This edge was fixable -- delete unused portion of original edge */
      tess.mesh.delete(e.Onext);
      regUp.fixUpperEdge = false;
    }

    tess.mesh.splice(vEvent.anEdge, e);
    Sweep.sweepEvent(tess, vEvent);
    /* recurse */

    return;
  }
  /* vEvent coincides with e->Dst, which has already been processed.
  * Splice in the additional right-going edges.
  */


  assert(false
  /*TOLERANCE_NONZERO*/
  );
  regUp = Sweep.topRightRegion(regUp);
  reg = Sweep.regionBelow(regUp);
  eTopRight = reg.eUp.Sym;
  eTopLeft = eLast = eTopRight.Onext;

  if (reg.fixUpperEdge) {
    /* Here e->Dst has only a single fixable edge going right.
    * We can delete it since now we have some real right-going edges.
    */
    assert(eTopLeft !== eTopRight);
    /* there are some left edges too */

    Sweep.deleteRegion(tess, reg);
    tess.mesh.delete(eTopRight);
    eTopRight = eTopLeft.Oprev;
  }

  tess.mesh.splice(vEvent.anEdge, eTopRight);

  if (!Geom.edgeGoesLeft(eTopLeft)) {
    /* e->Dst had no left-going edges -- indicate this to AddRightEdges() */
    eTopLeft = null;
  }

  Sweep.addRightEdges(tess, regUp, eTopRight.Onext, eLast, eTopLeft, true);
}; //static void ConnectLeftVertex( TESStesselator *tess, TESSvertex *vEvent )


Sweep.connectLeftVertex = function (tess, vEvent) {
  /*
  * Purpose: connect a "left" vertex (one where both edges go right)
  * to the processed portion of the mesh.  Let R be the active region
  * containing vEvent, and let U and L be the upper and lower edge
  * chains of R.  There are two possibilities:
  *
  * - the normal case: split R into two regions, by connecting vEvent to
  *   the rightmost vertex of U or L lying to the left of the sweep line
  *
  * - the degenerate case: if vEvent is close enough to U or L, we
  *   merge vEvent into that edge chain.  The subcases are:
  *	- merging with the rightmost vertex of U or L
  *	- merging with the active edge of U or L
  *	- merging with an already-processed portion of U or L
  */
  var regUp, regLo, reg;
  var eUp, eLo, eNew;
  var tmp = new ActiveRegion();
  /* assert( vEvent->anEdge->Onext->Onext == vEvent->anEdge ); */

  /* Get a pointer to the active region containing vEvent */

  tmp.eUp = vEvent.anEdge.Sym;
  /* __GL_DICTLISTKEY */

  /* tessDictListSearch */

  regUp = tess.dict.search(tmp).key;
  regLo = Sweep.regionBelow(regUp);

  if (!regLo) {
    // This may happen if the input polygon is coplanar.
    return;
  }

  eUp = regUp.eUp;
  eLo = regLo.eUp;
  /* Try merging with U or L first */

  if (Geom.edgeSign(eUp.Dst, vEvent, eUp.Org) === 0.0) {
    Sweep.connectLeftDegenerate(tess, regUp, vEvent);
    return;
  }
  /* Connect vEvent to rightmost processed vertex of either chain.
  * e->Dst is the vertex that we will connect to vEvent.
  */


  reg = Geom.vertLeq(eLo.Dst, eUp.Dst) ? regUp : regLo;

  if (regUp.inside || reg.fixUpperEdge) {
    if (reg === regUp) {
      eNew = tess.mesh.connect(vEvent.anEdge.Sym, eUp.Lnext);
    } else {
      var tempHalfEdge = tess.mesh.connect(eLo.Dnext, vEvent.anEdge);
      eNew = tempHalfEdge.Sym;
    }

    if (reg.fixUpperEdge) {
      Sweep.fixUpperEdge(tess, reg, eNew);
    } else {
      Sweep.computeWinding(tess, Sweep.addRegionBelow(tess, regUp, eNew));
    }

    Sweep.sweepEvent(tess, vEvent);
  } else {
    /* The new vertex is in a region which does not belong to the polygon.
    * We don''t need to connect this vertex to the rest of the mesh.
    */
    Sweep.addRightEdges(tess, regUp, vEvent.anEdge, vEvent.anEdge, null, true);
  }
}; //static void SweepEvent( TESStesselator *tess, TESSvertex *vEvent )


Sweep.sweepEvent = function (tess, vEvent) {
  /*
  * Does everything necessary when the sweep line crosses a vertex.
  * Updates the mesh and the edge dictionary.
  */
  tess.event = vEvent;
  /* for access in EdgeLeq() */

  Sweep.debugEvent(tess);
  /* Check if this vertex is the right endpoint of an edge that is
  * already in the dictionary.  In this case we don't need to waste
  * time searching for the location to insert new edges.
  */

  var e = vEvent.anEdge;

  while (e.activeRegion === null) {
    e = e.Onext;

    if (e === vEvent.anEdge) {
      /* All edges go right -- not incident to any processed edges */
      Sweep.connectLeftVertex(tess, vEvent);
      return;
    }
  }
  /* Processing consists of two phases: first we "finish" all the
  * active regions where both the upper and lower edges terminate
  * at vEvent (ie. vEvent is closing off these regions).
  * We mark these faces "inside" or "outside" the polygon according
  * to their winding number, and delete the edges from the dictionary.
  * This takes care of all the left-going edges from vEvent.
  */


  var regUp = Sweep.topLeftRegion(tess, e.activeRegion);
  assert(regUp !== null); //	if (regUp == NULL) longjmp(tess->env,1);

  var reg = Sweep.regionBelow(regUp);
  var eTopLeft = reg.eUp;
  var eBottomLeft = Sweep.finishLeftRegions(tess, reg, null);
  /* Next we process all the right-going edges from vEvent.  This
  * involves adding the edges to the dictionary, and creating the
  * associated "active regions" which record information about the
  * regions between adjacent dictionary edges.
  */

  if (eBottomLeft.Onext === eTopLeft) {
    /* No right-going edges -- add a temporary "fixable" edge */
    Sweep.connectRightVertex(tess, regUp, eBottomLeft);
  } else {
    Sweep.addRightEdges(tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, true);
  }
};
/* Make the sentinel coordinates big enough that they will never be
* merged with real input features.
*/
//static void AddSentinel( TESStesselator *tess, TESSreal smin, TESSreal smax, TESSreal t )


Sweep.addSentinel = function (tess, smin, smax, t) {
  /*
  * We add two sentinel edges above and below all other edges,
  * to avoid special cases at the top and bottom.
  */
  var reg = new ActiveRegion();
  var e = tess.mesh.makeEdge(); //	if (e == NULL) longjmp(tess->env,1);

  e.Org.s = smax;
  e.Org.t = t;
  e.Dst.s = smin;
  e.Dst.t = t;
  tess.event = e.Dst;
  /* initialize it */

  reg.eUp = e;
  reg.windingNumber = 0;
  reg.inside = false;
  reg.fixUpperEdge = false;
  reg.sentinel = true;
  reg.dirty = false;
  reg.nodeUp = tess.dict.insert(reg); //	if (reg->nodeUp == NULL) longjmp(tess->env,1);
}; //static void InitEdgeDict( TESStesselator *tess )


Sweep.initEdgeDict = function (tess) {
  /*
  * We maintain an ordering of edge intersections with the sweep line.
  * This order is maintained in a dynamic dictionary.
  */
  tess.dict = new Dict(tess, Sweep.edgeLeq); //	if (tess->dict == NULL) longjmp(tess->env,1);

  var w = tess.bmax[0] - tess.bmin[0];
  var h = tess.bmax[1] - tess.bmin[1];
  var smin = tess.bmin[0] - w;
  var smax = tess.bmax[0] + w;
  var tmin = tess.bmin[1] - h;
  var tmax = tess.bmax[1] + h;
  Sweep.addSentinel(tess, smin, smax, tmin);
  Sweep.addSentinel(tess, smin, smax, tmax);
};

Sweep.doneEdgeDict = function (tess) {
  var reg;
  var fixedEdges = 0;

  while ((reg = tess.dict.min().key) !== null) {
    /*
    * At the end of all processing, the dictionary should contain
    * only the two sentinel edges, plus at most one "fixable" edge
    * created by ConnectRightVertex().
    */
    if (!reg.sentinel) {
      assert(reg.fixUpperEdge);
      assert(++fixedEdges === 1);
    }

    assert(reg.windingNumber === 0);
    Sweep.deleteRegion(tess, reg);
    /*    tessMeshDelete( reg->eUp );*/
  } //	dictDeleteDict( &tess->alloc, tess->dict );

};

Sweep.removeDegenerateEdges = function (tess) {
  /*
  * Remove zero-length edges, and contours with fewer than 3 vertices.
  */
  var e, eNext, eLnext;
  var eHead = tess.mesh.eHead;
  /*LINTED*/

  for (e = eHead.next; e !== eHead; e = eNext) {
    eNext = e.next;
    eLnext = e.Lnext;

    if (Geom.vertEq(e.Org, e.Dst) && e.Lnext.Lnext !== e) {
      /* Zero-length edge, contour has at least 3 edges */
      Sweep.spliceMergeVertices(tess, eLnext, e);
      /* deletes e->Org */

      tess.mesh.delete(e);
      /* e is a self-loop */

      e = eLnext;
      eLnext = e.Lnext;
    }

    if (eLnext.Lnext === e) {
      /* Degenerate contour (one or two edges) */
      if (eLnext !== e) {
        if (eLnext === eNext || eLnext === eNext.Sym) {
          eNext = eNext.next;
        }

        tess.mesh.delete(eLnext);
      }

      if (e === eNext || e === eNext.Sym) {
        eNext = eNext.next;
      }

      tess.mesh.delete(e);
    }
  }
};

Sweep.initPriorityQ = function (tess) {
  /*
  * Insert all vertices into the priority queue which determines the
  * order in which vertices cross the sweep line.
  */
  var pq;
  var v, vHead;
  var vertexCount = 0;
  vHead = tess.mesh.vHead;

  for (v = vHead.next; v !== vHead; v = v.next) {
    vertexCount++;
  }
  /* Make sure there is enough space for sentinels. */


  vertexCount += 8; //MAX( 8, tess->alloc.extraVertices );

  pq = tess.pq = new PriorityQ(vertexCount, Geom.vertLeq); //	if (pq == NULL) return 0;

  vHead = tess.mesh.vHead;

  for (v = vHead.next; v !== vHead; v = v.next) {
    v.pqHandle = pq.insert(v); //		if (v.pqHandle == INV_HANDLE)
    //			break;
  }

  if (v !== vHead) {
    return false;
  }

  pq.init();
  return true;
};

Sweep.donePriorityQ = function (tess) {
  tess.pq = null;
};

Sweep.removeDegenerateFaces = function (tess, mesh) {
  /*
  * Delete any degenerate faces with only two edges.  WalkDirtyRegions()
  * will catch almost all of these, but it won't catch degenerate faces
  * produced by splice operations on already-processed edges.
  * The two places this can happen are in FinishLeftRegions(), when
  * we splice in a "temporary" edge produced by ConnectRightVertex(),
  * and in CheckForLeftSplice(), where we splice already-processed
  * edges to ensure that our dictionary invariants are not violated
  * by numerical errors.
  *
  * In both these cases it is *very* dangerous to delete the offending
  * edge at the time, since one of the routines further up the stack
  * will sometimes be keeping a pointer to that edge.
  */
  var f, fNext;
  var e;
  /*LINTED*/

  for (f = mesh.fHead.next; f !== mesh.fHead; f = fNext) {
    fNext = f.next;
    e = f.anEdge;
    assert(e.Lnext !== e);

    if (e.Lnext.Lnext === e) {
      /* A face with only two edges */
      Sweep.addWinding(e.Onext, e);
      tess.mesh.delete(e);
    }
  }

  return true;
};

Sweep.computeInterior = function (tess) {
  /*
  * tessComputeInterior( tess ) computes the planar arrangement specified
  * by the given contours, and further subdivides this arrangement
  * into regions.  Each region is marked "inside" if it belongs
  * to the polygon, according to the rule given by tess->windingRule.
  * Each interior region is guaranteed be monotone.
  */
  var v, vNext;
  /* Each vertex defines an event for our sweep line.  Start by inserting
  * all the vertices in a priority queue.  Events are processed in
  * lexicographic order, ie.
  *
  *	e1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)
  */

  Sweep.removeDegenerateEdges(tess);
  if (!Sweep.initPriorityQ(tess)) return false;
  /* if error */

  Sweep.initEdgeDict(tess);

  while ((v = tess.pq.extractMin()) !== null) {
    for (;;) {
      vNext = tess.pq.min();
      if (vNext === null || !Geom.vertEq(vNext, v)) break;
      /* Merge together all vertices at exactly the same location.
      * This is more efficient than processing them one at a time,
      * simplifies the code (see ConnectLeftDegenerate), and is also
      * important for correct handling of certain degenerate cases.
      * For example, suppose there are two identical edges A and B
      * that belong to different contours (so without this code they would
      * be processed by separate sweep events).  Suppose another edge C
      * crosses A and B from above.  When A is processed, we split it
      * at its intersection point with C.  However this also splits C,
      * so when we insert B we may compute a slightly different
      * intersection point.  This might leave two edges with a small
      * gap between them.  This kind of error is especially obvious
      * when using boundary extraction (TESS_BOUNDARY_ONLY).
      */

      vNext = tess.pq.extractMin();
      Sweep.spliceMergeVertices(tess, v.anEdge, vNext.anEdge);
    }

    Sweep.sweepEvent(tess, v);
  }
  /* Set tess->event for debugging purposes */


  tess.event = tess.dict.min().key.eUp.Org;
  Sweep.debugEvent(tess);
  Sweep.doneEdgeDict(tess);
  Sweep.donePriorityQ(tess);
  if (!Sweep.removeDegenerateFaces(tess, tess.mesh)) return false;
  tess.mesh.check();
  return true;
};

function Tesselator() {
  /*** state needed for collecting the input data ***/
  this.mesh = null;
  /* stores the input contours, and eventually
  the tessellation itself */

  /*** state needed for projecting onto the sweep plane ***/

  this.normal = [0.0, 0.0, 0.0];
  /* user-specified normal (if provided) */

  this.sUnit = [0.0, 0.0, 0.0];
  /* unit vector in s-direction (debugging) */

  this.tUnit = [0.0, 0.0, 0.0];
  /* unit vector in t-direction (debugging) */

  this.bmin = [0.0, 0.0];
  this.bmax = [0.0, 0.0];
  /*** state needed for the line sweep ***/

  this.windingRule = Tess2.WINDING_ODD;
  /* rule for determining polygon interior */

  this.dict = null;
  /* edge dictionary for sweep line */

  this.pq = null;
  /* priority queue of vertex events */

  this.event = null;
  /* current sweep event being processed */

  this.vertexIndexCounter = 0;
  this.vertices = [];
  this.vertexIndices = [];
  this.vertexCount = 0;
  this.elements = [];
  this.elementCount = 0;
}

;
Tesselator.prototype = {
  dot_: function dot_(u, v) {
    return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
  },
  normalize_: function normalize_(v) {
    var len = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
    assert(len > 0.0);
    len = Math.sqrt(len);
    v[0] /= len;
    v[1] /= len;
    v[2] /= len;
  },
  longAxis_: function longAxis_(v) {
    var i = 0;

    if (Math.abs(v[1]) > Math.abs(v[0])) {
      i = 1;
    }

    if (Math.abs(v[2]) > Math.abs(v[i])) {
      i = 2;
    }

    return i;
  },
  computeNormal_: function computeNormal_(norm) {
    var v, v1, v2;
    var c, tLen2, maxLen2;
    var maxVal = [0, 0, 0],
        minVal = [0, 0, 0],
        d1 = [0, 0, 0],
        d2 = [0, 0, 0],
        tNorm = [0, 0, 0];
    var maxVert = [null, null, null],
        minVert = [null, null, null];
    var vHead = this.mesh.vHead;
    var i;
    v = vHead.next;

    for (i = 0; i < 3; ++i) {
      c = v.coords[i];
      minVal[i] = c;
      minVert[i] = v;
      maxVal[i] = c;
      maxVert[i] = v;
    }

    for (v = vHead.next; v !== vHead; v = v.next) {
      for (i = 0; i < 3; ++i) {
        c = v.coords[i];

        if (c < minVal[i]) {
          minVal[i] = c;
          minVert[i] = v;
        }

        if (c > maxVal[i]) {
          maxVal[i] = c;
          maxVert[i] = v;
        }
      }
    }
    /* Find two vertices separated by at least 1/sqrt(3) of the maximum
    * distance between any two vertices
    */


    i = 0;

    if (maxVal[1] - minVal[1] > maxVal[0] - minVal[0]) {
      i = 1;
    }

    if (maxVal[2] - minVal[2] > maxVal[i] - minVal[i]) {
      i = 2;
    }

    if (minVal[i] >= maxVal[i]) {
      /* All vertices are the same -- normal doesn't matter */
      norm[0] = 0;
      norm[1] = 0;
      norm[2] = 1;
      return;
    }
    /* Look for a third vertex which forms the triangle with maximum area
    * (Length of normal == twice the triangle area)
    */


    maxLen2 = 0;
    v1 = minVert[i];
    v2 = maxVert[i];
    d1[0] = v1.coords[0] - v2.coords[0];
    d1[1] = v1.coords[1] - v2.coords[1];
    d1[2] = v1.coords[2] - v2.coords[2];

    for (v = vHead.next; v !== vHead; v = v.next) {
      d2[0] = v.coords[0] - v2.coords[0];
      d2[1] = v.coords[1] - v2.coords[1];
      d2[2] = v.coords[2] - v2.coords[2];
      tNorm[0] = d1[1] * d2[2] - d1[2] * d2[1];
      tNorm[1] = d1[2] * d2[0] - d1[0] * d2[2];
      tNorm[2] = d1[0] * d2[1] - d1[1] * d2[0];
      tLen2 = tNorm[0] * tNorm[0] + tNorm[1] * tNorm[1] + tNorm[2] * tNorm[2];

      if (tLen2 > maxLen2) {
        maxLen2 = tLen2;
        norm[0] = tNorm[0];
        norm[1] = tNorm[1];
        norm[2] = tNorm[2];
      }
    }

    if (maxLen2 <= 0) {
      /* All points lie on a single line -- any decent normal will do */
      norm[0] = norm[1] = norm[2] = 0;
      norm[this.longAxis_(d1)] = 1;
    }
  },
  checkOrientation_: function checkOrientation_() {
    var area;
    var f,
        fHead = this.mesh.fHead;
    var v,
        vHead = this.mesh.vHead;
    var e;
    /* When we compute the normal automatically, we choose the orientation
    * so that the the sum of the signed areas of all contours is non-negative.
    */

    area = 0;

    for (f = fHead.next; f !== fHead; f = f.next) {
      e = f.anEdge;
      if (e.winding <= 0) continue;

      do {
        area += (e.Org.s - e.Dst.s) * (e.Org.t + e.Dst.t);
        e = e.Lnext;
      } while (e !== f.anEdge);
    }

    if (area < 0) {
      /* Reverse the orientation by flipping all the t-coordinates */
      for (v = vHead.next; v !== vHead; v = v.next) {
        v.t = -v.t;
      }

      this.tUnit[0] = -this.tUnit[0];
      this.tUnit[1] = -this.tUnit[1];
      this.tUnit[2] = -this.tUnit[2];
    }
  },

  /*	#ifdef FOR_TRITE_TEST_PROGRAM
    #include <stdlib.h>
    extern int RandomSweep;
    #define S_UNIT_X	(RandomSweep ? (2*drand48()-1) : 1.0)
    #define S_UNIT_Y	(RandomSweep ? (2*drand48()-1) : 0.0)
    #else
    #if defined(SLANTED_SWEEP) */

  /* The "feature merging" is not intended to be complete.  There are
  * special cases where edges are nearly parallel to the sweep line
  * which are not implemented.  The algorithm should still behave
  * robustly (ie. produce a reasonable tesselation) in the presence
  * of such edges, however it may miss features which could have been
  * merged.  We could minimize this effect by choosing the sweep line
  * direction to be something unusual (ie. not parallel to one of the
  * coordinate axes).
  */

  /*	#define S_UNIT_X	(TESSreal)0.50941539564955385	// Pre-normalized
    #define S_UNIT_Y	(TESSreal)0.86052074622010633
    #else
    #define S_UNIT_X	(TESSreal)1.0
    #define S_UNIT_Y	(TESSreal)0.0
    #endif
    #endif*/

  /* Determine the polygon normal and project vertices onto the plane
  * of the polygon.
  */
  projectPolygon_: function projectPolygon_() {
    var v,
        vHead = this.mesh.vHead;
    var norm = [0, 0, 0];
    var sUnit, tUnit;
    var i,
        first,
        computedNormal = false;
    norm[0] = this.normal[0];
    norm[1] = this.normal[1];
    norm[2] = this.normal[2];

    if (norm[0] === 0.0 && norm[1] === 0.0 && norm[2] === 0.0) {
      this.computeNormal_(norm);
      computedNormal = true;
    }

    sUnit = this.sUnit;
    tUnit = this.tUnit;
    i = this.longAxis_(norm);
    /*	#if defined(FOR_TRITE_TEST_PROGRAM) || defined(TRUE_PROJECT)
        // Choose the initial sUnit vector to be approximately perpendicular
        // to the normal.
        
        Normalize( norm );
    
        sUnit[i] = 0;
        sUnit[(i+1)%3] = S_UNIT_X;
        sUnit[(i+2)%3] = S_UNIT_Y;
    
        // Now make it exactly perpendicular 
        w = Dot( sUnit, norm );
        sUnit[0] -= w * norm[0];
        sUnit[1] -= w * norm[1];
        sUnit[2] -= w * norm[2];
        Normalize( sUnit );
    
        // Choose tUnit so that (sUnit,tUnit,norm) form a right-handed frame 
        tUnit[0] = norm[1]*sUnit[2] - norm[2]*sUnit[1];
        tUnit[1] = norm[2]*sUnit[0] - norm[0]*sUnit[2];
        tUnit[2] = norm[0]*sUnit[1] - norm[1]*sUnit[0];
        Normalize( tUnit );
      #else*/

    /* Project perpendicular to a coordinate axis -- better numerically */

    sUnit[i] = 0;
    sUnit[(i + 1) % 3] = 1.0;
    sUnit[(i + 2) % 3] = 0.0;
    tUnit[i] = 0;
    tUnit[(i + 1) % 3] = 0.0;
    tUnit[(i + 2) % 3] = norm[i] > 0 ? 1.0 : -1.0; //	#endif

    /* Project the vertices onto the sweep plane */

    for (v = vHead.next; v !== vHead; v = v.next) {
      v.s = this.dot_(v.coords, sUnit);
      v.t = this.dot_(v.coords, tUnit);
    }

    if (computedNormal) {
      this.checkOrientation_();
    }
    /* Compute ST bounds. */


    first = true;

    for (v = vHead.next; v !== vHead; v = v.next) {
      if (first) {
        this.bmin[0] = this.bmax[0] = v.s;
        this.bmin[1] = this.bmax[1] = v.t;
        first = false;
      } else {
        if (v.s < this.bmin[0]) this.bmin[0] = v.s;
        if (v.s > this.bmax[0]) this.bmax[0] = v.s;
        if (v.t < this.bmin[1]) this.bmin[1] = v.t;
        if (v.t > this.bmax[1]) this.bmax[1] = v.t;
      }
    }
  },
  addWinding_: function addWinding_(eDst, eSrc) {
    eDst.winding += eSrc.winding;
    eDst.Sym.winding += eSrc.Sym.winding;
  },

  /* tessMeshTessellateMonoRegion( face ) tessellates a monotone region
  * (what else would it do??)  The region must consist of a single
  * loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
  * case means that any vertical line intersects the interior of the
  * region in a single interval.  
  *
  * Tessellation consists of adding interior edges (actually pairs of
  * half-edges), to split the region into non-overlapping triangles.
  *
  * The basic idea is explained in Preparata and Shamos (which I don''t
  * have handy right now), although their implementation is more
  * complicated than this one.  The are two edge chains, an upper chain
  * and a lower chain.  We process all vertices from both chains in order,
  * from right to left.
  *
  * The algorithm ensures that the following invariant holds after each
  * vertex is processed: the untessellated region consists of two
  * chains, where one chain (say the upper) is a single edge, and
  * the other chain is concave.  The left vertex of the single edge
  * is always to the left of all vertices in the concave chain.
  *
  * Each step consists of adding the rightmost unprocessed vertex to one
  * of the two chains, and forming a fan of triangles from the rightmost
  * of two chain endpoints.  Determining whether we can add each triangle
  * to the fan is a simple orientation test.  By making the fan as large
  * as possible, we restore the invariant (check it yourself).
  */
  //	int tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )
  tessellateMonoRegion_: function tessellateMonoRegion_(mesh, face) {
    var up, lo;
    /* All edges are oriented CCW around the boundary of the region.
    * First, find the half-edge whose origin vertex is rightmost.
    * Since the sweep goes from left to right, face->anEdge should
    * be close to the edge we want.
    */

    up = face.anEdge;
    assert(up.Lnext !== up && up.Lnext.Lnext !== up);

    for (; Geom.vertLeq(up.Dst, up.Org); up = up.Lprev) {
      ;
    }

    for (; Geom.vertLeq(up.Org, up.Dst); up = up.Lnext) {
      ;
    }

    lo = up.Lprev;

    while (up.Lnext !== lo) {
      if (Geom.vertLeq(up.Dst, lo.Org)) {
        /* up->Dst is on the left.  It is safe to form triangles from lo->Org.
        * The EdgeGoesLeft test guarantees progress even when some triangles
        * are CW, given that the upper and lower chains are truly monotone.
        */
        while (lo.Lnext !== up && (Geom.edgeGoesLeft(lo.Lnext) || Geom.edgeSign(lo.Org, lo.Dst, lo.Lnext.Dst) <= 0.0)) {
          var tempHalfEdge = mesh.connect(lo.Lnext, lo); //if (tempHalfEdge == NULL) return 0;

          lo = tempHalfEdge.Sym;
        }

        lo = lo.Lprev;
      } else {
        /* lo->Org is on the left.  We can make CCW triangles from up->Dst. */
        while (lo.Lnext !== up && (Geom.edgeGoesRight(up.Lprev) || Geom.edgeSign(up.Dst, up.Org, up.Lprev.Org) >= 0.0)) {
          var tempHalfEdge = mesh.connect(up, up.Lprev); //if (tempHalfEdge == NULL) return 0;

          up = tempHalfEdge.Sym;
        }

        up = up.Lnext;
      }
    }
    /* Now lo->Org == up->Dst == the leftmost vertex.  The remaining region
    * can be tessellated in a fan from this leftmost vertex.
    */


    assert(lo.Lnext !== up);

    while (lo.Lnext.Lnext !== up) {
      var tempHalfEdge = mesh.connect(lo.Lnext, lo); //if (tempHalfEdge == NULL) return 0;

      lo = tempHalfEdge.Sym;
    }

    return true;
  },

  /* tessMeshTessellateInterior( mesh ) tessellates each region of
  * the mesh which is marked "inside" the polygon.  Each such region
  * must be monotone.
  */
  //int tessMeshTessellateInterior( TESSmesh *mesh )
  tessellateInterior_: function tessellateInterior_(mesh) {
    var f, next;
    /*LINTED*/

    for (f = mesh.fHead.next; f !== mesh.fHead; f = next) {
      /* Make sure we don''t try to tessellate the new triangles. */
      next = f.next;

      if (f.inside) {
        if (!this.tessellateMonoRegion_(mesh, f)) return false;
      }
    }

    return true;
  },

  /* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
  * which are not marked "inside" the polygon.  Since further mesh operations
  * on NULL faces are not allowed, the main purpose is to clean up the
  * mesh so that exterior loops are not represented in the data structure.
  */
  //void tessMeshDiscardExterior( TESSmesh *mesh )
  discardExterior_: function discardExterior_(mesh) {
    var f, next;
    /*LINTED*/

    for (f = mesh.fHead.next; f !== mesh.fHead; f = next) {
      /* Since f will be destroyed, save its next pointer. */
      next = f.next;

      if (!f.inside) {
        mesh.zapFace(f);
      }
    }
  },

  /* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
  * winding numbers on all edges so that regions marked "inside" the
  * polygon have a winding number of "value", and regions outside
  * have a winding number of 0.
  *
  * If keepOnlyBoundary is TRUE, it also deletes all edges which do not
  * separate an interior region from an exterior one.
  */
  //	int tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )
  setWindingNumber_: function setWindingNumber_(mesh, value, keepOnlyBoundary) {
    var e, eNext;

    for (e = mesh.eHead.next; e !== mesh.eHead; e = eNext) {
      eNext = e.next;

      if (e.Rface.inside !== e.Lface.inside) {
        /* This is a boundary edge (one side is interior, one is exterior). */
        e.winding = e.Lface.inside ? value : -value;
      } else {
        /* Both regions are interior, or both are exterior. */
        if (!keepOnlyBoundary) {
          e.winding = 0;
        } else {
          mesh.delete(e);
        }
      }
    }
  },
  getNeighbourFace_: function getNeighbourFace_(edge) {
    if (!edge.Rface) return -1;
    if (!edge.Rface.inside) return -1;
    return edge.Rface.n;
  },
  outputPolymesh_: function outputPolymesh_(mesh, elementType, polySize, vertexSize) {
    var v;
    var f;
    var edge;
    var maxFaceCount = 0;
    var maxVertexCount = 0;
    var faceVerts, i;
    var elements = 0;
    var vert; // Assume that the input data is triangles now.
    // Try to merge as many polygons as possible

    if (polySize > 3) {
      mesh.mergeConvexFaces(polySize);
    } // Mark unused


    for (v = mesh.vHead.next; v !== mesh.vHead; v = v.next) {
      v.n = -1;
    } // Create unique IDs for all vertices and faces.


    for (f = mesh.fHead.next; f !== mesh.fHead; f = f.next) {
      f.n = -1;
      if (!f.inside) continue;
      edge = f.anEdge;
      faceVerts = 0;

      do {
        v = edge.Org;

        if (v.n === -1) {
          v.n = maxVertexCount;
          maxVertexCount++;
        }

        faceVerts++;
        edge = edge.Lnext;
      } while (edge !== f.anEdge);

      assert(faceVerts <= polySize);
      f.n = maxFaceCount;
      ++maxFaceCount;
    }

    this.elementCount = maxFaceCount;
    if (elementType === Tess2.CONNECTED_POLYGONS) maxFaceCount *= 2;
    /*		tess.elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
                                  sizeof(TESSindex) * maxFaceCount * polySize );
        if (!tess->elements)
        {
          tess->outOfMemory = 1;
          return;
        }*/

    this.elements = [];
    this.elements.length = maxFaceCount * polySize;
    this.vertexCount = maxVertexCount;
    /*		tess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,
                                 sizeof(TESSreal) * tess->vertexCount * vertexSize );
        if (!tess->vertices)
        {
          tess->outOfMemory = 1;
          return;
        }*/

    this.vertices = [];
    this.vertices.length = maxVertexCount * vertexSize;
    /*		tess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
                                      sizeof(TESSindex) * tess->vertexCount );
        if (!tess->vertexIndices)
        {
          tess->outOfMemory = 1;
          return;
        }*/

    this.vertexIndices = [];
    this.vertexIndices.length = maxVertexCount; // Output vertices.

    for (v = mesh.vHead.next; v !== mesh.vHead; v = v.next) {
      if (v.n !== -1) {
        // Store coordinate
        var idx = v.n * vertexSize;
        this.vertices[idx + 0] = v.coords[0];
        this.vertices[idx + 1] = v.coords[1];
        if (vertexSize > 2) this.vertices[idx + 2] = v.coords[2]; // Store vertex index.

        this.vertexIndices[v.n] = v.idx;
      }
    } // Output indices.


    var nel = 0;

    for (f = mesh.fHead.next; f !== mesh.fHead; f = f.next) {
      if (!f.inside) continue; // Store polygon

      edge = f.anEdge;
      faceVerts = 0;

      do {
        v = edge.Org;
        this.elements[nel++] = v.n;
        faceVerts++;
        edge = edge.Lnext;
      } while (edge !== f.anEdge); // Fill unused.


      for (i = faceVerts; i < polySize; ++i) {
        this.elements[nel++] = -1;
      } // Store polygon connectivity


      if (elementType === Tess2.CONNECTED_POLYGONS) {
        edge = f.anEdge;

        do {
          this.elements[nel++] = this.getNeighbourFace_(edge);
          edge = edge.Lnext;
        } while (edge !== f.anEdge); // Fill unused.


        for (i = faceVerts; i < polySize; ++i) {
          this.elements[nel++] = -1;
        }
      }
    }
  },
  //	void OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )
  outputContours_: function outputContours_(mesh, vertexSize) {
    var f;
    var edge;
    var start;
    var verts;
    var elements;
    var vertInds;
    var startVert = 0;
    var vertCount = 0;
    this.vertexCount = 0;
    this.elementCount = 0;

    for (f = mesh.fHead.next; f !== mesh.fHead; f = f.next) {
      if (!f.inside) continue;
      start = edge = f.anEdge;

      do {
        this.vertexCount++;
        edge = edge.Lnext;
      } while (edge !== start);

      this.elementCount++;
    }
    /*		tess->elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
                                  sizeof(TESSindex) * tess->elementCount * 2 );
        if (!tess->elements)
        {
          tess->outOfMemory = 1;
          return;
        }*/


    this.elements = [];
    this.elements.length = this.elementCount * 2;
    /*		tess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,
                                  sizeof(TESSreal) * tess->vertexCount * vertexSize );
        if (!tess->vertices)
        {
          tess->outOfMemory = 1;
          return;
        }*/

    this.vertices = [];
    this.vertices.length = this.vertexCount * vertexSize;
    /*		tess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
                                      sizeof(TESSindex) * tess->vertexCount );
        if (!tess->vertexIndices)
        {
          tess->outOfMemory = 1;
          return;
        }*/

    this.vertexIndices = [];
    this.vertexIndices.length = this.vertexCount;
    var nv = 0;
    var nvi = 0;
    var nel = 0;
    startVert = 0;

    for (f = mesh.fHead.next; f !== mesh.fHead; f = f.next) {
      if (!f.inside) continue;
      vertCount = 0;
      start = edge = f.anEdge;

      do {
        this.vertices[nv++] = edge.Org.coords[0];
        this.vertices[nv++] = edge.Org.coords[1];
        if (vertexSize > 2) this.vertices[nv++] = edge.Org.coords[2];
        this.vertexIndices[nvi++] = edge.Org.idx;
        vertCount++;
        edge = edge.Lnext;
      } while (edge !== start);

      this.elements[nel++] = startVert;
      this.elements[nel++] = vertCount;
      startVert += vertCount;
    }
  },
  addContour: function addContour(size, vertices) {
    var e;
    var i;
    if (this.mesh === null) this.mesh = new TESSmesh();
    /*	 	if ( tess->mesh == NULL ) {
          tess->outOfMemory = 1;
          return;
        }*/

    if (size < 2) size = 2;
    if (size > 3) size = 3;
    e = null;

    for (i = 0; i < vertices.length; i += size) {
      if (e === null) {
        /* Make a self-loop (one vertex, one edge). */
        e = this.mesh.makeEdge();
        /*				if ( e == NULL ) {
                  tess->outOfMemory = 1;
                  return;
                }*/

        this.mesh.splice(e, e.Sym);
      } else {
        /* Create a new vertex and edge which immediately follow e
        * in the ordering around the left face.
        */
        this.mesh.splitEdge(e);
        e = e.Lnext;
      }
      /* The new vertex is now e->Org. */


      e.Org.coords[0] = vertices[i + 0];
      e.Org.coords[1] = vertices[i + 1];
      if (size > 2) e.Org.coords[2] = vertices[i + 2];else e.Org.coords[2] = 0.0;
      /* Store the insertion number so that the vertex can be later recognized. */

      e.Org.idx = this.vertexIndexCounter++;
      /* The winding of an edge says how the winding number changes as we
      * cross from the edge''s right face to its left face.  We add the
      * vertices in such an order that a CCW contour will add +1 to
      * the winding number of the region inside the contour.
      */

      e.winding = 1;
      e.Sym.winding = -1;
    }
  },
  //	int tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )
  tesselate: function tesselate(windingRule, elementType, polySize, vertexSize, normal) {
    this.vertices = [];
    this.elements = [];
    this.vertexIndices = [];
    this.vertexIndexCounter = 0;

    if (normal) {
      this.normal[0] = normal[0];
      this.normal[1] = normal[1];
      this.normal[2] = normal[2];
    }

    this.windingRule = windingRule;
    if (vertexSize < 2) vertexSize = 2;
    if (vertexSize > 3) vertexSize = 3;
    /*		if (setjmp(tess->env) != 0) { 
          // come back here if out of memory
          return 0;
        }*/

    if (!this.mesh) {
      return false;
    }
    /* Determine the polygon normal and project vertices onto the plane
    * of the polygon.
    */


    this.projectPolygon_();
    /* tessComputeInterior( tess ) computes the planar arrangement specified
    * by the given contours, and further subdivides this arrangement
    * into regions.  Each region is marked "inside" if it belongs
    * to the polygon, according to the rule given by tess->windingRule.
    * Each interior region is guaranteed be monotone.
    */

    Sweep.computeInterior(this);
    var mesh = this.mesh;
    /* If the user wants only the boundary contours, we throw away all edges
    * except those which separate the interior from the exterior.
    * Otherwise we tessellate all the regions marked "inside".
    */

    if (elementType === Tess2.BOUNDARY_CONTOURS) {
      this.setWindingNumber_(mesh, 1, true);
    } else {
      this.tessellateInterior_(mesh);
    } //		if (rc == 0) longjmp(tess->env,1);  /* could've used a label */


    mesh.check();

    if (elementType === Tess2.BOUNDARY_CONTOURS) {
      this.outputContours_(mesh, vertexSize);
      /* output contours */
    } else {
      this.outputPolymesh_(mesh, elementType, polySize, vertexSize);
      /* output polygons */
    } //			tess.mesh = null;


    return true;
  }
};

/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createShaders", function() { return createShaders; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyShader", function() { return applyShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCloudShaders", function() { return createCloudShaders; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyCloudShader", function() { return applyCloudShader; });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_vert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(83);
/* harmony import */ var _shader_frag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84);
/* harmony import */ var _shader_cloud_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85);
/* harmony import */ var _shader_cloud_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(86);


__webpack_require__(1).glMatrix.setMatrixArrayType(Array);






var _shaders = Symbol('shaders');

function createShaders(renderer) {
  renderer[_shaders] = [];

  for (var i = 0; i < 16; i++) {
    var defines = [];
    var hasTexture = !!(i & 0x1);
    var hasFilter = !!(i & 0x2);
    var hasGradient = !!(i & 0x4);
    var hasClipPath = !!(i & 0x8);
    if (hasTexture) defines.push('#define TEXTURE 1');
    if (hasFilter) defines.push('#define FILTER 1');
    if (hasGradient) defines.push('#define GRADIENT 1');
    if (hasClipPath) defines.push('#define CLIPPATH 1');
    var prefix = "".concat(defines.join('\n'), "\n");
    var samplerDef = [];

    if (hasTexture) {
      samplerDef.push('uniform sampler2D u_texSampler;');
    }

    if (hasClipPath) {
      samplerDef.push('uniform sampler2D u_clipSampler;');
    } // renderer.createProgram(prefix + samplerDef.join('\n') + fragShader, prefix + vertShader);


    renderer[_shaders][i] = [prefix + samplerDef.join('\n') + _shader_frag__WEBPACK_IMPORTED_MODULE_2__["default"], prefix + _shader_vert__WEBPACK_IMPORTED_MODULE_1__["default"]];
  }
}
function applyShader(renderer) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$hasTexture = _ref.hasTexture,
      hasTexture = _ref$hasTexture === void 0 ? false : _ref$hasTexture,
      _ref$hasFilter = _ref.hasFilter,
      hasFilter = _ref$hasFilter === void 0 ? false : _ref$hasFilter,
      _ref$hasGradient = _ref.hasGradient,
      hasGradient = _ref$hasGradient === void 0 ? false : _ref$hasGradient,
      _ref$hasClipPath = _ref.hasClipPath,
      hasClipPath = _ref$hasClipPath === void 0 ? false : _ref$hasClipPath;

  var idx = hasTexture | hasFilter << 1 | hasGradient << 2 | hasClipPath << 3;
  var program = renderer[_shaders][idx];

  if (Array.isArray(program)) {
    program = renderer.createProgram.apply(renderer, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(program));
    renderer[_shaders][idx] = program;
  }

  if (renderer.program !== program) {
    renderer.useProgram(program, {
      a_color: {
        type: 'UNSIGNED_BYTE',
        normalize: true
      }
    });
  }
}
var cloudShaders = [];
function createCloudShaders(renderer) {
  for (var i = 0; i < 64; i++) {
    var defines = [];
    var hasTexture = !!(i & 0x1);
    var hasFilter = !!(i & 0x2);
    var hasGradient = !!(i & 0x4);
    var hasCloudColor = !!(i & 0x8);
    var hasCloudFilter = !!(i & 0x10);
    var hasClipPath = !!(i & 0x20);
    if (hasTexture) defines.push('#define TEXTURE 1');
    if (hasFilter) defines.push('#define FILTER 1');
    if (hasGradient) defines.push('#define GRADIENT 1');
    if (hasCloudColor) defines.push('#define CLOUDCOLOR 1');
    if (hasCloudFilter) defines.push('#define CLOUDFILTER 1');
    if (hasClipPath) defines.push('#define CLIPPATH 1');
    var prefix = "".concat(defines.join('\n'), "\n");
    var samplerDef = [];

    if (hasTexture) {
      samplerDef.push('uniform sampler2D u_texSampler;');

      for (var j = 0; j < 12; j++) {
        samplerDef.push("uniform sampler2D u_texFrame".concat(j, ";"));
      }
    }

    if (hasClipPath) {
      samplerDef.push('uniform sampler2D u_clipSampler;');
    }

    cloudShaders[i] = [prefix + samplerDef.join('\n') + _shader_cloud_frag__WEBPACK_IMPORTED_MODULE_4__["default"], prefix + _shader_cloud_vert__WEBPACK_IMPORTED_MODULE_3__["default"]]; // renderer.createProgram(prefix + samplerDef.join('\n') + fragShaderCloud, prefix + vertShaderCloud);
  }
}
function applyCloudShader(renderer) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$hasTexture = _ref2.hasTexture,
      hasTexture = _ref2$hasTexture === void 0 ? false : _ref2$hasTexture,
      _ref2$hasFilter = _ref2.hasFilter,
      hasFilter = _ref2$hasFilter === void 0 ? false : _ref2$hasFilter,
      _ref2$hasGradient = _ref2.hasGradient,
      hasGradient = _ref2$hasGradient === void 0 ? false : _ref2$hasGradient,
      _ref2$hasCloudColor = _ref2.hasCloudColor,
      hasCloudColor = _ref2$hasCloudColor === void 0 ? false : _ref2$hasCloudColor,
      _ref2$hasCloudFilter = _ref2.hasCloudFilter,
      hasCloudFilter = _ref2$hasCloudFilter === void 0 ? false : _ref2$hasCloudFilter,
      _ref2$hasClipPath = _ref2.hasClipPath,
      hasClipPath = _ref2$hasClipPath === void 0 ? false : _ref2$hasClipPath;

  var idx = hasTexture | hasFilter << 1 | hasGradient << 2 | hasCloudColor << 3 | hasCloudFilter << 4 | hasClipPath << 5;
  var program = cloudShaders[idx];

  if (Array.isArray(program)) {
    program = renderer.createProgram.apply(renderer, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(program));
    cloudShaders[idx] = program;
  }

  if (renderer.program !== program) {
    renderer.useProgram(program, {
      a_color: {
        type: 'UNSIGNED_BYTE',
        normalize: true
      },
      a_fillCloudColor: {
        type: 'UNSIGNED_BYTE',
        normalize: true
      },
      a_strokeCloudColor: {
        type: 'UNSIGNED_BYTE',
        normalize: true
      },
      a_frameIndex: {
        type: 'UNSIGNED_BYTE',
        normalize: false
      }
    });
  }
}

/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("attribute vec3 a_vertexPosition;\nattribute vec4 a_color;\nvarying vec4 vColor;\nvarying float flagBackground;\nuniform vec2 u_resolution;\nuniform mat3 viewMatrix;\nuniform mat3 projectionMatrix;\n\n#ifdef TEXTURE\nattribute vec3 a_vertexTextureCoord;\nvarying vec3 vTextureCoord;\nattribute vec4 a_sourceRect;\nvarying vec4 vSourceRect;\n#endif\n\n#ifdef CLIPPATH\nattribute vec2 a_clipUV;\nvarying vec2 vClipUV;\n#endif\n\n#ifdef GRADIENT\nuniform float u_radialGradientVector[6];\nvarying vec3 vGradientVector1;\nvarying vec3 vGradientVector2;\n#endif\n\nvoid main() {\n  gl_PointSize = 1.0;\n\n  vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);\n  gl_Position = vec4(pos.xy, 1.0, 1.0);\n\n#ifdef GRADIENT\n  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);\n  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);\n  float h = u_resolution.y;\n  vg1.y = h - vg1.y;\n  vg2.y = h - vg2.y;\n  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);\n  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);\n#endif\n  \n  flagBackground = a_vertexPosition.z;\n  vColor = a_color;\n\n#ifdef TEXTURE\n  vTextureCoord = a_vertexTextureCoord;\n  vSourceRect = a_sourceRect;\n#endif\n\n#ifdef CLIPPATH\n  vClipUV = a_clipUV;\n#endif\n}");

/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("precision mediump float;\n\nvarying vec4 vColor;\nvarying float flagBackground;\n\n#ifdef TEXTURE\nvarying vec3 vTextureCoord;\nvarying vec4 vSourceRect;\n#endif\n\n#ifdef CLIPPATH\nvarying vec2 vClipUV;\n#endif\n\n#ifdef FILTER\nuniform int u_filterFlag;\nuniform float u_colorMatrix[20];\n#endif\n\n#ifdef GRADIENT\nvarying vec3 vGradientVector1;\nvarying vec3 vGradientVector2;\nuniform float u_colorSteps[40];\nuniform int u_gradientType;\n// uniform float u_radialGradientVector[6];\n\nvoid gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {\n  float t;\n  // center circle radius\n  float cr = gv1.z;\n  // focal circle radius\n  float fr = gv2.z;\n\n  if(cr > 0.0 || fr > 0.0) {\n    // radial gradient\n    vec2 center = gv1.xy;\n    vec2 focal = gv2.xy;\n    float x = focal.x - gl_FragCoord.x;\n    float y = focal.y - gl_FragCoord.y;\n    float dx = focal.x - center.x;\n    float dy = focal.y - center.y;\n    float dr = cr - fr;\n    float a = dx * dx + dy * dy - dr * dr;\n    float b = -2.0 * (y * dy + x * dx + fr * dr);\n    float c = x * x + y * y - fr * fr;\n    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));\n  } else {\n    // linear gradient\n    vec2 v1 = gl_FragCoord.xy - gv1.xy;\n    vec2 v2 = gv2.xy - gv1.xy;\n    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);\n  }\n\n  vec4 colors[8];\n  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);\n  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);\n  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);\n  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);\n  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);\n  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);\n  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);\n  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);\n  \n  float steps[8];\n  steps[0] = colorSteps[0];\n  steps[1] = colorSteps[5];\n  steps[2] = colorSteps[10];\n  steps[3] = colorSteps[15];\n  steps[4] = colorSteps[20];\n  steps[5] = colorSteps[25];\n  steps[6] = colorSteps[30];\n  steps[7] = colorSteps[35];\n\n  color = colors[0];\n  for (int i = 1; i < 8; i++) {\n    if (steps[i] < 0.0 || steps[i] > 1.0) {\n      break;\n    }\n    if(steps[i] == steps[i - 1]) {\n      color = colors[i];\n    } else {\n      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));\n    }\n    if (steps[i] >= t) {\n      break;\n    }\n  }\n}\n#endif\n\n#ifdef FILTER\nvoid transformColor(inout vec4 color, in float colorMatrix[20]) {\n  float r = color.r, g = color.g, b = color.b, a = color.a;\n  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];\n  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];\n  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];\n  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];\n}\n#endif\n\nvoid main() {\n  vec4 color = vColor;\n  float opacity = abs(flagBackground);\n\n#ifdef GRADIENT\n  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {\n    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);\n  }\n#endif\n\n  if(opacity < 1.0) {\n    color.a *= opacity;\n  }\n\n#ifdef TEXTURE\n  if(flagBackground > 0.0) {\n    vec3 texCoord = vTextureCoord;\n\n    if(texCoord.z == 1.0) {\n      texCoord = fract(texCoord);\n    }\n\n    if(texCoord.x <= 1.0 && texCoord.x >= 0.0\n      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {\n      if(vSourceRect.z > 0.0) {\n        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;\n        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);\n      }\n      vec4 texColor = texture2D(u_texSampler, texCoord.xy);\n      float alpha = texColor.a;\n      if(opacity < 1.0) {\n        texColor.a *= opacity;\n        alpha *= mix(0.465, 1.0, opacity);\n      }\n      // color = mix(color, texColor, texColor.a);\n      color.rgb = mix(color.rgb, texColor.rgb, alpha);\n      // color.rgb = mix(texColor.rgb, color.rgb, color.a);\n      color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));\n      color.a = texColor.a + (1.0 - texColor.a) * color.a;\n    }\n  }\n#endif\n\n#ifdef FILTER\n  if(u_filterFlag > 0) {\n    transformColor(color, u_colorMatrix);\n  }\n#endif\n\n#ifdef CLIPPATH\n  float clip = texture2D(u_clipSampler, vClipUV).r;\n  color *= clip;\n#endif\n\n  gl_FragColor = color;\n}");

/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("attribute vec3 a_vertexPosition;\nattribute vec4 a_color;\nvarying vec4 vColor;\nvarying float flagBackground;\nattribute vec3 a_transform0;\nattribute vec3 a_transform1;\nuniform vec2 u_resolution;\nuniform mat3 viewMatrix;\nuniform mat3 projectionMatrix;\n\n#ifdef TEXTURE\nattribute vec3 a_vertexTextureCoord;\nvarying vec3 vTextureCoord;\nattribute float a_frameIndex;\nvarying float frameIndex;\nattribute vec4 a_sourceRect;\nvarying vec4 vSourceRect;\n#endif\n\n#ifdef CLIPPATH\nattribute vec2 a_clipUV;\nvarying vec2 vClipUV;\n#endif\n\n#ifdef CLOUDFILTER\nattribute vec4 a_colorCloud0;\nattribute vec4 a_colorCloud1;\nattribute vec4 a_colorCloud2;\nattribute vec4 a_colorCloud3;\nattribute vec4 a_colorCloud4;\nvarying vec4 colorCloud0;\nvarying vec4 colorCloud1;\nvarying vec4 colorCloud2;\nvarying vec4 colorCloud3;\nvarying vec4 colorCloud4;\n#endif\n\n#ifdef CLOUDCOLOR\nattribute vec4 a_fillCloudColor;\nattribute vec4 a_strokeCloudColor;\n#endif\n\n#ifdef GRADIENT\nuniform float u_radialGradientVector[6];\nvarying vec3 vGradientVector1;\nvarying vec3 vGradientVector2;\n#endif\n\nvoid main() {\n  gl_PointSize = 1.0;\n\n  mat3 modelMatrix = mat3(\n    a_transform0.x, a_transform1.x, 0, \n    a_transform0.y, a_transform1.y, 0,\n    a_transform0.z, a_transform1.z, 1\n  );\n\n  vec3 pos = projectionMatrix * viewMatrix * modelMatrix * vec3(a_vertexPosition.xy, 1.0);\n  gl_Position = vec4(pos.xy, 1.0, 1.0);\n\n#ifdef GRADIENT\n  vec3 vg1 = viewMatrix * vec3(u_radialGradientVector[0], u_radialGradientVector[1], 1.0);\n  vec3 vg2 = viewMatrix * vec3(u_radialGradientVector[3], u_radialGradientVector[4], 1.0);\n  float h = u_resolution.y;\n  vg1.y = h - vg1.y;\n  vg2.y = h - vg2.y;\n  vGradientVector1 = vec3(vg1.xy, u_radialGradientVector[2]);\n  vGradientVector2 = vec3(vg2.xy, u_radialGradientVector[5]);\n#endif\n  \n  flagBackground = a_vertexPosition.z;\n\n#ifdef CLOUDCOLOR\n  if(flagBackground > 0.0) {\n    vColor = mix(a_color, a_fillCloudColor, a_fillCloudColor.a);\n  } else {\n    vColor = mix(a_color, a_strokeCloudColor, a_strokeCloudColor.a);\n  }\n#else\n  vColor = a_color;\n#endif\n\n#ifdef TEXTURE\n  vTextureCoord = a_vertexTextureCoord;\n  frameIndex = a_frameIndex;\n  vSourceRect = a_sourceRect;\n#endif\n\n#ifdef CLIPPATH\n  vClipUV = a_clipUV;\n#endif\n\n#ifdef CLOUDFILTER\n  colorCloud0 = a_colorCloud0;\n  colorCloud1 = a_colorCloud1;\n  colorCloud2 = a_colorCloud2;\n  colorCloud3 = a_colorCloud3;\n  colorCloud4 = a_colorCloud4;\n#endif\n}");

/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("precision mediump float;\n\nvarying vec4 vColor;\nvarying float flagBackground;\n\n#ifdef TEXTURE\nvarying float frameIndex;\nvarying vec3 vTextureCoord;\nvarying vec4 vSourceRect;\n#endif\n\n#ifdef CLIPPATH\nvarying vec2 vClipUV;\n#endif\n\n#ifdef FILTER\nuniform int u_filterFlag;\nuniform float u_colorMatrix[20];\n#endif\n\n#ifdef CLOUDFILTER\nvarying vec4 colorCloud0;\nvarying vec4 colorCloud1;\nvarying vec4 colorCloud2;\nvarying vec4 colorCloud3;\nvarying vec4 colorCloud4;\n#endif\n\n#ifdef GRADIENT\nvarying vec3 vGradientVector1;\nvarying vec3 vGradientVector2;\nuniform float u_colorSteps[40];\nuniform int u_gradientType;\n\nvoid gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {\n  float t;\n  // center circle radius\n  float cr = gv1.z;\n  // focal circle radius\n  float fr = gv2.z;\n\n  if(cr > 0.0 || fr > 0.0) {\n    // radial gradient\n    vec2 center = gv1.xy;\n    vec2 focal = gv2.xy;\n    float x = focal.x - gl_FragCoord.x;\n    float y = focal.y - gl_FragCoord.y;\n    float dx = focal.x - center.x;\n    float dy = focal.y - center.y;\n    float dr = cr - fr;\n    float a = dx * dx + dy * dy - dr * dr;\n    float b = -2.0 * (y * dy + x * dx + fr * dr);\n    float c = x * x + y * y - fr * fr;\n    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));\n  } else {\n    // linear gradient\n    vec2 v1 = gl_FragCoord.xy - gv1.xy;\n    vec2 v2 = gv2.xy - gv1.xy;\n    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);\n  }\n\n  vec4 colors[8];\n  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);\n  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);\n  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);\n  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);\n  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);\n  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);\n  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);\n  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);\n  \n  float steps[8];\n  steps[0] = colorSteps[0];\n  steps[1] = colorSteps[5];\n  steps[2] = colorSteps[10];\n  steps[3] = colorSteps[15];\n  steps[4] = colorSteps[20];\n  steps[5] = colorSteps[25];\n  steps[6] = colorSteps[30];\n  steps[7] = colorSteps[35];\n\n  color = colors[0];\n  for (int i = 1; i < 8; i++) {\n    if (steps[i] < 0.0 || steps[i] > 1.0) {\n      break;\n    }\n    if(steps[i] == steps[i - 1]) {\n      color = colors[i];\n    } else {\n      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));\n    }\n    if (steps[i] >= t) {\n      break;\n    }\n  }\n}\n#endif\n\nvoid transformColor(inout vec4 color, in float colorMatrix[20]) {\n  float r = color.r, g = color.g, b = color.b, a = color.a;\n  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];\n  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];\n  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];\n  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];\n}\n\n#ifdef CLOUDFILTER\nvoid buildCloudColor(inout float colorCloudMatrix[20]) {\n  colorCloudMatrix[0] = colorCloud0[0];\n  colorCloudMatrix[1] = colorCloud1[0];\n  colorCloudMatrix[2] = colorCloud2[0];\n  colorCloudMatrix[3] = colorCloud3[0];\n  colorCloudMatrix[4] = colorCloud4[0];\n\n  colorCloudMatrix[5] = colorCloud0[1];\n  colorCloudMatrix[6] = colorCloud1[1];\n  colorCloudMatrix[7] = colorCloud2[1];\n  colorCloudMatrix[8] = colorCloud3[1];\n  colorCloudMatrix[9] = colorCloud4[1];\n\n  colorCloudMatrix[10] = colorCloud0[2];\n  colorCloudMatrix[11] = colorCloud1[2];\n  colorCloudMatrix[12] = colorCloud2[2];\n  colorCloudMatrix[13] = colorCloud3[2];\n  colorCloudMatrix[14] = colorCloud4[2];\n\n  colorCloudMatrix[15] = colorCloud0[3];\n  colorCloudMatrix[16] = colorCloud1[3];\n  colorCloudMatrix[17] = colorCloud2[3];\n  colorCloudMatrix[18] = colorCloud3[3];\n  colorCloudMatrix[19] = colorCloud4[3];\n}\n#endif\n\nvoid main() {\n  vec4 color = vColor;\n  float opacity = abs(flagBackground);\n\n#ifdef GRADIENT\n  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {\n    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);\n  }\n#endif\n\n  if(opacity < 1.0) {\n    color.a *= opacity;\n  }\n\n#ifdef TEXTURE\n  if(flagBackground > 0.0) {\n    vec3 texCoord = vTextureCoord;\n\n    if(texCoord.z == 1.0) {\n      texCoord = fract(texCoord);\n    }\n\n    if(texCoord.x <= 1.0 && texCoord.x >= 0.0\n      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {\n      if(vSourceRect.z > 0.0) {\n        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;\n        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);\n      }\n      if(frameIndex < 0.0) {\n        vec4 texColor = texture2D(u_texSampler, texCoord.xy);\n        color = mix(color, texColor, texColor.a);\n      } else {\n        int index = int(floor(clamp(0.0, 11.0, frameIndex)));\n        vec4 texColor;\n        if(index == 0) texColor = texture2D(u_texFrame0, texCoord.xy);\n        else if(index == 1) texColor = texture2D(u_texFrame1, texCoord.xy);\n        else if(index == 2) texColor = texture2D(u_texFrame2, texCoord.xy);\n        else if(index == 3) texColor = texture2D(u_texFrame3, texCoord.xy);\n        else if(index == 4) texColor = texture2D(u_texFrame4, texCoord.xy);\n        else if(index == 5) texColor = texture2D(u_texFrame5, texCoord.xy);\n        else if(index == 6) texColor = texture2D(u_texFrame6, texCoord.xy);\n        else if(index == 7) texColor = texture2D(u_texFrame7, texCoord.xy);\n        else if(index == 8) texColor = texture2D(u_texFrame8, texCoord.xy);\n        else if(index == 9) texColor = texture2D(u_texFrame9, texCoord.xy);\n        else if(index == 10) texColor = texture2D(u_texFrame10, texCoord.xy);\n        else texColor = texture2D(u_texFrame11, texCoord.xy);\n        float alpha = texColor.a;\n        if(opacity < 1.0) {\n          texColor.a *= opacity;\n          alpha *= mix(0.465, 1.0, opacity);\n        }\n        // color = mix(color, texColor, texColor.a);\n        color.rgb = mix(color.rgb, texColor.rgb, alpha);\n        // color.rgb = mix(texColor.rgb, color.rgb, color.a);\n        color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));\n        color.a = texColor.a + (1.0 - texColor.a) * color.a;\n      }\n    }\n  }\n#endif\n\n#ifdef FILTER\n  if(u_filterFlag > 0) {\n    transformColor(color, u_colorMatrix);\n  }\n#endif\n\n#ifdef CLOUDFILTER\n  float colorCloudMatrix[20];\n  buildCloudColor(colorCloudMatrix);\n  transformColor(color, colorCloudMatrix);\n#endif\n\n#ifdef CLIPPATH\n  float clip = texture2D(u_clipSampler, vClipUV).r;\n  color *= clip;\n#endif\n\n  gl_FragColor = color;\n}");

/***/ })
/******/ ]);
});